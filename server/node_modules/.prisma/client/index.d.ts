
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model App
 * 
 */
export type App = $Result.DefaultSelection<Prisma.$AppPayload>
/**
 * Model Template
 * 
 */
export type Template = $Result.DefaultSelection<Prisma.$TemplatePayload>
/**
 * Model Component
 * 
 */
export type Component = $Result.DefaultSelection<Prisma.$ComponentPayload>
/**
 * Model Workflow
 * 
 */
export type Workflow = $Result.DefaultSelection<Prisma.$WorkflowPayload>
/**
 * Model Otp
 * 
 */
export type Otp = $Result.DefaultSelection<Prisma.$OtpPayload>
/**
 * Model AppSchema
 * 
 */
export type AppSchema = $Result.DefaultSelection<Prisma.$AppSchemaPayload>
/**
 * Model AppField
 * 
 */
export type AppField = $Result.DefaultSelection<Prisma.$AppFieldPayload>
/**
 * Model AppData
 * 
 */
export type AppData = $Result.DefaultSelection<Prisma.$AppDataPayload>
/**
 * Model Video
 * 
 */
export type Video = $Result.DefaultSelection<Prisma.$VideoPayload>
/**
 * Model AppMetric
 * 
 */
export type AppMetric = $Result.DefaultSelection<Prisma.$AppMetricPayload>
/**
 * Model AppIssue
 * 
 */
export type AppIssue = $Result.DefaultSelection<Prisma.$AppIssuePayload>
/**
 * Model AppWarning
 * 
 */
export type AppWarning = $Result.DefaultSelection<Prisma.$AppWarningPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model BlacklistedToken
 * 
 */
export type BlacklistedToken = $Result.DefaultSelection<Prisma.$BlacklistedTokenPayload>
/**
 * Model Canvas
 * 
 */
export type Canvas = $Result.DefaultSelection<Prisma.$CanvasPayload>
/**
 * Model CanvasElement
 * 
 */
export type CanvasElement = $Result.DefaultSelection<Prisma.$CanvasElementPayload>
/**
 * Model ElementInteraction
 * 
 */
export type ElementInteraction = $Result.DefaultSelection<Prisma.$ElementInteractionPayload>
/**
 * Model ElementValidation
 * 
 */
export type ElementValidation = $Result.DefaultSelection<Prisma.$ElementValidationPayload>
/**
 * Model CanvasHistory
 * 
 */
export type CanvasHistory = $Result.DefaultSelection<Prisma.$CanvasHistoryPayload>
/**
 * Model MediaFile
 * 
 */
export type MediaFile = $Result.DefaultSelection<Prisma.$MediaFilePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const FieldType: {
  text: 'text',
  number: 'number',
  date: 'date'
};

export type FieldType = (typeof FieldType)[keyof typeof FieldType]


export const IssueSeverity: {
  severe: 'severe',
  mild: 'mild',
  low: 'low'
};

export type IssueSeverity = (typeof IssueSeverity)[keyof typeof IssueSeverity]


export const IssueStatus: {
  open: 'open',
  resolved: 'resolved'
};

export type IssueStatus = (typeof IssueStatus)[keyof typeof IssueStatus]


export const AppStatus: {
  Draft: 'Draft',
  Published: 'Published',
  Active: 'Active'
};

export type AppStatus = (typeof AppStatus)[keyof typeof AppStatus]


export const ElementType: {
  TEXT_FIELD: 'TEXT_FIELD',
  TEXT_AREA: 'TEXT_AREA',
  DROPDOWN: 'DROPDOWN',
  CHECKBOX: 'CHECKBOX',
  RADIO_BUTTON: 'RADIO_BUTTON',
  PHONE_FIELD: 'PHONE_FIELD',
  TOGGLE: 'TOGGLE',
  DATE_PICKER: 'DATE_PICKER',
  IMAGE: 'IMAGE',
  BUTTON: 'BUTTON',
  UPLOAD_MEDIA: 'UPLOAD_MEDIA',
  ADD_MEDIA: 'ADD_MEDIA',
  SHAPE: 'SHAPE',
  ICON_MINIMIZE: 'ICON_MINIMIZE',
  ICON_MAXIMIZE: 'ICON_MAXIMIZE',
  ICON_CLOSE: 'ICON_CLOSE',
  ICON_SETTINGS: 'ICON_SETTINGS',
  ICON_REFRESH: 'ICON_REFRESH',
  ICON_INFO: 'ICON_INFO',
  ICON_HELP: 'ICON_HELP',
  ICON_SEARCH: 'ICON_SEARCH'
};

export type ElementType = (typeof ElementType)[keyof typeof ElementType]

}

export type FieldType = $Enums.FieldType

export const FieldType: typeof $Enums.FieldType

export type IssueSeverity = $Enums.IssueSeverity

export const IssueSeverity: typeof $Enums.IssueSeverity

export type IssueStatus = $Enums.IssueStatus

export const IssueStatus: typeof $Enums.IssueStatus

export type AppStatus = $Enums.AppStatus

export const AppStatus: typeof $Enums.AppStatus

export type ElementType = $Enums.ElementType

export const ElementType: typeof $Enums.ElementType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.app`: Exposes CRUD operations for the **App** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Apps
    * const apps = await prisma.app.findMany()
    * ```
    */
  get app(): Prisma.AppDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.template`: Exposes CRUD operations for the **Template** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Templates
    * const templates = await prisma.template.findMany()
    * ```
    */
  get template(): Prisma.TemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.component`: Exposes CRUD operations for the **Component** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Components
    * const components = await prisma.component.findMany()
    * ```
    */
  get component(): Prisma.ComponentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.workflow`: Exposes CRUD operations for the **Workflow** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Workflows
    * const workflows = await prisma.workflow.findMany()
    * ```
    */
  get workflow(): Prisma.WorkflowDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.otp`: Exposes CRUD operations for the **Otp** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Otps
    * const otps = await prisma.otp.findMany()
    * ```
    */
  get otp(): Prisma.OtpDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appSchema`: Exposes CRUD operations for the **AppSchema** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppSchemas
    * const appSchemas = await prisma.appSchema.findMany()
    * ```
    */
  get appSchema(): Prisma.AppSchemaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appField`: Exposes CRUD operations for the **AppField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppFields
    * const appFields = await prisma.appField.findMany()
    * ```
    */
  get appField(): Prisma.AppFieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appData`: Exposes CRUD operations for the **AppData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppData
    * const appData = await prisma.appData.findMany()
    * ```
    */
  get appData(): Prisma.AppDataDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.video`: Exposes CRUD operations for the **Video** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Videos
    * const videos = await prisma.video.findMany()
    * ```
    */
  get video(): Prisma.VideoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appMetric`: Exposes CRUD operations for the **AppMetric** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppMetrics
    * const appMetrics = await prisma.appMetric.findMany()
    * ```
    */
  get appMetric(): Prisma.AppMetricDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appIssue`: Exposes CRUD operations for the **AppIssue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppIssues
    * const appIssues = await prisma.appIssue.findMany()
    * ```
    */
  get appIssue(): Prisma.AppIssueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.appWarning`: Exposes CRUD operations for the **AppWarning** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AppWarnings
    * const appWarnings = await prisma.appWarning.findMany()
    * ```
    */
  get appWarning(): Prisma.AppWarningDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.blacklistedToken`: Exposes CRUD operations for the **BlacklistedToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BlacklistedTokens
    * const blacklistedTokens = await prisma.blacklistedToken.findMany()
    * ```
    */
  get blacklistedToken(): Prisma.BlacklistedTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.canvas`: Exposes CRUD operations for the **Canvas** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Canvas
    * const canvas = await prisma.canvas.findMany()
    * ```
    */
  get canvas(): Prisma.CanvasDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.canvasElement`: Exposes CRUD operations for the **CanvasElement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CanvasElements
    * const canvasElements = await prisma.canvasElement.findMany()
    * ```
    */
  get canvasElement(): Prisma.CanvasElementDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.elementInteraction`: Exposes CRUD operations for the **ElementInteraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ElementInteractions
    * const elementInteractions = await prisma.elementInteraction.findMany()
    * ```
    */
  get elementInteraction(): Prisma.ElementInteractionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.elementValidation`: Exposes CRUD operations for the **ElementValidation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ElementValidations
    * const elementValidations = await prisma.elementValidation.findMany()
    * ```
    */
  get elementValidation(): Prisma.ElementValidationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.canvasHistory`: Exposes CRUD operations for the **CanvasHistory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CanvasHistories
    * const canvasHistories = await prisma.canvasHistory.findMany()
    * ```
    */
  get canvasHistory(): Prisma.CanvasHistoryDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mediaFile`: Exposes CRUD operations for the **MediaFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MediaFiles
    * const mediaFiles = await prisma.mediaFile.findMany()
    * ```
    */
  get mediaFile(): Prisma.MediaFileDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.15.0
   * Query Engine version: 85179d7826409ee107a6ba334b5e305ae3fba9fb
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    App: 'App',
    Template: 'Template',
    Component: 'Component',
    Workflow: 'Workflow',
    Otp: 'Otp',
    AppSchema: 'AppSchema',
    AppField: 'AppField',
    AppData: 'AppData',
    Video: 'Video',
    AppMetric: 'AppMetric',
    AppIssue: 'AppIssue',
    AppWarning: 'AppWarning',
    Notification: 'Notification',
    BlacklistedToken: 'BlacklistedToken',
    Canvas: 'Canvas',
    CanvasElement: 'CanvasElement',
    ElementInteraction: 'ElementInteraction',
    ElementValidation: 'ElementValidation',
    CanvasHistory: 'CanvasHistory',
    MediaFile: 'MediaFile'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "app" | "template" | "component" | "workflow" | "otp" | "appSchema" | "appField" | "appData" | "video" | "appMetric" | "appIssue" | "appWarning" | "notification" | "blacklistedToken" | "canvas" | "canvasElement" | "elementInteraction" | "elementValidation" | "canvasHistory" | "mediaFile"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      App: {
        payload: Prisma.$AppPayload<ExtArgs>
        fields: Prisma.AppFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          findFirst: {
            args: Prisma.AppFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          findMany: {
            args: Prisma.AppFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>[]
          }
          create: {
            args: Prisma.AppCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          createMany: {
            args: Prisma.AppCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>[]
          }
          delete: {
            args: Prisma.AppDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          update: {
            args: Prisma.AppUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          deleteMany: {
            args: Prisma.AppDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>[]
          }
          upsert: {
            args: Prisma.AppUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppPayload>
          }
          aggregate: {
            args: Prisma.AppAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateApp>
          }
          groupBy: {
            args: Prisma.AppGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppCountArgs<ExtArgs>
            result: $Utils.Optional<AppCountAggregateOutputType> | number
          }
        }
      }
      Template: {
        payload: Prisma.$TemplatePayload<ExtArgs>
        fields: Prisma.TemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findFirst: {
            args: Prisma.TemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          findMany: {
            args: Prisma.TemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          create: {
            args: Prisma.TemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          createMany: {
            args: Prisma.TemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          delete: {
            args: Prisma.TemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          update: {
            args: Prisma.TemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          deleteMany: {
            args: Prisma.TemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>[]
          }
          upsert: {
            args: Prisma.TemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TemplatePayload>
          }
          aggregate: {
            args: Prisma.TemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTemplate>
          }
          groupBy: {
            args: Prisma.TemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<TemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.TemplateCountArgs<ExtArgs>
            result: $Utils.Optional<TemplateCountAggregateOutputType> | number
          }
        }
      }
      Component: {
        payload: Prisma.$ComponentPayload<ExtArgs>
        fields: Prisma.ComponentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComponentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComponentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          findFirst: {
            args: Prisma.ComponentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComponentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          findMany: {
            args: Prisma.ComponentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>[]
          }
          create: {
            args: Prisma.ComponentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          createMany: {
            args: Prisma.ComponentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComponentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>[]
          }
          delete: {
            args: Prisma.ComponentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          update: {
            args: Prisma.ComponentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          deleteMany: {
            args: Prisma.ComponentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComponentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComponentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>[]
          }
          upsert: {
            args: Prisma.ComponentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComponentPayload>
          }
          aggregate: {
            args: Prisma.ComponentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComponent>
          }
          groupBy: {
            args: Prisma.ComponentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComponentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComponentCountArgs<ExtArgs>
            result: $Utils.Optional<ComponentCountAggregateOutputType> | number
          }
        }
      }
      Workflow: {
        payload: Prisma.$WorkflowPayload<ExtArgs>
        fields: Prisma.WorkflowFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WorkflowFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WorkflowFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findFirst: {
            args: Prisma.WorkflowFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WorkflowFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          findMany: {
            args: Prisma.WorkflowFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          create: {
            args: Prisma.WorkflowCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          createMany: {
            args: Prisma.WorkflowCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WorkflowCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          delete: {
            args: Prisma.WorkflowDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          update: {
            args: Prisma.WorkflowUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          deleteMany: {
            args: Prisma.WorkflowDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WorkflowUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WorkflowUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]
          }
          upsert: {
            args: Prisma.WorkflowUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>
          }
          aggregate: {
            args: Prisma.WorkflowAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWorkflow>
          }
          groupBy: {
            args: Prisma.WorkflowGroupByArgs<ExtArgs>
            result: $Utils.Optional<WorkflowGroupByOutputType>[]
          }
          count: {
            args: Prisma.WorkflowCountArgs<ExtArgs>
            result: $Utils.Optional<WorkflowCountAggregateOutputType> | number
          }
        }
      }
      Otp: {
        payload: Prisma.$OtpPayload<ExtArgs>
        fields: Prisma.OtpFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OtpFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OtpFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findFirst: {
            args: Prisma.OtpFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OtpFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          findMany: {
            args: Prisma.OtpFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          create: {
            args: Prisma.OtpCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          createMany: {
            args: Prisma.OtpCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OtpCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          delete: {
            args: Prisma.OtpDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          update: {
            args: Prisma.OtpUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          deleteMany: {
            args: Prisma.OtpDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OtpUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OtpUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>[]
          }
          upsert: {
            args: Prisma.OtpUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OtpPayload>
          }
          aggregate: {
            args: Prisma.OtpAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOtp>
          }
          groupBy: {
            args: Prisma.OtpGroupByArgs<ExtArgs>
            result: $Utils.Optional<OtpGroupByOutputType>[]
          }
          count: {
            args: Prisma.OtpCountArgs<ExtArgs>
            result: $Utils.Optional<OtpCountAggregateOutputType> | number
          }
        }
      }
      AppSchema: {
        payload: Prisma.$AppSchemaPayload<ExtArgs>
        fields: Prisma.AppSchemaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppSchemaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSchemaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppSchemaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSchemaPayload>
          }
          findFirst: {
            args: Prisma.AppSchemaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSchemaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppSchemaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSchemaPayload>
          }
          findMany: {
            args: Prisma.AppSchemaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSchemaPayload>[]
          }
          create: {
            args: Prisma.AppSchemaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSchemaPayload>
          }
          createMany: {
            args: Prisma.AppSchemaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppSchemaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSchemaPayload>[]
          }
          delete: {
            args: Prisma.AppSchemaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSchemaPayload>
          }
          update: {
            args: Prisma.AppSchemaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSchemaPayload>
          }
          deleteMany: {
            args: Prisma.AppSchemaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppSchemaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppSchemaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSchemaPayload>[]
          }
          upsert: {
            args: Prisma.AppSchemaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppSchemaPayload>
          }
          aggregate: {
            args: Prisma.AppSchemaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppSchema>
          }
          groupBy: {
            args: Prisma.AppSchemaGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppSchemaGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppSchemaCountArgs<ExtArgs>
            result: $Utils.Optional<AppSchemaCountAggregateOutputType> | number
          }
        }
      }
      AppField: {
        payload: Prisma.$AppFieldPayload<ExtArgs>
        fields: Prisma.AppFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFieldPayload>
          }
          findFirst: {
            args: Prisma.AppFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFieldPayload>
          }
          findMany: {
            args: Prisma.AppFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFieldPayload>[]
          }
          create: {
            args: Prisma.AppFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFieldPayload>
          }
          createMany: {
            args: Prisma.AppFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFieldPayload>[]
          }
          delete: {
            args: Prisma.AppFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFieldPayload>
          }
          update: {
            args: Prisma.AppFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFieldPayload>
          }
          deleteMany: {
            args: Prisma.AppFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppFieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFieldPayload>[]
          }
          upsert: {
            args: Prisma.AppFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppFieldPayload>
          }
          aggregate: {
            args: Prisma.AppFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppField>
          }
          groupBy: {
            args: Prisma.AppFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppFieldCountArgs<ExtArgs>
            result: $Utils.Optional<AppFieldCountAggregateOutputType> | number
          }
        }
      }
      AppData: {
        payload: Prisma.$AppDataPayload<ExtArgs>
        fields: Prisma.AppDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDataPayload>
          }
          findFirst: {
            args: Prisma.AppDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDataPayload>
          }
          findMany: {
            args: Prisma.AppDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDataPayload>[]
          }
          create: {
            args: Prisma.AppDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDataPayload>
          }
          createMany: {
            args: Prisma.AppDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDataPayload>[]
          }
          delete: {
            args: Prisma.AppDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDataPayload>
          }
          update: {
            args: Prisma.AppDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDataPayload>
          }
          deleteMany: {
            args: Prisma.AppDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppDataUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDataPayload>[]
          }
          upsert: {
            args: Prisma.AppDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppDataPayload>
          }
          aggregate: {
            args: Prisma.AppDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppData>
          }
          groupBy: {
            args: Prisma.AppDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppDataCountArgs<ExtArgs>
            result: $Utils.Optional<AppDataCountAggregateOutputType> | number
          }
        }
      }
      Video: {
        payload: Prisma.$VideoPayload<ExtArgs>
        fields: Prisma.VideoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VideoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VideoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findFirst: {
            args: Prisma.VideoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VideoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          findMany: {
            args: Prisma.VideoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          create: {
            args: Prisma.VideoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          createMany: {
            args: Prisma.VideoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VideoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          delete: {
            args: Prisma.VideoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          update: {
            args: Prisma.VideoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          deleteMany: {
            args: Prisma.VideoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VideoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VideoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>[]
          }
          upsert: {
            args: Prisma.VideoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VideoPayload>
          }
          aggregate: {
            args: Prisma.VideoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVideo>
          }
          groupBy: {
            args: Prisma.VideoGroupByArgs<ExtArgs>
            result: $Utils.Optional<VideoGroupByOutputType>[]
          }
          count: {
            args: Prisma.VideoCountArgs<ExtArgs>
            result: $Utils.Optional<VideoCountAggregateOutputType> | number
          }
        }
      }
      AppMetric: {
        payload: Prisma.$AppMetricPayload<ExtArgs>
        fields: Prisma.AppMetricFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppMetricFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppMetricPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppMetricFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppMetricPayload>
          }
          findFirst: {
            args: Prisma.AppMetricFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppMetricPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppMetricFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppMetricPayload>
          }
          findMany: {
            args: Prisma.AppMetricFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppMetricPayload>[]
          }
          create: {
            args: Prisma.AppMetricCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppMetricPayload>
          }
          createMany: {
            args: Prisma.AppMetricCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppMetricCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppMetricPayload>[]
          }
          delete: {
            args: Prisma.AppMetricDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppMetricPayload>
          }
          update: {
            args: Prisma.AppMetricUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppMetricPayload>
          }
          deleteMany: {
            args: Prisma.AppMetricDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppMetricUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppMetricUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppMetricPayload>[]
          }
          upsert: {
            args: Prisma.AppMetricUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppMetricPayload>
          }
          aggregate: {
            args: Prisma.AppMetricAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppMetric>
          }
          groupBy: {
            args: Prisma.AppMetricGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppMetricGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppMetricCountArgs<ExtArgs>
            result: $Utils.Optional<AppMetricCountAggregateOutputType> | number
          }
        }
      }
      AppIssue: {
        payload: Prisma.$AppIssuePayload<ExtArgs>
        fields: Prisma.AppIssueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppIssueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIssuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppIssueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIssuePayload>
          }
          findFirst: {
            args: Prisma.AppIssueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIssuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppIssueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIssuePayload>
          }
          findMany: {
            args: Prisma.AppIssueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIssuePayload>[]
          }
          create: {
            args: Prisma.AppIssueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIssuePayload>
          }
          createMany: {
            args: Prisma.AppIssueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppIssueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIssuePayload>[]
          }
          delete: {
            args: Prisma.AppIssueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIssuePayload>
          }
          update: {
            args: Prisma.AppIssueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIssuePayload>
          }
          deleteMany: {
            args: Prisma.AppIssueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppIssueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppIssueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIssuePayload>[]
          }
          upsert: {
            args: Prisma.AppIssueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppIssuePayload>
          }
          aggregate: {
            args: Prisma.AppIssueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppIssue>
          }
          groupBy: {
            args: Prisma.AppIssueGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppIssueGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppIssueCountArgs<ExtArgs>
            result: $Utils.Optional<AppIssueCountAggregateOutputType> | number
          }
        }
      }
      AppWarning: {
        payload: Prisma.$AppWarningPayload<ExtArgs>
        fields: Prisma.AppWarningFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AppWarningFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppWarningPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AppWarningFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppWarningPayload>
          }
          findFirst: {
            args: Prisma.AppWarningFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppWarningPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AppWarningFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppWarningPayload>
          }
          findMany: {
            args: Prisma.AppWarningFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppWarningPayload>[]
          }
          create: {
            args: Prisma.AppWarningCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppWarningPayload>
          }
          createMany: {
            args: Prisma.AppWarningCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AppWarningCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppWarningPayload>[]
          }
          delete: {
            args: Prisma.AppWarningDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppWarningPayload>
          }
          update: {
            args: Prisma.AppWarningUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppWarningPayload>
          }
          deleteMany: {
            args: Prisma.AppWarningDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AppWarningUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AppWarningUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppWarningPayload>[]
          }
          upsert: {
            args: Prisma.AppWarningUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AppWarningPayload>
          }
          aggregate: {
            args: Prisma.AppWarningAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAppWarning>
          }
          groupBy: {
            args: Prisma.AppWarningGroupByArgs<ExtArgs>
            result: $Utils.Optional<AppWarningGroupByOutputType>[]
          }
          count: {
            args: Prisma.AppWarningCountArgs<ExtArgs>
            result: $Utils.Optional<AppWarningCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      BlacklistedToken: {
        payload: Prisma.$BlacklistedTokenPayload<ExtArgs>
        fields: Prisma.BlacklistedTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BlacklistedTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BlacklistedTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>
          }
          findFirst: {
            args: Prisma.BlacklistedTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BlacklistedTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>
          }
          findMany: {
            args: Prisma.BlacklistedTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>[]
          }
          create: {
            args: Prisma.BlacklistedTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>
          }
          createMany: {
            args: Prisma.BlacklistedTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BlacklistedTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>[]
          }
          delete: {
            args: Prisma.BlacklistedTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>
          }
          update: {
            args: Prisma.BlacklistedTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>
          }
          deleteMany: {
            args: Prisma.BlacklistedTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BlacklistedTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BlacklistedTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>[]
          }
          upsert: {
            args: Prisma.BlacklistedTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BlacklistedTokenPayload>
          }
          aggregate: {
            args: Prisma.BlacklistedTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBlacklistedToken>
          }
          groupBy: {
            args: Prisma.BlacklistedTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<BlacklistedTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.BlacklistedTokenCountArgs<ExtArgs>
            result: $Utils.Optional<BlacklistedTokenCountAggregateOutputType> | number
          }
        }
      }
      Canvas: {
        payload: Prisma.$CanvasPayload<ExtArgs>
        fields: Prisma.CanvasFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CanvasFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CanvasFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>
          }
          findFirst: {
            args: Prisma.CanvasFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CanvasFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>
          }
          findMany: {
            args: Prisma.CanvasFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>[]
          }
          create: {
            args: Prisma.CanvasCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>
          }
          createMany: {
            args: Prisma.CanvasCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CanvasCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>[]
          }
          delete: {
            args: Prisma.CanvasDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>
          }
          update: {
            args: Prisma.CanvasUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>
          }
          deleteMany: {
            args: Prisma.CanvasDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CanvasUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CanvasUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>[]
          }
          upsert: {
            args: Prisma.CanvasUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasPayload>
          }
          aggregate: {
            args: Prisma.CanvasAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCanvas>
          }
          groupBy: {
            args: Prisma.CanvasGroupByArgs<ExtArgs>
            result: $Utils.Optional<CanvasGroupByOutputType>[]
          }
          count: {
            args: Prisma.CanvasCountArgs<ExtArgs>
            result: $Utils.Optional<CanvasCountAggregateOutputType> | number
          }
        }
      }
      CanvasElement: {
        payload: Prisma.$CanvasElementPayload<ExtArgs>
        fields: Prisma.CanvasElementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CanvasElementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasElementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CanvasElementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasElementPayload>
          }
          findFirst: {
            args: Prisma.CanvasElementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasElementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CanvasElementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasElementPayload>
          }
          findMany: {
            args: Prisma.CanvasElementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasElementPayload>[]
          }
          create: {
            args: Prisma.CanvasElementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasElementPayload>
          }
          createMany: {
            args: Prisma.CanvasElementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CanvasElementCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasElementPayload>[]
          }
          delete: {
            args: Prisma.CanvasElementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasElementPayload>
          }
          update: {
            args: Prisma.CanvasElementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasElementPayload>
          }
          deleteMany: {
            args: Prisma.CanvasElementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CanvasElementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CanvasElementUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasElementPayload>[]
          }
          upsert: {
            args: Prisma.CanvasElementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasElementPayload>
          }
          aggregate: {
            args: Prisma.CanvasElementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCanvasElement>
          }
          groupBy: {
            args: Prisma.CanvasElementGroupByArgs<ExtArgs>
            result: $Utils.Optional<CanvasElementGroupByOutputType>[]
          }
          count: {
            args: Prisma.CanvasElementCountArgs<ExtArgs>
            result: $Utils.Optional<CanvasElementCountAggregateOutputType> | number
          }
        }
      }
      ElementInteraction: {
        payload: Prisma.$ElementInteractionPayload<ExtArgs>
        fields: Prisma.ElementInteractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ElementInteractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementInteractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ElementInteractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementInteractionPayload>
          }
          findFirst: {
            args: Prisma.ElementInteractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementInteractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ElementInteractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementInteractionPayload>
          }
          findMany: {
            args: Prisma.ElementInteractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementInteractionPayload>[]
          }
          create: {
            args: Prisma.ElementInteractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementInteractionPayload>
          }
          createMany: {
            args: Prisma.ElementInteractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ElementInteractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementInteractionPayload>[]
          }
          delete: {
            args: Prisma.ElementInteractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementInteractionPayload>
          }
          update: {
            args: Prisma.ElementInteractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementInteractionPayload>
          }
          deleteMany: {
            args: Prisma.ElementInteractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ElementInteractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ElementInteractionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementInteractionPayload>[]
          }
          upsert: {
            args: Prisma.ElementInteractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementInteractionPayload>
          }
          aggregate: {
            args: Prisma.ElementInteractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateElementInteraction>
          }
          groupBy: {
            args: Prisma.ElementInteractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ElementInteractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ElementInteractionCountArgs<ExtArgs>
            result: $Utils.Optional<ElementInteractionCountAggregateOutputType> | number
          }
        }
      }
      ElementValidation: {
        payload: Prisma.$ElementValidationPayload<ExtArgs>
        fields: Prisma.ElementValidationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ElementValidationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementValidationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ElementValidationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementValidationPayload>
          }
          findFirst: {
            args: Prisma.ElementValidationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementValidationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ElementValidationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementValidationPayload>
          }
          findMany: {
            args: Prisma.ElementValidationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementValidationPayload>[]
          }
          create: {
            args: Prisma.ElementValidationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementValidationPayload>
          }
          createMany: {
            args: Prisma.ElementValidationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ElementValidationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementValidationPayload>[]
          }
          delete: {
            args: Prisma.ElementValidationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementValidationPayload>
          }
          update: {
            args: Prisma.ElementValidationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementValidationPayload>
          }
          deleteMany: {
            args: Prisma.ElementValidationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ElementValidationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ElementValidationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementValidationPayload>[]
          }
          upsert: {
            args: Prisma.ElementValidationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ElementValidationPayload>
          }
          aggregate: {
            args: Prisma.ElementValidationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateElementValidation>
          }
          groupBy: {
            args: Prisma.ElementValidationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ElementValidationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ElementValidationCountArgs<ExtArgs>
            result: $Utils.Optional<ElementValidationCountAggregateOutputType> | number
          }
        }
      }
      CanvasHistory: {
        payload: Prisma.$CanvasHistoryPayload<ExtArgs>
        fields: Prisma.CanvasHistoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CanvasHistoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasHistoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CanvasHistoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasHistoryPayload>
          }
          findFirst: {
            args: Prisma.CanvasHistoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasHistoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CanvasHistoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasHistoryPayload>
          }
          findMany: {
            args: Prisma.CanvasHistoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasHistoryPayload>[]
          }
          create: {
            args: Prisma.CanvasHistoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasHistoryPayload>
          }
          createMany: {
            args: Prisma.CanvasHistoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CanvasHistoryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasHistoryPayload>[]
          }
          delete: {
            args: Prisma.CanvasHistoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasHistoryPayload>
          }
          update: {
            args: Prisma.CanvasHistoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasHistoryPayload>
          }
          deleteMany: {
            args: Prisma.CanvasHistoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CanvasHistoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CanvasHistoryUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasHistoryPayload>[]
          }
          upsert: {
            args: Prisma.CanvasHistoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CanvasHistoryPayload>
          }
          aggregate: {
            args: Prisma.CanvasHistoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCanvasHistory>
          }
          groupBy: {
            args: Prisma.CanvasHistoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<CanvasHistoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.CanvasHistoryCountArgs<ExtArgs>
            result: $Utils.Optional<CanvasHistoryCountAggregateOutputType> | number
          }
        }
      }
      MediaFile: {
        payload: Prisma.$MediaFilePayload<ExtArgs>
        fields: Prisma.MediaFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MediaFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MediaFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          findFirst: {
            args: Prisma.MediaFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MediaFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          findMany: {
            args: Prisma.MediaFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>[]
          }
          create: {
            args: Prisma.MediaFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          createMany: {
            args: Prisma.MediaFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MediaFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>[]
          }
          delete: {
            args: Prisma.MediaFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          update: {
            args: Prisma.MediaFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          deleteMany: {
            args: Prisma.MediaFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MediaFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MediaFileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>[]
          }
          upsert: {
            args: Prisma.MediaFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MediaFilePayload>
          }
          aggregate: {
            args: Prisma.MediaFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMediaFile>
          }
          groupBy: {
            args: Prisma.MediaFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<MediaFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.MediaFileCountArgs<ExtArgs>
            result: $Utils.Optional<MediaFileCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    app?: AppOmit
    template?: TemplateOmit
    component?: ComponentOmit
    workflow?: WorkflowOmit
    otp?: OtpOmit
    appSchema?: AppSchemaOmit
    appField?: AppFieldOmit
    appData?: AppDataOmit
    video?: VideoOmit
    appMetric?: AppMetricOmit
    appIssue?: AppIssueOmit
    appWarning?: AppWarningOmit
    notification?: NotificationOmit
    blacklistedToken?: BlacklistedTokenOmit
    canvas?: CanvasOmit
    canvasElement?: CanvasElementOmit
    elementInteraction?: ElementInteractionOmit
    elementValidation?: ElementValidationOmit
    canvasHistory?: CanvasHistoryOmit
    mediaFile?: MediaFileOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    apps: number
    notifications: number
    canvasHistory: number
    mediaFiles: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apps?: boolean | UserCountOutputTypeCountAppsArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    canvasHistory?: boolean | UserCountOutputTypeCountCanvasHistoryArgs
    mediaFiles?: boolean | UserCountOutputTypeCountMediaFilesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCanvasHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasHistoryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMediaFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaFileWhereInput
  }


  /**
   * Count Type AppCountOutputType
   */

  export type AppCountOutputType = {
    components: number
    workflows: number
    schemas: number
    metrics: number
    issues: number
    warnings: number
    mediaFiles: number
  }

  export type AppCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    components?: boolean | AppCountOutputTypeCountComponentsArgs
    workflows?: boolean | AppCountOutputTypeCountWorkflowsArgs
    schemas?: boolean | AppCountOutputTypeCountSchemasArgs
    metrics?: boolean | AppCountOutputTypeCountMetricsArgs
    issues?: boolean | AppCountOutputTypeCountIssuesArgs
    warnings?: boolean | AppCountOutputTypeCountWarningsArgs
    mediaFiles?: boolean | AppCountOutputTypeCountMediaFilesArgs
  }

  // Custom InputTypes
  /**
   * AppCountOutputType without action
   */
  export type AppCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppCountOutputType
     */
    select?: AppCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppCountOutputType without action
   */
  export type AppCountOutputTypeCountComponentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentWhereInput
  }

  /**
   * AppCountOutputType without action
   */
  export type AppCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
  }

  /**
   * AppCountOutputType without action
   */
  export type AppCountOutputTypeCountSchemasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppSchemaWhereInput
  }

  /**
   * AppCountOutputType without action
   */
  export type AppCountOutputTypeCountMetricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppMetricWhereInput
  }

  /**
   * AppCountOutputType without action
   */
  export type AppCountOutputTypeCountIssuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppIssueWhereInput
  }

  /**
   * AppCountOutputType without action
   */
  export type AppCountOutputTypeCountWarningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppWarningWhereInput
  }

  /**
   * AppCountOutputType without action
   */
  export type AppCountOutputTypeCountMediaFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaFileWhereInput
  }


  /**
   * Count Type TemplateCountOutputType
   */

  export type TemplateCountOutputType = {
    apps: number
  }

  export type TemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apps?: boolean | TemplateCountOutputTypeCountAppsArgs
  }

  // Custom InputTypes
  /**
   * TemplateCountOutputType without action
   */
  export type TemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TemplateCountOutputType
     */
    select?: TemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TemplateCountOutputType without action
   */
  export type TemplateCountOutputTypeCountAppsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppWhereInput
  }


  /**
   * Count Type AppSchemaCountOutputType
   */

  export type AppSchemaCountOutputType = {
    data: number
    relatedFields: number
    fields: number
  }

  export type AppSchemaCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    data?: boolean | AppSchemaCountOutputTypeCountDataArgs
    relatedFields?: boolean | AppSchemaCountOutputTypeCountRelatedFieldsArgs
    fields?: boolean | AppSchemaCountOutputTypeCountFieldsArgs
  }

  // Custom InputTypes
  /**
   * AppSchemaCountOutputType without action
   */
  export type AppSchemaCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSchemaCountOutputType
     */
    select?: AppSchemaCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AppSchemaCountOutputType without action
   */
  export type AppSchemaCountOutputTypeCountDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppDataWhereInput
  }

  /**
   * AppSchemaCountOutputType without action
   */
  export type AppSchemaCountOutputTypeCountRelatedFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppFieldWhereInput
  }

  /**
   * AppSchemaCountOutputType without action
   */
  export type AppSchemaCountOutputTypeCountFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppFieldWhereInput
  }


  /**
   * Count Type CanvasCountOutputType
   */

  export type CanvasCountOutputType = {
    elements: number
    history: number
  }

  export type CanvasCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    elements?: boolean | CanvasCountOutputTypeCountElementsArgs
    history?: boolean | CanvasCountOutputTypeCountHistoryArgs
  }

  // Custom InputTypes
  /**
   * CanvasCountOutputType without action
   */
  export type CanvasCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasCountOutputType
     */
    select?: CanvasCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CanvasCountOutputType without action
   */
  export type CanvasCountOutputTypeCountElementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasElementWhereInput
  }

  /**
   * CanvasCountOutputType without action
   */
  export type CanvasCountOutputTypeCountHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasHistoryWhereInput
  }


  /**
   * Count Type CanvasElementCountOutputType
   */

  export type CanvasElementCountOutputType = {
    children: number
    interactions: number
    validations: number
  }

  export type CanvasElementCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | CanvasElementCountOutputTypeCountChildrenArgs
    interactions?: boolean | CanvasElementCountOutputTypeCountInteractionsArgs
    validations?: boolean | CanvasElementCountOutputTypeCountValidationsArgs
  }

  // Custom InputTypes
  /**
   * CanvasElementCountOutputType without action
   */
  export type CanvasElementCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElementCountOutputType
     */
    select?: CanvasElementCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CanvasElementCountOutputType without action
   */
  export type CanvasElementCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasElementWhereInput
  }

  /**
   * CanvasElementCountOutputType without action
   */
  export type CanvasElementCountOutputTypeCountInteractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElementInteractionWhereInput
  }

  /**
   * CanvasElementCountOutputType without action
   */
  export type CanvasElementCountOutputTypeCountValidationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElementValidationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    createdAt: Date | null
    role: string | null
    updatedAt: Date | null
    verified: boolean | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    createdAt: Date | null
    role: string | null
    updatedAt: Date | null
    verified: boolean | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    createdAt: number
    role: number
    updatedAt: number
    verified: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    createdAt?: true
    role?: true
    updatedAt?: true
    verified?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    createdAt?: true
    role?: true
    updatedAt?: true
    verified?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    createdAt?: true
    role?: true
    updatedAt?: true
    verified?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    createdAt: Date
    role: string
    updatedAt: Date
    verified: boolean
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    role?: boolean
    updatedAt?: boolean
    verified?: boolean
    apps?: boolean | User$appsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    canvasHistory?: boolean | User$canvasHistoryArgs<ExtArgs>
    mediaFiles?: boolean | User$mediaFilesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    role?: boolean
    updatedAt?: boolean
    verified?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    role?: boolean
    updatedAt?: boolean
    verified?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    createdAt?: boolean
    role?: boolean
    updatedAt?: boolean
    verified?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "createdAt" | "role" | "updatedAt" | "verified", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apps?: boolean | User$appsArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    canvasHistory?: boolean | User$canvasHistoryArgs<ExtArgs>
    mediaFiles?: boolean | User$mediaFilesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      apps: Prisma.$AppPayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      canvasHistory: Prisma.$CanvasHistoryPayload<ExtArgs>[]
      mediaFiles: Prisma.$MediaFilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      createdAt: Date
      role: string
      updatedAt: Date
      verified: boolean
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apps<T extends User$appsArgs<ExtArgs> = {}>(args?: Subset<T, User$appsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    canvasHistory<T extends User$canvasHistoryArgs<ExtArgs> = {}>(args?: Subset<T, User$canvasHistoryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    mediaFiles<T extends User$mediaFilesArgs<ExtArgs> = {}>(args?: Subset<T, User$mediaFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'String'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly verified: FieldRef<"User", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.apps
   */
  export type User$appsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    where?: AppWhereInput
    orderBy?: AppOrderByWithRelationInput | AppOrderByWithRelationInput[]
    cursor?: AppWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppScalarFieldEnum | AppScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.canvasHistory
   */
  export type User$canvasHistoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasHistory
     */
    select?: CanvasHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasHistory
     */
    omit?: CanvasHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasHistoryInclude<ExtArgs> | null
    where?: CanvasHistoryWhereInput
    orderBy?: CanvasHistoryOrderByWithRelationInput | CanvasHistoryOrderByWithRelationInput[]
    cursor?: CanvasHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvasHistoryScalarFieldEnum | CanvasHistoryScalarFieldEnum[]
  }

  /**
   * User.mediaFiles
   */
  export type User$mediaFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    where?: MediaFileWhereInput
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    cursor?: MediaFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model App
   */

  export type AggregateApp = {
    _count: AppCountAggregateOutputType | null
    _avg: AppAvgAggregateOutputType | null
    _sum: AppSumAggregateOutputType | null
    _min: AppMinAggregateOutputType | null
    _max: AppMaxAggregateOutputType | null
  }

  export type AppAvgAggregateOutputType = {
    id: number | null
    ownerId: number | null
    templateId: number | null
  }

  export type AppSumAggregateOutputType = {
    id: number | null
    ownerId: number | null
    templateId: number | null
  }

  export type AppMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    status: $Enums.AppStatus | null
    archived: boolean | null
    ownerId: number | null
    templateId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    status: $Enums.AppStatus | null
    archived: boolean | null
    ownerId: number | null
    templateId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AppCountAggregateOutputType = {
    id: number
    name: number
    description: number
    status: number
    archived: number
    ownerId: number
    templateId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AppAvgAggregateInputType = {
    id?: true
    ownerId?: true
    templateId?: true
  }

  export type AppSumAggregateInputType = {
    id?: true
    ownerId?: true
    templateId?: true
  }

  export type AppMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    archived?: true
    ownerId?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    archived?: true
    ownerId?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AppCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    status?: true
    archived?: true
    ownerId?: true
    templateId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AppAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which App to aggregate.
     */
    where?: AppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apps to fetch.
     */
    orderBy?: AppOrderByWithRelationInput | AppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Apps
    **/
    _count?: true | AppCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppMaxAggregateInputType
  }

  export type GetAppAggregateType<T extends AppAggregateArgs> = {
        [P in keyof T & keyof AggregateApp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateApp[P]>
      : GetScalarType<T[P], AggregateApp[P]>
  }




  export type AppGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppWhereInput
    orderBy?: AppOrderByWithAggregationInput | AppOrderByWithAggregationInput[]
    by: AppScalarFieldEnum[] | AppScalarFieldEnum
    having?: AppScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppCountAggregateInputType | true
    _avg?: AppAvgAggregateInputType
    _sum?: AppSumAggregateInputType
    _min?: AppMinAggregateInputType
    _max?: AppMaxAggregateInputType
  }

  export type AppGroupByOutputType = {
    id: number
    name: string
    description: string | null
    status: $Enums.AppStatus
    archived: boolean
    ownerId: number
    templateId: number | null
    createdAt: Date
    updatedAt: Date
    _count: AppCountAggregateOutputType | null
    _avg: AppAvgAggregateOutputType | null
    _sum: AppSumAggregateOutputType | null
    _min: AppMinAggregateOutputType | null
    _max: AppMaxAggregateOutputType | null
  }

  type GetAppGroupByPayload<T extends AppGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppGroupByOutputType[P]>
            : GetScalarType<T[P], AppGroupByOutputType[P]>
        }
      >
    >


  export type AppSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    archived?: boolean
    ownerId?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | App$templateArgs<ExtArgs>
    components?: boolean | App$componentsArgs<ExtArgs>
    workflows?: boolean | App$workflowsArgs<ExtArgs>
    schemas?: boolean | App$schemasArgs<ExtArgs>
    metrics?: boolean | App$metricsArgs<ExtArgs>
    issues?: boolean | App$issuesArgs<ExtArgs>
    warnings?: boolean | App$warningsArgs<ExtArgs>
    canvas?: boolean | App$canvasArgs<ExtArgs>
    mediaFiles?: boolean | App$mediaFilesArgs<ExtArgs>
    _count?: boolean | AppCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["app"]>

  export type AppSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    archived?: boolean
    ownerId?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | App$templateArgs<ExtArgs>
  }, ExtArgs["result"]["app"]>

  export type AppSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    archived?: boolean
    ownerId?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | App$templateArgs<ExtArgs>
  }, ExtArgs["result"]["app"]>

  export type AppSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    status?: boolean
    archived?: boolean
    ownerId?: boolean
    templateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AppOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "status" | "archived" | "ownerId" | "templateId" | "createdAt" | "updatedAt", ExtArgs["result"]["app"]>
  export type AppInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | App$templateArgs<ExtArgs>
    components?: boolean | App$componentsArgs<ExtArgs>
    workflows?: boolean | App$workflowsArgs<ExtArgs>
    schemas?: boolean | App$schemasArgs<ExtArgs>
    metrics?: boolean | App$metricsArgs<ExtArgs>
    issues?: boolean | App$issuesArgs<ExtArgs>
    warnings?: boolean | App$warningsArgs<ExtArgs>
    canvas?: boolean | App$canvasArgs<ExtArgs>
    mediaFiles?: boolean | App$mediaFilesArgs<ExtArgs>
    _count?: boolean | AppCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | App$templateArgs<ExtArgs>
  }
  export type AppIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    template?: boolean | App$templateArgs<ExtArgs>
  }

  export type $AppPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "App"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      template: Prisma.$TemplatePayload<ExtArgs> | null
      components: Prisma.$ComponentPayload<ExtArgs>[]
      workflows: Prisma.$WorkflowPayload<ExtArgs>[]
      schemas: Prisma.$AppSchemaPayload<ExtArgs>[]
      metrics: Prisma.$AppMetricPayload<ExtArgs>[]
      issues: Prisma.$AppIssuePayload<ExtArgs>[]
      warnings: Prisma.$AppWarningPayload<ExtArgs>[]
      canvas: Prisma.$CanvasPayload<ExtArgs> | null
      mediaFiles: Prisma.$MediaFilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string | null
      status: $Enums.AppStatus
      archived: boolean
      ownerId: number
      templateId: number | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["app"]>
    composites: {}
  }

  type AppGetPayload<S extends boolean | null | undefined | AppDefaultArgs> = $Result.GetResult<Prisma.$AppPayload, S>

  type AppCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppCountAggregateInputType | true
    }

  export interface AppDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['App'], meta: { name: 'App' } }
    /**
     * Find zero or one App that matches the filter.
     * @param {AppFindUniqueArgs} args - Arguments to find a App
     * @example
     * // Get one App
     * const app = await prisma.app.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppFindUniqueArgs>(args: SelectSubset<T, AppFindUniqueArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one App that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppFindUniqueOrThrowArgs} args - Arguments to find a App
     * @example
     * // Get one App
     * const app = await prisma.app.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppFindUniqueOrThrowArgs>(args: SelectSubset<T, AppFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first App that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFindFirstArgs} args - Arguments to find a App
     * @example
     * // Get one App
     * const app = await prisma.app.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppFindFirstArgs>(args?: SelectSubset<T, AppFindFirstArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first App that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFindFirstOrThrowArgs} args - Arguments to find a App
     * @example
     * // Get one App
     * const app = await prisma.app.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppFindFirstOrThrowArgs>(args?: SelectSubset<T, AppFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Apps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Apps
     * const apps = await prisma.app.findMany()
     * 
     * // Get first 10 Apps
     * const apps = await prisma.app.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appWithIdOnly = await prisma.app.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppFindManyArgs>(args?: SelectSubset<T, AppFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a App.
     * @param {AppCreateArgs} args - Arguments to create a App.
     * @example
     * // Create one App
     * const App = await prisma.app.create({
     *   data: {
     *     // ... data to create a App
     *   }
     * })
     * 
     */
    create<T extends AppCreateArgs>(args: SelectSubset<T, AppCreateArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Apps.
     * @param {AppCreateManyArgs} args - Arguments to create many Apps.
     * @example
     * // Create many Apps
     * const app = await prisma.app.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppCreateManyArgs>(args?: SelectSubset<T, AppCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Apps and returns the data saved in the database.
     * @param {AppCreateManyAndReturnArgs} args - Arguments to create many Apps.
     * @example
     * // Create many Apps
     * const app = await prisma.app.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Apps and only return the `id`
     * const appWithIdOnly = await prisma.app.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppCreateManyAndReturnArgs>(args?: SelectSubset<T, AppCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a App.
     * @param {AppDeleteArgs} args - Arguments to delete one App.
     * @example
     * // Delete one App
     * const App = await prisma.app.delete({
     *   where: {
     *     // ... filter to delete one App
     *   }
     * })
     * 
     */
    delete<T extends AppDeleteArgs>(args: SelectSubset<T, AppDeleteArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one App.
     * @param {AppUpdateArgs} args - Arguments to update one App.
     * @example
     * // Update one App
     * const app = await prisma.app.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppUpdateArgs>(args: SelectSubset<T, AppUpdateArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Apps.
     * @param {AppDeleteManyArgs} args - Arguments to filter Apps to delete.
     * @example
     * // Delete a few Apps
     * const { count } = await prisma.app.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppDeleteManyArgs>(args?: SelectSubset<T, AppDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Apps
     * const app = await prisma.app.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppUpdateManyArgs>(args: SelectSubset<T, AppUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Apps and returns the data updated in the database.
     * @param {AppUpdateManyAndReturnArgs} args - Arguments to update many Apps.
     * @example
     * // Update many Apps
     * const app = await prisma.app.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Apps and only return the `id`
     * const appWithIdOnly = await prisma.app.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppUpdateManyAndReturnArgs>(args: SelectSubset<T, AppUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one App.
     * @param {AppUpsertArgs} args - Arguments to update or create a App.
     * @example
     * // Update or create a App
     * const app = await prisma.app.upsert({
     *   create: {
     *     // ... data to create a App
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the App we want to update
     *   }
     * })
     */
    upsert<T extends AppUpsertArgs>(args: SelectSubset<T, AppUpsertArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Apps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppCountArgs} args - Arguments to filter Apps to count.
     * @example
     * // Count the number of Apps
     * const count = await prisma.app.count({
     *   where: {
     *     // ... the filter for the Apps we want to count
     *   }
     * })
    **/
    count<T extends AppCountArgs>(
      args?: Subset<T, AppCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a App.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppAggregateArgs>(args: Subset<T, AppAggregateArgs>): Prisma.PrismaPromise<GetAppAggregateType<T>>

    /**
     * Group by App.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppGroupByArgs['orderBy'] }
        : { orderBy?: AppGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the App model
   */
  readonly fields: AppFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for App.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    template<T extends App$templateArgs<ExtArgs> = {}>(args?: Subset<T, App$templateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    components<T extends App$componentsArgs<ExtArgs> = {}>(args?: Subset<T, App$componentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    workflows<T extends App$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, App$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schemas<T extends App$schemasArgs<ExtArgs> = {}>(args?: Subset<T, App$schemasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppSchemaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    metrics<T extends App$metricsArgs<ExtArgs> = {}>(args?: Subset<T, App$metricsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    issues<T extends App$issuesArgs<ExtArgs> = {}>(args?: Subset<T, App$issuesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    warnings<T extends App$warningsArgs<ExtArgs> = {}>(args?: Subset<T, App$warningsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppWarningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    canvas<T extends App$canvasArgs<ExtArgs> = {}>(args?: Subset<T, App$canvasArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mediaFiles<T extends App$mediaFilesArgs<ExtArgs> = {}>(args?: Subset<T, App$mediaFilesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the App model
   */
  interface AppFieldRefs {
    readonly id: FieldRef<"App", 'Int'>
    readonly name: FieldRef<"App", 'String'>
    readonly description: FieldRef<"App", 'String'>
    readonly status: FieldRef<"App", 'AppStatus'>
    readonly archived: FieldRef<"App", 'Boolean'>
    readonly ownerId: FieldRef<"App", 'Int'>
    readonly templateId: FieldRef<"App", 'Int'>
    readonly createdAt: FieldRef<"App", 'DateTime'>
    readonly updatedAt: FieldRef<"App", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * App findUnique
   */
  export type AppFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter, which App to fetch.
     */
    where: AppWhereUniqueInput
  }

  /**
   * App findUniqueOrThrow
   */
  export type AppFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter, which App to fetch.
     */
    where: AppWhereUniqueInput
  }

  /**
   * App findFirst
   */
  export type AppFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter, which App to fetch.
     */
    where?: AppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apps to fetch.
     */
    orderBy?: AppOrderByWithRelationInput | AppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Apps.
     */
    cursor?: AppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Apps.
     */
    distinct?: AppScalarFieldEnum | AppScalarFieldEnum[]
  }

  /**
   * App findFirstOrThrow
   */
  export type AppFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter, which App to fetch.
     */
    where?: AppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apps to fetch.
     */
    orderBy?: AppOrderByWithRelationInput | AppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Apps.
     */
    cursor?: AppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Apps.
     */
    distinct?: AppScalarFieldEnum | AppScalarFieldEnum[]
  }

  /**
   * App findMany
   */
  export type AppFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter, which Apps to fetch.
     */
    where?: AppWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Apps to fetch.
     */
    orderBy?: AppOrderByWithRelationInput | AppOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Apps.
     */
    cursor?: AppWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Apps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Apps.
     */
    skip?: number
    distinct?: AppScalarFieldEnum | AppScalarFieldEnum[]
  }

  /**
   * App create
   */
  export type AppCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * The data needed to create a App.
     */
    data: XOR<AppCreateInput, AppUncheckedCreateInput>
  }

  /**
   * App createMany
   */
  export type AppCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Apps.
     */
    data: AppCreateManyInput | AppCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * App createManyAndReturn
   */
  export type AppCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * The data used to create many Apps.
     */
    data: AppCreateManyInput | AppCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * App update
   */
  export type AppUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * The data needed to update a App.
     */
    data: XOR<AppUpdateInput, AppUncheckedUpdateInput>
    /**
     * Choose, which App to update.
     */
    where: AppWhereUniqueInput
  }

  /**
   * App updateMany
   */
  export type AppUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Apps.
     */
    data: XOR<AppUpdateManyMutationInput, AppUncheckedUpdateManyInput>
    /**
     * Filter which Apps to update
     */
    where?: AppWhereInput
    /**
     * Limit how many Apps to update.
     */
    limit?: number
  }

  /**
   * App updateManyAndReturn
   */
  export type AppUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * The data used to update Apps.
     */
    data: XOR<AppUpdateManyMutationInput, AppUncheckedUpdateManyInput>
    /**
     * Filter which Apps to update
     */
    where?: AppWhereInput
    /**
     * Limit how many Apps to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * App upsert
   */
  export type AppUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * The filter to search for the App to update in case it exists.
     */
    where: AppWhereUniqueInput
    /**
     * In case the App found by the `where` argument doesn't exist, create a new App with this data.
     */
    create: XOR<AppCreateInput, AppUncheckedCreateInput>
    /**
     * In case the App was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppUpdateInput, AppUncheckedUpdateInput>
  }

  /**
   * App delete
   */
  export type AppDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    /**
     * Filter which App to delete.
     */
    where: AppWhereUniqueInput
  }

  /**
   * App deleteMany
   */
  export type AppDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Apps to delete
     */
    where?: AppWhereInput
    /**
     * Limit how many Apps to delete.
     */
    limit?: number
  }

  /**
   * App.template
   */
  export type App$templateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    where?: TemplateWhereInput
  }

  /**
   * App.components
   */
  export type App$componentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    where?: ComponentWhereInput
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    cursor?: ComponentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * App.workflows
   */
  export type App$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    cursor?: WorkflowWhereUniqueInput
    take?: number
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * App.schemas
   */
  export type App$schemasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSchema
     */
    select?: AppSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSchema
     */
    omit?: AppSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSchemaInclude<ExtArgs> | null
    where?: AppSchemaWhereInput
    orderBy?: AppSchemaOrderByWithRelationInput | AppSchemaOrderByWithRelationInput[]
    cursor?: AppSchemaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppSchemaScalarFieldEnum | AppSchemaScalarFieldEnum[]
  }

  /**
   * App.metrics
   */
  export type App$metricsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppMetric
     */
    select?: AppMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppMetric
     */
    omit?: AppMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppMetricInclude<ExtArgs> | null
    where?: AppMetricWhereInput
    orderBy?: AppMetricOrderByWithRelationInput | AppMetricOrderByWithRelationInput[]
    cursor?: AppMetricWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppMetricScalarFieldEnum | AppMetricScalarFieldEnum[]
  }

  /**
   * App.issues
   */
  export type App$issuesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIssue
     */
    select?: AppIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppIssue
     */
    omit?: AppIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIssueInclude<ExtArgs> | null
    where?: AppIssueWhereInput
    orderBy?: AppIssueOrderByWithRelationInput | AppIssueOrderByWithRelationInput[]
    cursor?: AppIssueWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppIssueScalarFieldEnum | AppIssueScalarFieldEnum[]
  }

  /**
   * App.warnings
   */
  export type App$warningsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppWarning
     */
    select?: AppWarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppWarning
     */
    omit?: AppWarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppWarningInclude<ExtArgs> | null
    where?: AppWarningWhereInput
    orderBy?: AppWarningOrderByWithRelationInput | AppWarningOrderByWithRelationInput[]
    cursor?: AppWarningWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppWarningScalarFieldEnum | AppWarningScalarFieldEnum[]
  }

  /**
   * App.canvas
   */
  export type App$canvasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    where?: CanvasWhereInput
  }

  /**
   * App.mediaFiles
   */
  export type App$mediaFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    where?: MediaFileWhereInput
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    cursor?: MediaFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * App without action
   */
  export type AppDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
  }


  /**
   * Model Template
   */

  export type AggregateTemplate = {
    _count: TemplateCountAggregateOutputType | null
    _avg: TemplateAvgAggregateOutputType | null
    _sum: TemplateSumAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  export type TemplateAvgAggregateOutputType = {
    id: number | null
  }

  export type TemplateSumAggregateOutputType = {
    id: number | null
  }

  export type TemplateMinAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    preview_image: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateMaxAggregateOutputType = {
    id: number | null
    name: string | null
    description: string | null
    preview_image: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TemplateCountAggregateOutputType = {
    id: number
    name: number
    description: number
    preview_image: number
    app_schema: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TemplateAvgAggregateInputType = {
    id?: true
  }

  export type TemplateSumAggregateInputType = {
    id?: true
  }

  export type TemplateMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    preview_image?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    preview_image?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TemplateCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    preview_image?: true
    app_schema?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Template to aggregate.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Templates
    **/
    _count?: true | TemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TemplateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TemplateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TemplateMaxAggregateInputType
  }

  export type GetTemplateAggregateType<T extends TemplateAggregateArgs> = {
        [P in keyof T & keyof AggregateTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTemplate[P]>
      : GetScalarType<T[P], AggregateTemplate[P]>
  }




  export type TemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TemplateWhereInput
    orderBy?: TemplateOrderByWithAggregationInput | TemplateOrderByWithAggregationInput[]
    by: TemplateScalarFieldEnum[] | TemplateScalarFieldEnum
    having?: TemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TemplateCountAggregateInputType | true
    _avg?: TemplateAvgAggregateInputType
    _sum?: TemplateSumAggregateInputType
    _min?: TemplateMinAggregateInputType
    _max?: TemplateMaxAggregateInputType
  }

  export type TemplateGroupByOutputType = {
    id: number
    name: string
    description: string
    preview_image: string | null
    app_schema: JsonValue
    category: string
    createdAt: Date
    updatedAt: Date
    _count: TemplateCountAggregateOutputType | null
    _avg: TemplateAvgAggregateOutputType | null
    _sum: TemplateSumAggregateOutputType | null
    _min: TemplateMinAggregateOutputType | null
    _max: TemplateMaxAggregateOutputType | null
  }

  type GetTemplateGroupByPayload<T extends TemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TemplateGroupByOutputType[P]>
            : GetScalarType<T[P], TemplateGroupByOutputType[P]>
        }
      >
    >


  export type TemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    preview_image?: boolean
    app_schema?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    apps?: boolean | Template$appsArgs<ExtArgs>
    _count?: boolean | TemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    preview_image?: boolean
    app_schema?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    preview_image?: boolean
    app_schema?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["template"]>

  export type TemplateSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    preview_image?: boolean
    app_schema?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "description" | "preview_image" | "app_schema" | "category" | "createdAt" | "updatedAt", ExtArgs["result"]["template"]>
  export type TemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    apps?: boolean | Template$appsArgs<ExtArgs>
    _count?: boolean | TemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type TemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Template"
    objects: {
      apps: Prisma.$AppPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      description: string
      preview_image: string | null
      app_schema: Prisma.JsonValue
      category: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["template"]>
    composites: {}
  }

  type TemplateGetPayload<S extends boolean | null | undefined | TemplateDefaultArgs> = $Result.GetResult<Prisma.$TemplatePayload, S>

  type TemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TemplateCountAggregateInputType | true
    }

  export interface TemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Template'], meta: { name: 'Template' } }
    /**
     * Find zero or one Template that matches the filter.
     * @param {TemplateFindUniqueArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TemplateFindUniqueArgs>(args: SelectSubset<T, TemplateFindUniqueArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Template that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TemplateFindUniqueOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, TemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Template that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TemplateFindFirstArgs>(args?: SelectSubset<T, TemplateFindFirstArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Template that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindFirstOrThrowArgs} args - Arguments to find a Template
     * @example
     * // Get one Template
     * const template = await prisma.template.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, TemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Templates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Templates
     * const templates = await prisma.template.findMany()
     * 
     * // Get first 10 Templates
     * const templates = await prisma.template.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const templateWithIdOnly = await prisma.template.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TemplateFindManyArgs>(args?: SelectSubset<T, TemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Template.
     * @param {TemplateCreateArgs} args - Arguments to create a Template.
     * @example
     * // Create one Template
     * const Template = await prisma.template.create({
     *   data: {
     *     // ... data to create a Template
     *   }
     * })
     * 
     */
    create<T extends TemplateCreateArgs>(args: SelectSubset<T, TemplateCreateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Templates.
     * @param {TemplateCreateManyArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const template = await prisma.template.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TemplateCreateManyArgs>(args?: SelectSubset<T, TemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Templates and returns the data saved in the database.
     * @param {TemplateCreateManyAndReturnArgs} args - Arguments to create many Templates.
     * @example
     * // Create many Templates
     * const template = await prisma.template.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Templates and only return the `id`
     * const templateWithIdOnly = await prisma.template.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, TemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Template.
     * @param {TemplateDeleteArgs} args - Arguments to delete one Template.
     * @example
     * // Delete one Template
     * const Template = await prisma.template.delete({
     *   where: {
     *     // ... filter to delete one Template
     *   }
     * })
     * 
     */
    delete<T extends TemplateDeleteArgs>(args: SelectSubset<T, TemplateDeleteArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Template.
     * @param {TemplateUpdateArgs} args - Arguments to update one Template.
     * @example
     * // Update one Template
     * const template = await prisma.template.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TemplateUpdateArgs>(args: SelectSubset<T, TemplateUpdateArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Templates.
     * @param {TemplateDeleteManyArgs} args - Arguments to filter Templates to delete.
     * @example
     * // Delete a few Templates
     * const { count } = await prisma.template.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TemplateDeleteManyArgs>(args?: SelectSubset<T, TemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TemplateUpdateManyArgs>(args: SelectSubset<T, TemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Templates and returns the data updated in the database.
     * @param {TemplateUpdateManyAndReturnArgs} args - Arguments to update many Templates.
     * @example
     * // Update many Templates
     * const template = await prisma.template.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Templates and only return the `id`
     * const templateWithIdOnly = await prisma.template.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, TemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Template.
     * @param {TemplateUpsertArgs} args - Arguments to update or create a Template.
     * @example
     * // Update or create a Template
     * const template = await prisma.template.upsert({
     *   create: {
     *     // ... data to create a Template
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Template we want to update
     *   }
     * })
     */
    upsert<T extends TemplateUpsertArgs>(args: SelectSubset<T, TemplateUpsertArgs<ExtArgs>>): Prisma__TemplateClient<$Result.GetResult<Prisma.$TemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Templates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateCountArgs} args - Arguments to filter Templates to count.
     * @example
     * // Count the number of Templates
     * const count = await prisma.template.count({
     *   where: {
     *     // ... the filter for the Templates we want to count
     *   }
     * })
    **/
    count<T extends TemplateCountArgs>(
      args?: Subset<T, TemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TemplateAggregateArgs>(args: Subset<T, TemplateAggregateArgs>): Prisma.PrismaPromise<GetTemplateAggregateType<T>>

    /**
     * Group by Template.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TemplateGroupByArgs['orderBy'] }
        : { orderBy?: TemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Template model
   */
  readonly fields: TemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Template.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    apps<T extends Template$appsArgs<ExtArgs> = {}>(args?: Subset<T, Template$appsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Template model
   */
  interface TemplateFieldRefs {
    readonly id: FieldRef<"Template", 'Int'>
    readonly name: FieldRef<"Template", 'String'>
    readonly description: FieldRef<"Template", 'String'>
    readonly preview_image: FieldRef<"Template", 'String'>
    readonly app_schema: FieldRef<"Template", 'Json'>
    readonly category: FieldRef<"Template", 'String'>
    readonly createdAt: FieldRef<"Template", 'DateTime'>
    readonly updatedAt: FieldRef<"Template", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Template findUnique
   */
  export type TemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findUniqueOrThrow
   */
  export type TemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template findFirst
   */
  export type TemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findFirstOrThrow
   */
  export type TemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Template to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Templates.
     */
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template findMany
   */
  export type TemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter, which Templates to fetch.
     */
    where?: TemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Templates to fetch.
     */
    orderBy?: TemplateOrderByWithRelationInput | TemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Templates.
     */
    cursor?: TemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Templates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Templates.
     */
    skip?: number
    distinct?: TemplateScalarFieldEnum | TemplateScalarFieldEnum[]
  }

  /**
   * Template create
   */
  export type TemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a Template.
     */
    data: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
  }

  /**
   * Template createMany
   */
  export type TemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Template createManyAndReturn
   */
  export type TemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * The data used to create many Templates.
     */
    data: TemplateCreateManyInput | TemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Template update
   */
  export type TemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a Template.
     */
    data: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
    /**
     * Choose, which Template to update.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template updateMany
   */
  export type TemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to update.
     */
    limit?: number
  }

  /**
   * Template updateManyAndReturn
   */
  export type TemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * The data used to update Templates.
     */
    data: XOR<TemplateUpdateManyMutationInput, TemplateUncheckedUpdateManyInput>
    /**
     * Filter which Templates to update
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to update.
     */
    limit?: number
  }

  /**
   * Template upsert
   */
  export type TemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the Template to update in case it exists.
     */
    where: TemplateWhereUniqueInput
    /**
     * In case the Template found by the `where` argument doesn't exist, create a new Template with this data.
     */
    create: XOR<TemplateCreateInput, TemplateUncheckedCreateInput>
    /**
     * In case the Template was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TemplateUpdateInput, TemplateUncheckedUpdateInput>
  }

  /**
   * Template delete
   */
  export type TemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
    /**
     * Filter which Template to delete.
     */
    where: TemplateWhereUniqueInput
  }

  /**
   * Template deleteMany
   */
  export type TemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Templates to delete
     */
    where?: TemplateWhereInput
    /**
     * Limit how many Templates to delete.
     */
    limit?: number
  }

  /**
   * Template.apps
   */
  export type Template$appsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    where?: AppWhereInput
    orderBy?: AppOrderByWithRelationInput | AppOrderByWithRelationInput[]
    cursor?: AppWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppScalarFieldEnum | AppScalarFieldEnum[]
  }

  /**
   * Template without action
   */
  export type TemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Template
     */
    select?: TemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Template
     */
    omit?: TemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TemplateInclude<ExtArgs> | null
  }


  /**
   * Model Component
   */

  export type AggregateComponent = {
    _count: ComponentCountAggregateOutputType | null
    _avg: ComponentAvgAggregateOutputType | null
    _sum: ComponentSumAggregateOutputType | null
    _min: ComponentMinAggregateOutputType | null
    _max: ComponentMaxAggregateOutputType | null
  }

  export type ComponentAvgAggregateOutputType = {
    id: number | null
    appId: number | null
  }

  export type ComponentSumAggregateOutputType = {
    id: number | null
    appId: number | null
  }

  export type ComponentMinAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    appId: number | null
  }

  export type ComponentMaxAggregateOutputType = {
    id: number | null
    name: string | null
    type: string | null
    appId: number | null
  }

  export type ComponentCountAggregateOutputType = {
    id: number
    name: number
    type: number
    appId: number
    properties: number
    _all: number
  }


  export type ComponentAvgAggregateInputType = {
    id?: true
    appId?: true
  }

  export type ComponentSumAggregateInputType = {
    id?: true
    appId?: true
  }

  export type ComponentMinAggregateInputType = {
    id?: true
    name?: true
    type?: true
    appId?: true
  }

  export type ComponentMaxAggregateInputType = {
    id?: true
    name?: true
    type?: true
    appId?: true
  }

  export type ComponentCountAggregateInputType = {
    id?: true
    name?: true
    type?: true
    appId?: true
    properties?: true
    _all?: true
  }

  export type ComponentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Component to aggregate.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Components
    **/
    _count?: true | ComponentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComponentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComponentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComponentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComponentMaxAggregateInputType
  }

  export type GetComponentAggregateType<T extends ComponentAggregateArgs> = {
        [P in keyof T & keyof AggregateComponent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComponent[P]>
      : GetScalarType<T[P], AggregateComponent[P]>
  }




  export type ComponentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComponentWhereInput
    orderBy?: ComponentOrderByWithAggregationInput | ComponentOrderByWithAggregationInput[]
    by: ComponentScalarFieldEnum[] | ComponentScalarFieldEnum
    having?: ComponentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComponentCountAggregateInputType | true
    _avg?: ComponentAvgAggregateInputType
    _sum?: ComponentSumAggregateInputType
    _min?: ComponentMinAggregateInputType
    _max?: ComponentMaxAggregateInputType
  }

  export type ComponentGroupByOutputType = {
    id: number
    name: string
    type: string
    appId: number
    properties: JsonValue
    _count: ComponentCountAggregateOutputType | null
    _avg: ComponentAvgAggregateOutputType | null
    _sum: ComponentSumAggregateOutputType | null
    _min: ComponentMinAggregateOutputType | null
    _max: ComponentMaxAggregateOutputType | null
  }

  type GetComponentGroupByPayload<T extends ComponentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComponentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComponentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComponentGroupByOutputType[P]>
            : GetScalarType<T[P], ComponentGroupByOutputType[P]>
        }
      >
    >


  export type ComponentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    appId?: boolean
    properties?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["component"]>

  export type ComponentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    appId?: boolean
    properties?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["component"]>

  export type ComponentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    type?: boolean
    appId?: boolean
    properties?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["component"]>

  export type ComponentSelectScalar = {
    id?: boolean
    name?: boolean
    type?: boolean
    appId?: boolean
    properties?: boolean
  }

  export type ComponentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "type" | "appId" | "properties", ExtArgs["result"]["component"]>
  export type ComponentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }
  export type ComponentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }
  export type ComponentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }

  export type $ComponentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Component"
    objects: {
      app: Prisma.$AppPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      type: string
      appId: number
      properties: Prisma.JsonValue
    }, ExtArgs["result"]["component"]>
    composites: {}
  }

  type ComponentGetPayload<S extends boolean | null | undefined | ComponentDefaultArgs> = $Result.GetResult<Prisma.$ComponentPayload, S>

  type ComponentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComponentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComponentCountAggregateInputType | true
    }

  export interface ComponentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Component'], meta: { name: 'Component' } }
    /**
     * Find zero or one Component that matches the filter.
     * @param {ComponentFindUniqueArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComponentFindUniqueArgs>(args: SelectSubset<T, ComponentFindUniqueArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Component that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComponentFindUniqueOrThrowArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComponentFindUniqueOrThrowArgs>(args: SelectSubset<T, ComponentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Component that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindFirstArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComponentFindFirstArgs>(args?: SelectSubset<T, ComponentFindFirstArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Component that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindFirstOrThrowArgs} args - Arguments to find a Component
     * @example
     * // Get one Component
     * const component = await prisma.component.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComponentFindFirstOrThrowArgs>(args?: SelectSubset<T, ComponentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Components that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Components
     * const components = await prisma.component.findMany()
     * 
     * // Get first 10 Components
     * const components = await prisma.component.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const componentWithIdOnly = await prisma.component.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComponentFindManyArgs>(args?: SelectSubset<T, ComponentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Component.
     * @param {ComponentCreateArgs} args - Arguments to create a Component.
     * @example
     * // Create one Component
     * const Component = await prisma.component.create({
     *   data: {
     *     // ... data to create a Component
     *   }
     * })
     * 
     */
    create<T extends ComponentCreateArgs>(args: SelectSubset<T, ComponentCreateArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Components.
     * @param {ComponentCreateManyArgs} args - Arguments to create many Components.
     * @example
     * // Create many Components
     * const component = await prisma.component.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComponentCreateManyArgs>(args?: SelectSubset<T, ComponentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Components and returns the data saved in the database.
     * @param {ComponentCreateManyAndReturnArgs} args - Arguments to create many Components.
     * @example
     * // Create many Components
     * const component = await prisma.component.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Components and only return the `id`
     * const componentWithIdOnly = await prisma.component.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComponentCreateManyAndReturnArgs>(args?: SelectSubset<T, ComponentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Component.
     * @param {ComponentDeleteArgs} args - Arguments to delete one Component.
     * @example
     * // Delete one Component
     * const Component = await prisma.component.delete({
     *   where: {
     *     // ... filter to delete one Component
     *   }
     * })
     * 
     */
    delete<T extends ComponentDeleteArgs>(args: SelectSubset<T, ComponentDeleteArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Component.
     * @param {ComponentUpdateArgs} args - Arguments to update one Component.
     * @example
     * // Update one Component
     * const component = await prisma.component.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComponentUpdateArgs>(args: SelectSubset<T, ComponentUpdateArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Components.
     * @param {ComponentDeleteManyArgs} args - Arguments to filter Components to delete.
     * @example
     * // Delete a few Components
     * const { count } = await prisma.component.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComponentDeleteManyArgs>(args?: SelectSubset<T, ComponentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Components
     * const component = await prisma.component.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComponentUpdateManyArgs>(args: SelectSubset<T, ComponentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Components and returns the data updated in the database.
     * @param {ComponentUpdateManyAndReturnArgs} args - Arguments to update many Components.
     * @example
     * // Update many Components
     * const component = await prisma.component.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Components and only return the `id`
     * const componentWithIdOnly = await prisma.component.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComponentUpdateManyAndReturnArgs>(args: SelectSubset<T, ComponentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Component.
     * @param {ComponentUpsertArgs} args - Arguments to update or create a Component.
     * @example
     * // Update or create a Component
     * const component = await prisma.component.upsert({
     *   create: {
     *     // ... data to create a Component
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Component we want to update
     *   }
     * })
     */
    upsert<T extends ComponentUpsertArgs>(args: SelectSubset<T, ComponentUpsertArgs<ExtArgs>>): Prisma__ComponentClient<$Result.GetResult<Prisma.$ComponentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Components.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentCountArgs} args - Arguments to filter Components to count.
     * @example
     * // Count the number of Components
     * const count = await prisma.component.count({
     *   where: {
     *     // ... the filter for the Components we want to count
     *   }
     * })
    **/
    count<T extends ComponentCountArgs>(
      args?: Subset<T, ComponentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComponentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Component.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComponentAggregateArgs>(args: Subset<T, ComponentAggregateArgs>): Prisma.PrismaPromise<GetComponentAggregateType<T>>

    /**
     * Group by Component.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComponentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComponentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComponentGroupByArgs['orderBy'] }
        : { orderBy?: ComponentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComponentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComponentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Component model
   */
  readonly fields: ComponentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Component.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComponentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app<T extends AppDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppDefaultArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Component model
   */
  interface ComponentFieldRefs {
    readonly id: FieldRef<"Component", 'Int'>
    readonly name: FieldRef<"Component", 'String'>
    readonly type: FieldRef<"Component", 'String'>
    readonly appId: FieldRef<"Component", 'Int'>
    readonly properties: FieldRef<"Component", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Component findUnique
   */
  export type ComponentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component findUniqueOrThrow
   */
  export type ComponentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component findFirst
   */
  export type ComponentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Components.
     */
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Component findFirstOrThrow
   */
  export type ComponentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Component to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Components.
     */
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Component findMany
   */
  export type ComponentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter, which Components to fetch.
     */
    where?: ComponentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Components to fetch.
     */
    orderBy?: ComponentOrderByWithRelationInput | ComponentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Components.
     */
    cursor?: ComponentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Components from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Components.
     */
    skip?: number
    distinct?: ComponentScalarFieldEnum | ComponentScalarFieldEnum[]
  }

  /**
   * Component create
   */
  export type ComponentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The data needed to create a Component.
     */
    data: XOR<ComponentCreateInput, ComponentUncheckedCreateInput>
  }

  /**
   * Component createMany
   */
  export type ComponentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Components.
     */
    data: ComponentCreateManyInput | ComponentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Component createManyAndReturn
   */
  export type ComponentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * The data used to create many Components.
     */
    data: ComponentCreateManyInput | ComponentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Component update
   */
  export type ComponentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The data needed to update a Component.
     */
    data: XOR<ComponentUpdateInput, ComponentUncheckedUpdateInput>
    /**
     * Choose, which Component to update.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component updateMany
   */
  export type ComponentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Components.
     */
    data: XOR<ComponentUpdateManyMutationInput, ComponentUncheckedUpdateManyInput>
    /**
     * Filter which Components to update
     */
    where?: ComponentWhereInput
    /**
     * Limit how many Components to update.
     */
    limit?: number
  }

  /**
   * Component updateManyAndReturn
   */
  export type ComponentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * The data used to update Components.
     */
    data: XOR<ComponentUpdateManyMutationInput, ComponentUncheckedUpdateManyInput>
    /**
     * Filter which Components to update
     */
    where?: ComponentWhereInput
    /**
     * Limit how many Components to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Component upsert
   */
  export type ComponentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * The filter to search for the Component to update in case it exists.
     */
    where: ComponentWhereUniqueInput
    /**
     * In case the Component found by the `where` argument doesn't exist, create a new Component with this data.
     */
    create: XOR<ComponentCreateInput, ComponentUncheckedCreateInput>
    /**
     * In case the Component was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComponentUpdateInput, ComponentUncheckedUpdateInput>
  }

  /**
   * Component delete
   */
  export type ComponentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
    /**
     * Filter which Component to delete.
     */
    where: ComponentWhereUniqueInput
  }

  /**
   * Component deleteMany
   */
  export type ComponentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Components to delete
     */
    where?: ComponentWhereInput
    /**
     * Limit how many Components to delete.
     */
    limit?: number
  }

  /**
   * Component without action
   */
  export type ComponentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Component
     */
    select?: ComponentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Component
     */
    omit?: ComponentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComponentInclude<ExtArgs> | null
  }


  /**
   * Model Workflow
   */

  export type AggregateWorkflow = {
    _count: WorkflowCountAggregateOutputType | null
    _avg: WorkflowAvgAggregateOutputType | null
    _sum: WorkflowSumAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  export type WorkflowAvgAggregateOutputType = {
    id: number | null
    appId: number | null
  }

  export type WorkflowSumAggregateOutputType = {
    id: number | null
    appId: number | null
  }

  export type WorkflowMinAggregateOutputType = {
    id: number | null
    name: string | null
    appId: number | null
  }

  export type WorkflowMaxAggregateOutputType = {
    id: number | null
    name: string | null
    appId: number | null
  }

  export type WorkflowCountAggregateOutputType = {
    id: number
    name: number
    appId: number
    steps: number
    _all: number
  }


  export type WorkflowAvgAggregateInputType = {
    id?: true
    appId?: true
  }

  export type WorkflowSumAggregateInputType = {
    id?: true
    appId?: true
  }

  export type WorkflowMinAggregateInputType = {
    id?: true
    name?: true
    appId?: true
  }

  export type WorkflowMaxAggregateInputType = {
    id?: true
    name?: true
    appId?: true
  }

  export type WorkflowCountAggregateInputType = {
    id?: true
    name?: true
    appId?: true
    steps?: true
    _all?: true
  }

  export type WorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflow to aggregate.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Workflows
    **/
    _count?: true | WorkflowCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: WorkflowAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: WorkflowSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WorkflowMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WorkflowMaxAggregateInputType
  }

  export type GetWorkflowAggregateType<T extends WorkflowAggregateArgs> = {
        [P in keyof T & keyof AggregateWorkflow]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWorkflow[P]>
      : GetScalarType<T[P], AggregateWorkflow[P]>
  }




  export type WorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WorkflowWhereInput
    orderBy?: WorkflowOrderByWithAggregationInput | WorkflowOrderByWithAggregationInput[]
    by: WorkflowScalarFieldEnum[] | WorkflowScalarFieldEnum
    having?: WorkflowScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WorkflowCountAggregateInputType | true
    _avg?: WorkflowAvgAggregateInputType
    _sum?: WorkflowSumAggregateInputType
    _min?: WorkflowMinAggregateInputType
    _max?: WorkflowMaxAggregateInputType
  }

  export type WorkflowGroupByOutputType = {
    id: number
    name: string
    appId: number
    steps: JsonValue
    _count: WorkflowCountAggregateOutputType | null
    _avg: WorkflowAvgAggregateOutputType | null
    _sum: WorkflowSumAggregateOutputType | null
    _min: WorkflowMinAggregateOutputType | null
    _max: WorkflowMaxAggregateOutputType | null
  }

  type GetWorkflowGroupByPayload<T extends WorkflowGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WorkflowGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WorkflowGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
            : GetScalarType<T[P], WorkflowGroupByOutputType[P]>
        }
      >
    >


  export type WorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    appId?: boolean
    steps?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    appId?: boolean
    steps?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    appId?: boolean
    steps?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["workflow"]>

  export type WorkflowSelectScalar = {
    id?: boolean
    name?: boolean
    appId?: boolean
    steps?: boolean
  }

  export type WorkflowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "appId" | "steps", ExtArgs["result"]["workflow"]>
  export type WorkflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }
  export type WorkflowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }
  export type WorkflowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }

  export type $WorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Workflow"
    objects: {
      app: Prisma.$AppPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      appId: number
      steps: Prisma.JsonValue
    }, ExtArgs["result"]["workflow"]>
    composites: {}
  }

  type WorkflowGetPayload<S extends boolean | null | undefined | WorkflowDefaultArgs> = $Result.GetResult<Prisma.$WorkflowPayload, S>

  type WorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WorkflowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WorkflowCountAggregateInputType | true
    }

  export interface WorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workflow'], meta: { name: 'Workflow' } }
    /**
     * Find zero or one Workflow that matches the filter.
     * @param {WorkflowFindUniqueArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WorkflowFindUniqueArgs>(args: SelectSubset<T, WorkflowFindUniqueArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Workflow that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WorkflowFindUniqueOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WorkflowFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workflow that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WorkflowFindFirstArgs>(args?: SelectSubset<T, WorkflowFindFirstArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Workflow that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindFirstOrThrowArgs} args - Arguments to find a Workflow
     * @example
     * // Get one Workflow
     * const workflow = await prisma.workflow.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WorkflowFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Workflows that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Workflows
     * const workflows = await prisma.workflow.findMany()
     * 
     * // Get first 10 Workflows
     * const workflows = await prisma.workflow.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const workflowWithIdOnly = await prisma.workflow.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends WorkflowFindManyArgs>(args?: SelectSubset<T, WorkflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Workflow.
     * @param {WorkflowCreateArgs} args - Arguments to create a Workflow.
     * @example
     * // Create one Workflow
     * const Workflow = await prisma.workflow.create({
     *   data: {
     *     // ... data to create a Workflow
     *   }
     * })
     * 
     */
    create<T extends WorkflowCreateArgs>(args: SelectSubset<T, WorkflowCreateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Workflows.
     * @param {WorkflowCreateManyArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WorkflowCreateManyArgs>(args?: SelectSubset<T, WorkflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Workflows and returns the data saved in the database.
     * @param {WorkflowCreateManyAndReturnArgs} args - Arguments to create many Workflows.
     * @example
     * // Create many Workflows
     * const workflow = await prisma.workflow.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WorkflowCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Workflow.
     * @param {WorkflowDeleteArgs} args - Arguments to delete one Workflow.
     * @example
     * // Delete one Workflow
     * const Workflow = await prisma.workflow.delete({
     *   where: {
     *     // ... filter to delete one Workflow
     *   }
     * })
     * 
     */
    delete<T extends WorkflowDeleteArgs>(args: SelectSubset<T, WorkflowDeleteArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Workflow.
     * @param {WorkflowUpdateArgs} args - Arguments to update one Workflow.
     * @example
     * // Update one Workflow
     * const workflow = await prisma.workflow.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WorkflowUpdateArgs>(args: SelectSubset<T, WorkflowUpdateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Workflows.
     * @param {WorkflowDeleteManyArgs} args - Arguments to filter Workflows to delete.
     * @example
     * // Delete a few Workflows
     * const { count } = await prisma.workflow.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WorkflowDeleteManyArgs>(args?: SelectSubset<T, WorkflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WorkflowUpdateManyArgs>(args: SelectSubset<T, WorkflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Workflows and returns the data updated in the database.
     * @param {WorkflowUpdateManyAndReturnArgs} args - Arguments to update many Workflows.
     * @example
     * // Update many Workflows
     * const workflow = await prisma.workflow.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Workflows and only return the `id`
     * const workflowWithIdOnly = await prisma.workflow.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WorkflowUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkflowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Workflow.
     * @param {WorkflowUpsertArgs} args - Arguments to update or create a Workflow.
     * @example
     * // Update or create a Workflow
     * const workflow = await prisma.workflow.upsert({
     *   create: {
     *     // ... data to create a Workflow
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Workflow we want to update
     *   }
     * })
     */
    upsert<T extends WorkflowUpsertArgs>(args: SelectSubset<T, WorkflowUpsertArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Workflows.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowCountArgs} args - Arguments to filter Workflows to count.
     * @example
     * // Count the number of Workflows
     * const count = await prisma.workflow.count({
     *   where: {
     *     // ... the filter for the Workflows we want to count
     *   }
     * })
    **/
    count<T extends WorkflowCountArgs>(
      args?: Subset<T, WorkflowCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WorkflowCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WorkflowAggregateArgs>(args: Subset<T, WorkflowAggregateArgs>): Prisma.PrismaPromise<GetWorkflowAggregateType<T>>

    /**
     * Group by Workflow.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WorkflowGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WorkflowGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WorkflowGroupByArgs['orderBy'] }
        : { orderBy?: WorkflowGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Workflow model
   */
  readonly fields: WorkflowFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Workflow.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app<T extends AppDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppDefaultArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Workflow model
   */
  interface WorkflowFieldRefs {
    readonly id: FieldRef<"Workflow", 'Int'>
    readonly name: FieldRef<"Workflow", 'String'>
    readonly appId: FieldRef<"Workflow", 'Int'>
    readonly steps: FieldRef<"Workflow", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * Workflow findUnique
   */
  export type WorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow findUniqueOrThrow
   */
  export type WorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow findFirst
   */
  export type WorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow findFirstOrThrow
   */
  export type WorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflow to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Workflows.
     */
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow findMany
   */
  export type WorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter, which Workflows to fetch.
     */
    where?: WorkflowWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Workflows to fetch.
     */
    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Workflows.
     */
    cursor?: WorkflowWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Workflows from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Workflows.
     */
    skip?: number
    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]
  }

  /**
   * Workflow create
   */
  export type WorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to create a Workflow.
     */
    data: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
  }

  /**
   * Workflow createMany
   */
  export type WorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Workflow createManyAndReturn
   */
  export type WorkflowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * The data used to create many Workflows.
     */
    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workflow update
   */
  export type WorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The data needed to update a Workflow.
     */
    data: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
    /**
     * Choose, which Workflow to update.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow updateMany
   */
  export type WorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput
    /**
     * Limit how many Workflows to update.
     */
    limit?: number
  }

  /**
   * Workflow updateManyAndReturn
   */
  export type WorkflowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * The data used to update Workflows.
     */
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>
    /**
     * Filter which Workflows to update
     */
    where?: WorkflowWhereInput
    /**
     * Limit how many Workflows to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Workflow upsert
   */
  export type WorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * The filter to search for the Workflow to update in case it exists.
     */
    where: WorkflowWhereUniqueInput
    /**
     * In case the Workflow found by the `where` argument doesn't exist, create a new Workflow with this data.
     */
    create: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>
    /**
     * In case the Workflow was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>
  }

  /**
   * Workflow delete
   */
  export type WorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
    /**
     * Filter which Workflow to delete.
     */
    where: WorkflowWhereUniqueInput
  }

  /**
   * Workflow deleteMany
   */
  export type WorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Workflows to delete
     */
    where?: WorkflowWhereInput
    /**
     * Limit how many Workflows to delete.
     */
    limit?: number
  }

  /**
   * Workflow without action
   */
  export type WorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Workflow
     */
    select?: WorkflowSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Workflow
     */
    omit?: WorkflowOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WorkflowInclude<ExtArgs> | null
  }


  /**
   * Model Otp
   */

  export type AggregateOtp = {
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  export type OtpAvgAggregateOutputType = {
    id: number | null
  }

  export type OtpSumAggregateOutputType = {
    id: number | null
  }

  export type OtpMinAggregateOutputType = {
    id: number | null
    email: string | null
    otp: string | null
    type: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type OtpMaxAggregateOutputType = {
    id: number | null
    email: string | null
    otp: string | null
    type: string | null
    expiresAt: Date | null
    used: boolean | null
    createdAt: Date | null
  }

  export type OtpCountAggregateOutputType = {
    id: number
    email: number
    otp: number
    type: number
    expiresAt: number
    used: number
    createdAt: number
    _all: number
  }


  export type OtpAvgAggregateInputType = {
    id?: true
  }

  export type OtpSumAggregateInputType = {
    id?: true
  }

  export type OtpMinAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    type?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type OtpMaxAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    type?: true
    expiresAt?: true
    used?: true
    createdAt?: true
  }

  export type OtpCountAggregateInputType = {
    id?: true
    email?: true
    otp?: true
    type?: true
    expiresAt?: true
    used?: true
    createdAt?: true
    _all?: true
  }

  export type OtpAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otp to aggregate.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Otps
    **/
    _count?: true | OtpCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OtpAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OtpSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OtpMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OtpMaxAggregateInputType
  }

  export type GetOtpAggregateType<T extends OtpAggregateArgs> = {
        [P in keyof T & keyof AggregateOtp]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOtp[P]>
      : GetScalarType<T[P], AggregateOtp[P]>
  }




  export type OtpGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OtpWhereInput
    orderBy?: OtpOrderByWithAggregationInput | OtpOrderByWithAggregationInput[]
    by: OtpScalarFieldEnum[] | OtpScalarFieldEnum
    having?: OtpScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OtpCountAggregateInputType | true
    _avg?: OtpAvgAggregateInputType
    _sum?: OtpSumAggregateInputType
    _min?: OtpMinAggregateInputType
    _max?: OtpMaxAggregateInputType
  }

  export type OtpGroupByOutputType = {
    id: number
    email: string
    otp: string
    type: string
    expiresAt: Date
    used: boolean
    createdAt: Date
    _count: OtpCountAggregateOutputType | null
    _avg: OtpAvgAggregateOutputType | null
    _sum: OtpSumAggregateOutputType | null
    _min: OtpMinAggregateOutputType | null
    _max: OtpMaxAggregateOutputType | null
  }

  type GetOtpGroupByPayload<T extends OtpGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OtpGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OtpGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OtpGroupByOutputType[P]>
            : GetScalarType<T[P], OtpGroupByOutputType[P]>
        }
      >
    >


  export type OtpSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    type?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    type?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    otp?: boolean
    type?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["otp"]>

  export type OtpSelectScalar = {
    id?: boolean
    email?: boolean
    otp?: boolean
    type?: boolean
    expiresAt?: boolean
    used?: boolean
    createdAt?: boolean
  }

  export type OtpOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "otp" | "type" | "expiresAt" | "used" | "createdAt", ExtArgs["result"]["otp"]>

  export type $OtpPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Otp"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      otp: string
      type: string
      expiresAt: Date
      used: boolean
      createdAt: Date
    }, ExtArgs["result"]["otp"]>
    composites: {}
  }

  type OtpGetPayload<S extends boolean | null | undefined | OtpDefaultArgs> = $Result.GetResult<Prisma.$OtpPayload, S>

  type OtpCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OtpFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OtpCountAggregateInputType | true
    }

  export interface OtpDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Otp'], meta: { name: 'Otp' } }
    /**
     * Find zero or one Otp that matches the filter.
     * @param {OtpFindUniqueArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OtpFindUniqueArgs>(args: SelectSubset<T, OtpFindUniqueArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Otp that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OtpFindUniqueOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OtpFindUniqueOrThrowArgs>(args: SelectSubset<T, OtpFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OtpFindFirstArgs>(args?: SelectSubset<T, OtpFindFirstArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Otp that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindFirstOrThrowArgs} args - Arguments to find a Otp
     * @example
     * // Get one Otp
     * const otp = await prisma.otp.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OtpFindFirstOrThrowArgs>(args?: SelectSubset<T, OtpFindFirstOrThrowArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Otps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Otps
     * const otps = await prisma.otp.findMany()
     * 
     * // Get first 10 Otps
     * const otps = await prisma.otp.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const otpWithIdOnly = await prisma.otp.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OtpFindManyArgs>(args?: SelectSubset<T, OtpFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Otp.
     * @param {OtpCreateArgs} args - Arguments to create a Otp.
     * @example
     * // Create one Otp
     * const Otp = await prisma.otp.create({
     *   data: {
     *     // ... data to create a Otp
     *   }
     * })
     * 
     */
    create<T extends OtpCreateArgs>(args: SelectSubset<T, OtpCreateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Otps.
     * @param {OtpCreateManyArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OtpCreateManyArgs>(args?: SelectSubset<T, OtpCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Otps and returns the data saved in the database.
     * @param {OtpCreateManyAndReturnArgs} args - Arguments to create many Otps.
     * @example
     * // Create many Otps
     * const otp = await prisma.otp.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Otps and only return the `id`
     * const otpWithIdOnly = await prisma.otp.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OtpCreateManyAndReturnArgs>(args?: SelectSubset<T, OtpCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Otp.
     * @param {OtpDeleteArgs} args - Arguments to delete one Otp.
     * @example
     * // Delete one Otp
     * const Otp = await prisma.otp.delete({
     *   where: {
     *     // ... filter to delete one Otp
     *   }
     * })
     * 
     */
    delete<T extends OtpDeleteArgs>(args: SelectSubset<T, OtpDeleteArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Otp.
     * @param {OtpUpdateArgs} args - Arguments to update one Otp.
     * @example
     * // Update one Otp
     * const otp = await prisma.otp.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OtpUpdateArgs>(args: SelectSubset<T, OtpUpdateArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Otps.
     * @param {OtpDeleteManyArgs} args - Arguments to filter Otps to delete.
     * @example
     * // Delete a few Otps
     * const { count } = await prisma.otp.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OtpDeleteManyArgs>(args?: SelectSubset<T, OtpDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OtpUpdateManyArgs>(args: SelectSubset<T, OtpUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Otps and returns the data updated in the database.
     * @param {OtpUpdateManyAndReturnArgs} args - Arguments to update many Otps.
     * @example
     * // Update many Otps
     * const otp = await prisma.otp.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Otps and only return the `id`
     * const otpWithIdOnly = await prisma.otp.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OtpUpdateManyAndReturnArgs>(args: SelectSubset<T, OtpUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Otp.
     * @param {OtpUpsertArgs} args - Arguments to update or create a Otp.
     * @example
     * // Update or create a Otp
     * const otp = await prisma.otp.upsert({
     *   create: {
     *     // ... data to create a Otp
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Otp we want to update
     *   }
     * })
     */
    upsert<T extends OtpUpsertArgs>(args: SelectSubset<T, OtpUpsertArgs<ExtArgs>>): Prisma__OtpClient<$Result.GetResult<Prisma.$OtpPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Otps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpCountArgs} args - Arguments to filter Otps to count.
     * @example
     * // Count the number of Otps
     * const count = await prisma.otp.count({
     *   where: {
     *     // ... the filter for the Otps we want to count
     *   }
     * })
    **/
    count<T extends OtpCountArgs>(
      args?: Subset<T, OtpCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OtpCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OtpAggregateArgs>(args: Subset<T, OtpAggregateArgs>): Prisma.PrismaPromise<GetOtpAggregateType<T>>

    /**
     * Group by Otp.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OtpGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OtpGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OtpGroupByArgs['orderBy'] }
        : { orderBy?: OtpGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OtpGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOtpGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Otp model
   */
  readonly fields: OtpFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Otp.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OtpClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Otp model
   */
  interface OtpFieldRefs {
    readonly id: FieldRef<"Otp", 'Int'>
    readonly email: FieldRef<"Otp", 'String'>
    readonly otp: FieldRef<"Otp", 'String'>
    readonly type: FieldRef<"Otp", 'String'>
    readonly expiresAt: FieldRef<"Otp", 'DateTime'>
    readonly used: FieldRef<"Otp", 'Boolean'>
    readonly createdAt: FieldRef<"Otp", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Otp findUnique
   */
  export type OtpFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findUniqueOrThrow
   */
  export type OtpFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp findFirst
   */
  export type OtpFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findFirstOrThrow
   */
  export type OtpFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otp to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Otps.
     */
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp findMany
   */
  export type OtpFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter, which Otps to fetch.
     */
    where?: OtpWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Otps to fetch.
     */
    orderBy?: OtpOrderByWithRelationInput | OtpOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Otps.
     */
    cursor?: OtpWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Otps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Otps.
     */
    skip?: number
    distinct?: OtpScalarFieldEnum | OtpScalarFieldEnum[]
  }

  /**
   * Otp create
   */
  export type OtpCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data needed to create a Otp.
     */
    data: XOR<OtpCreateInput, OtpUncheckedCreateInput>
  }

  /**
   * Otp createMany
   */
  export type OtpCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp createManyAndReturn
   */
  export type OtpCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data used to create many Otps.
     */
    data: OtpCreateManyInput | OtpCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Otp update
   */
  export type OtpUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data needed to update a Otp.
     */
    data: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
    /**
     * Choose, which Otp to update.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp updateMany
   */
  export type OtpUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp updateManyAndReturn
   */
  export type OtpUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The data used to update Otps.
     */
    data: XOR<OtpUpdateManyMutationInput, OtpUncheckedUpdateManyInput>
    /**
     * Filter which Otps to update
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to update.
     */
    limit?: number
  }

  /**
   * Otp upsert
   */
  export type OtpUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * The filter to search for the Otp to update in case it exists.
     */
    where: OtpWhereUniqueInput
    /**
     * In case the Otp found by the `where` argument doesn't exist, create a new Otp with this data.
     */
    create: XOR<OtpCreateInput, OtpUncheckedCreateInput>
    /**
     * In case the Otp was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OtpUpdateInput, OtpUncheckedUpdateInput>
  }

  /**
   * Otp delete
   */
  export type OtpDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
    /**
     * Filter which Otp to delete.
     */
    where: OtpWhereUniqueInput
  }

  /**
   * Otp deleteMany
   */
  export type OtpDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Otps to delete
     */
    where?: OtpWhereInput
    /**
     * Limit how many Otps to delete.
     */
    limit?: number
  }

  /**
   * Otp without action
   */
  export type OtpDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Otp
     */
    select?: OtpSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Otp
     */
    omit?: OtpOmit<ExtArgs> | null
  }


  /**
   * Model AppSchema
   */

  export type AggregateAppSchema = {
    _count: AppSchemaCountAggregateOutputType | null
    _avg: AppSchemaAvgAggregateOutputType | null
    _sum: AppSchemaSumAggregateOutputType | null
    _min: AppSchemaMinAggregateOutputType | null
    _max: AppSchemaMaxAggregateOutputType | null
  }

  export type AppSchemaAvgAggregateOutputType = {
    id: number | null
    appId: number | null
  }

  export type AppSchemaSumAggregateOutputType = {
    id: number | null
    appId: number | null
  }

  export type AppSchemaMinAggregateOutputType = {
    id: number | null
    appId: number | null
    name: string | null
    createdAt: Date | null
  }

  export type AppSchemaMaxAggregateOutputType = {
    id: number | null
    appId: number | null
    name: string | null
    createdAt: Date | null
  }

  export type AppSchemaCountAggregateOutputType = {
    id: number
    appId: number
    name: number
    createdAt: number
    _all: number
  }


  export type AppSchemaAvgAggregateInputType = {
    id?: true
    appId?: true
  }

  export type AppSchemaSumAggregateInputType = {
    id?: true
    appId?: true
  }

  export type AppSchemaMinAggregateInputType = {
    id?: true
    appId?: true
    name?: true
    createdAt?: true
  }

  export type AppSchemaMaxAggregateInputType = {
    id?: true
    appId?: true
    name?: true
    createdAt?: true
  }

  export type AppSchemaCountAggregateInputType = {
    id?: true
    appId?: true
    name?: true
    createdAt?: true
    _all?: true
  }

  export type AppSchemaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppSchema to aggregate.
     */
    where?: AppSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSchemas to fetch.
     */
    orderBy?: AppSchemaOrderByWithRelationInput | AppSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSchemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppSchemas
    **/
    _count?: true | AppSchemaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppSchemaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppSchemaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppSchemaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppSchemaMaxAggregateInputType
  }

  export type GetAppSchemaAggregateType<T extends AppSchemaAggregateArgs> = {
        [P in keyof T & keyof AggregateAppSchema]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppSchema[P]>
      : GetScalarType<T[P], AggregateAppSchema[P]>
  }




  export type AppSchemaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppSchemaWhereInput
    orderBy?: AppSchemaOrderByWithAggregationInput | AppSchemaOrderByWithAggregationInput[]
    by: AppSchemaScalarFieldEnum[] | AppSchemaScalarFieldEnum
    having?: AppSchemaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppSchemaCountAggregateInputType | true
    _avg?: AppSchemaAvgAggregateInputType
    _sum?: AppSchemaSumAggregateInputType
    _min?: AppSchemaMinAggregateInputType
    _max?: AppSchemaMaxAggregateInputType
  }

  export type AppSchemaGroupByOutputType = {
    id: number
    appId: number
    name: string
    createdAt: Date
    _count: AppSchemaCountAggregateOutputType | null
    _avg: AppSchemaAvgAggregateOutputType | null
    _sum: AppSchemaSumAggregateOutputType | null
    _min: AppSchemaMinAggregateOutputType | null
    _max: AppSchemaMaxAggregateOutputType | null
  }

  type GetAppSchemaGroupByPayload<T extends AppSchemaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppSchemaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppSchemaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppSchemaGroupByOutputType[P]>
            : GetScalarType<T[P], AppSchemaGroupByOutputType[P]>
        }
      >
    >


  export type AppSchemaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    name?: boolean
    createdAt?: boolean
    data?: boolean | AppSchema$dataArgs<ExtArgs>
    relatedFields?: boolean | AppSchema$relatedFieldsArgs<ExtArgs>
    fields?: boolean | AppSchema$fieldsArgs<ExtArgs>
    app?: boolean | AppDefaultArgs<ExtArgs>
    _count?: boolean | AppSchemaCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appSchema"]>

  export type AppSchemaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    name?: boolean
    createdAt?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appSchema"]>

  export type AppSchemaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    name?: boolean
    createdAt?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appSchema"]>

  export type AppSchemaSelectScalar = {
    id?: boolean
    appId?: boolean
    name?: boolean
    createdAt?: boolean
  }

  export type AppSchemaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appId" | "name" | "createdAt", ExtArgs["result"]["appSchema"]>
  export type AppSchemaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    data?: boolean | AppSchema$dataArgs<ExtArgs>
    relatedFields?: boolean | AppSchema$relatedFieldsArgs<ExtArgs>
    fields?: boolean | AppSchema$fieldsArgs<ExtArgs>
    app?: boolean | AppDefaultArgs<ExtArgs>
    _count?: boolean | AppSchemaCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AppSchemaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }
  export type AppSchemaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }

  export type $AppSchemaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppSchema"
    objects: {
      data: Prisma.$AppDataPayload<ExtArgs>[]
      relatedFields: Prisma.$AppFieldPayload<ExtArgs>[]
      fields: Prisma.$AppFieldPayload<ExtArgs>[]
      app: Prisma.$AppPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      appId: number
      name: string
      createdAt: Date
    }, ExtArgs["result"]["appSchema"]>
    composites: {}
  }

  type AppSchemaGetPayload<S extends boolean | null | undefined | AppSchemaDefaultArgs> = $Result.GetResult<Prisma.$AppSchemaPayload, S>

  type AppSchemaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppSchemaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppSchemaCountAggregateInputType | true
    }

  export interface AppSchemaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppSchema'], meta: { name: 'AppSchema' } }
    /**
     * Find zero or one AppSchema that matches the filter.
     * @param {AppSchemaFindUniqueArgs} args - Arguments to find a AppSchema
     * @example
     * // Get one AppSchema
     * const appSchema = await prisma.appSchema.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppSchemaFindUniqueArgs>(args: SelectSubset<T, AppSchemaFindUniqueArgs<ExtArgs>>): Prisma__AppSchemaClient<$Result.GetResult<Prisma.$AppSchemaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppSchema that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppSchemaFindUniqueOrThrowArgs} args - Arguments to find a AppSchema
     * @example
     * // Get one AppSchema
     * const appSchema = await prisma.appSchema.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppSchemaFindUniqueOrThrowArgs>(args: SelectSubset<T, AppSchemaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppSchemaClient<$Result.GetResult<Prisma.$AppSchemaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppSchema that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSchemaFindFirstArgs} args - Arguments to find a AppSchema
     * @example
     * // Get one AppSchema
     * const appSchema = await prisma.appSchema.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppSchemaFindFirstArgs>(args?: SelectSubset<T, AppSchemaFindFirstArgs<ExtArgs>>): Prisma__AppSchemaClient<$Result.GetResult<Prisma.$AppSchemaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppSchema that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSchemaFindFirstOrThrowArgs} args - Arguments to find a AppSchema
     * @example
     * // Get one AppSchema
     * const appSchema = await prisma.appSchema.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppSchemaFindFirstOrThrowArgs>(args?: SelectSubset<T, AppSchemaFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppSchemaClient<$Result.GetResult<Prisma.$AppSchemaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppSchemas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSchemaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppSchemas
     * const appSchemas = await prisma.appSchema.findMany()
     * 
     * // Get first 10 AppSchemas
     * const appSchemas = await prisma.appSchema.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appSchemaWithIdOnly = await prisma.appSchema.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppSchemaFindManyArgs>(args?: SelectSubset<T, AppSchemaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppSchemaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppSchema.
     * @param {AppSchemaCreateArgs} args - Arguments to create a AppSchema.
     * @example
     * // Create one AppSchema
     * const AppSchema = await prisma.appSchema.create({
     *   data: {
     *     // ... data to create a AppSchema
     *   }
     * })
     * 
     */
    create<T extends AppSchemaCreateArgs>(args: SelectSubset<T, AppSchemaCreateArgs<ExtArgs>>): Prisma__AppSchemaClient<$Result.GetResult<Prisma.$AppSchemaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppSchemas.
     * @param {AppSchemaCreateManyArgs} args - Arguments to create many AppSchemas.
     * @example
     * // Create many AppSchemas
     * const appSchema = await prisma.appSchema.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppSchemaCreateManyArgs>(args?: SelectSubset<T, AppSchemaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppSchemas and returns the data saved in the database.
     * @param {AppSchemaCreateManyAndReturnArgs} args - Arguments to create many AppSchemas.
     * @example
     * // Create many AppSchemas
     * const appSchema = await prisma.appSchema.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppSchemas and only return the `id`
     * const appSchemaWithIdOnly = await prisma.appSchema.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppSchemaCreateManyAndReturnArgs>(args?: SelectSubset<T, AppSchemaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppSchemaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppSchema.
     * @param {AppSchemaDeleteArgs} args - Arguments to delete one AppSchema.
     * @example
     * // Delete one AppSchema
     * const AppSchema = await prisma.appSchema.delete({
     *   where: {
     *     // ... filter to delete one AppSchema
     *   }
     * })
     * 
     */
    delete<T extends AppSchemaDeleteArgs>(args: SelectSubset<T, AppSchemaDeleteArgs<ExtArgs>>): Prisma__AppSchemaClient<$Result.GetResult<Prisma.$AppSchemaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppSchema.
     * @param {AppSchemaUpdateArgs} args - Arguments to update one AppSchema.
     * @example
     * // Update one AppSchema
     * const appSchema = await prisma.appSchema.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppSchemaUpdateArgs>(args: SelectSubset<T, AppSchemaUpdateArgs<ExtArgs>>): Prisma__AppSchemaClient<$Result.GetResult<Prisma.$AppSchemaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppSchemas.
     * @param {AppSchemaDeleteManyArgs} args - Arguments to filter AppSchemas to delete.
     * @example
     * // Delete a few AppSchemas
     * const { count } = await prisma.appSchema.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppSchemaDeleteManyArgs>(args?: SelectSubset<T, AppSchemaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppSchemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSchemaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppSchemas
     * const appSchema = await prisma.appSchema.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppSchemaUpdateManyArgs>(args: SelectSubset<T, AppSchemaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppSchemas and returns the data updated in the database.
     * @param {AppSchemaUpdateManyAndReturnArgs} args - Arguments to update many AppSchemas.
     * @example
     * // Update many AppSchemas
     * const appSchema = await prisma.appSchema.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppSchemas and only return the `id`
     * const appSchemaWithIdOnly = await prisma.appSchema.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppSchemaUpdateManyAndReturnArgs>(args: SelectSubset<T, AppSchemaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppSchemaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppSchema.
     * @param {AppSchemaUpsertArgs} args - Arguments to update or create a AppSchema.
     * @example
     * // Update or create a AppSchema
     * const appSchema = await prisma.appSchema.upsert({
     *   create: {
     *     // ... data to create a AppSchema
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppSchema we want to update
     *   }
     * })
     */
    upsert<T extends AppSchemaUpsertArgs>(args: SelectSubset<T, AppSchemaUpsertArgs<ExtArgs>>): Prisma__AppSchemaClient<$Result.GetResult<Prisma.$AppSchemaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppSchemas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSchemaCountArgs} args - Arguments to filter AppSchemas to count.
     * @example
     * // Count the number of AppSchemas
     * const count = await prisma.appSchema.count({
     *   where: {
     *     // ... the filter for the AppSchemas we want to count
     *   }
     * })
    **/
    count<T extends AppSchemaCountArgs>(
      args?: Subset<T, AppSchemaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppSchemaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppSchema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSchemaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppSchemaAggregateArgs>(args: Subset<T, AppSchemaAggregateArgs>): Prisma.PrismaPromise<GetAppSchemaAggregateType<T>>

    /**
     * Group by AppSchema.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppSchemaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppSchemaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppSchemaGroupByArgs['orderBy'] }
        : { orderBy?: AppSchemaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppSchemaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppSchemaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppSchema model
   */
  readonly fields: AppSchemaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppSchema.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppSchemaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    data<T extends AppSchema$dataArgs<ExtArgs> = {}>(args?: Subset<T, AppSchema$dataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    relatedFields<T extends AppSchema$relatedFieldsArgs<ExtArgs> = {}>(args?: Subset<T, AppSchema$relatedFieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    fields<T extends AppSchema$fieldsArgs<ExtArgs> = {}>(args?: Subset<T, AppSchema$fieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    app<T extends AppDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppDefaultArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppSchema model
   */
  interface AppSchemaFieldRefs {
    readonly id: FieldRef<"AppSchema", 'Int'>
    readonly appId: FieldRef<"AppSchema", 'Int'>
    readonly name: FieldRef<"AppSchema", 'String'>
    readonly createdAt: FieldRef<"AppSchema", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppSchema findUnique
   */
  export type AppSchemaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSchema
     */
    select?: AppSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSchema
     */
    omit?: AppSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSchemaInclude<ExtArgs> | null
    /**
     * Filter, which AppSchema to fetch.
     */
    where: AppSchemaWhereUniqueInput
  }

  /**
   * AppSchema findUniqueOrThrow
   */
  export type AppSchemaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSchema
     */
    select?: AppSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSchema
     */
    omit?: AppSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSchemaInclude<ExtArgs> | null
    /**
     * Filter, which AppSchema to fetch.
     */
    where: AppSchemaWhereUniqueInput
  }

  /**
   * AppSchema findFirst
   */
  export type AppSchemaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSchema
     */
    select?: AppSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSchema
     */
    omit?: AppSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSchemaInclude<ExtArgs> | null
    /**
     * Filter, which AppSchema to fetch.
     */
    where?: AppSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSchemas to fetch.
     */
    orderBy?: AppSchemaOrderByWithRelationInput | AppSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppSchemas.
     */
    cursor?: AppSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSchemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppSchemas.
     */
    distinct?: AppSchemaScalarFieldEnum | AppSchemaScalarFieldEnum[]
  }

  /**
   * AppSchema findFirstOrThrow
   */
  export type AppSchemaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSchema
     */
    select?: AppSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSchema
     */
    omit?: AppSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSchemaInclude<ExtArgs> | null
    /**
     * Filter, which AppSchema to fetch.
     */
    where?: AppSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSchemas to fetch.
     */
    orderBy?: AppSchemaOrderByWithRelationInput | AppSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppSchemas.
     */
    cursor?: AppSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSchemas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppSchemas.
     */
    distinct?: AppSchemaScalarFieldEnum | AppSchemaScalarFieldEnum[]
  }

  /**
   * AppSchema findMany
   */
  export type AppSchemaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSchema
     */
    select?: AppSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSchema
     */
    omit?: AppSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSchemaInclude<ExtArgs> | null
    /**
     * Filter, which AppSchemas to fetch.
     */
    where?: AppSchemaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppSchemas to fetch.
     */
    orderBy?: AppSchemaOrderByWithRelationInput | AppSchemaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppSchemas.
     */
    cursor?: AppSchemaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppSchemas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppSchemas.
     */
    skip?: number
    distinct?: AppSchemaScalarFieldEnum | AppSchemaScalarFieldEnum[]
  }

  /**
   * AppSchema create
   */
  export type AppSchemaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSchema
     */
    select?: AppSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSchema
     */
    omit?: AppSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSchemaInclude<ExtArgs> | null
    /**
     * The data needed to create a AppSchema.
     */
    data: XOR<AppSchemaCreateInput, AppSchemaUncheckedCreateInput>
  }

  /**
   * AppSchema createMany
   */
  export type AppSchemaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppSchemas.
     */
    data: AppSchemaCreateManyInput | AppSchemaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppSchema createManyAndReturn
   */
  export type AppSchemaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSchema
     */
    select?: AppSchemaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppSchema
     */
    omit?: AppSchemaOmit<ExtArgs> | null
    /**
     * The data used to create many AppSchemas.
     */
    data: AppSchemaCreateManyInput | AppSchemaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSchemaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppSchema update
   */
  export type AppSchemaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSchema
     */
    select?: AppSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSchema
     */
    omit?: AppSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSchemaInclude<ExtArgs> | null
    /**
     * The data needed to update a AppSchema.
     */
    data: XOR<AppSchemaUpdateInput, AppSchemaUncheckedUpdateInput>
    /**
     * Choose, which AppSchema to update.
     */
    where: AppSchemaWhereUniqueInput
  }

  /**
   * AppSchema updateMany
   */
  export type AppSchemaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppSchemas.
     */
    data: XOR<AppSchemaUpdateManyMutationInput, AppSchemaUncheckedUpdateManyInput>
    /**
     * Filter which AppSchemas to update
     */
    where?: AppSchemaWhereInput
    /**
     * Limit how many AppSchemas to update.
     */
    limit?: number
  }

  /**
   * AppSchema updateManyAndReturn
   */
  export type AppSchemaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSchema
     */
    select?: AppSchemaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppSchema
     */
    omit?: AppSchemaOmit<ExtArgs> | null
    /**
     * The data used to update AppSchemas.
     */
    data: XOR<AppSchemaUpdateManyMutationInput, AppSchemaUncheckedUpdateManyInput>
    /**
     * Filter which AppSchemas to update
     */
    where?: AppSchemaWhereInput
    /**
     * Limit how many AppSchemas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSchemaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppSchema upsert
   */
  export type AppSchemaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSchema
     */
    select?: AppSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSchema
     */
    omit?: AppSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSchemaInclude<ExtArgs> | null
    /**
     * The filter to search for the AppSchema to update in case it exists.
     */
    where: AppSchemaWhereUniqueInput
    /**
     * In case the AppSchema found by the `where` argument doesn't exist, create a new AppSchema with this data.
     */
    create: XOR<AppSchemaCreateInput, AppSchemaUncheckedCreateInput>
    /**
     * In case the AppSchema was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppSchemaUpdateInput, AppSchemaUncheckedUpdateInput>
  }

  /**
   * AppSchema delete
   */
  export type AppSchemaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSchema
     */
    select?: AppSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSchema
     */
    omit?: AppSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSchemaInclude<ExtArgs> | null
    /**
     * Filter which AppSchema to delete.
     */
    where: AppSchemaWhereUniqueInput
  }

  /**
   * AppSchema deleteMany
   */
  export type AppSchemaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppSchemas to delete
     */
    where?: AppSchemaWhereInput
    /**
     * Limit how many AppSchemas to delete.
     */
    limit?: number
  }

  /**
   * AppSchema.data
   */
  export type AppSchema$dataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppData
     */
    select?: AppDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppData
     */
    omit?: AppDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDataInclude<ExtArgs> | null
    where?: AppDataWhereInput
    orderBy?: AppDataOrderByWithRelationInput | AppDataOrderByWithRelationInput[]
    cursor?: AppDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppDataScalarFieldEnum | AppDataScalarFieldEnum[]
  }

  /**
   * AppSchema.relatedFields
   */
  export type AppSchema$relatedFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppField
     */
    select?: AppFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppField
     */
    omit?: AppFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFieldInclude<ExtArgs> | null
    where?: AppFieldWhereInput
    orderBy?: AppFieldOrderByWithRelationInput | AppFieldOrderByWithRelationInput[]
    cursor?: AppFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppFieldScalarFieldEnum | AppFieldScalarFieldEnum[]
  }

  /**
   * AppSchema.fields
   */
  export type AppSchema$fieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppField
     */
    select?: AppFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppField
     */
    omit?: AppFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFieldInclude<ExtArgs> | null
    where?: AppFieldWhereInput
    orderBy?: AppFieldOrderByWithRelationInput | AppFieldOrderByWithRelationInput[]
    cursor?: AppFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AppFieldScalarFieldEnum | AppFieldScalarFieldEnum[]
  }

  /**
   * AppSchema without action
   */
  export type AppSchemaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSchema
     */
    select?: AppSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSchema
     */
    omit?: AppSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSchemaInclude<ExtArgs> | null
  }


  /**
   * Model AppField
   */

  export type AggregateAppField = {
    _count: AppFieldCountAggregateOutputType | null
    _avg: AppFieldAvgAggregateOutputType | null
    _sum: AppFieldSumAggregateOutputType | null
    _min: AppFieldMinAggregateOutputType | null
    _max: AppFieldMaxAggregateOutputType | null
  }

  export type AppFieldAvgAggregateOutputType = {
    id: number | null
    schemaId: number | null
    relatedSchemaId: number | null
  }

  export type AppFieldSumAggregateOutputType = {
    id: number | null
    schemaId: number | null
    relatedSchemaId: number | null
  }

  export type AppFieldMinAggregateOutputType = {
    id: number | null
    schemaId: number | null
    name: string | null
    type: $Enums.FieldType | null
    relatedSchemaId: number | null
    createdAt: Date | null
  }

  export type AppFieldMaxAggregateOutputType = {
    id: number | null
    schemaId: number | null
    name: string | null
    type: $Enums.FieldType | null
    relatedSchemaId: number | null
    createdAt: Date | null
  }

  export type AppFieldCountAggregateOutputType = {
    id: number
    schemaId: number
    name: number
    type: number
    constraints: number
    relatedSchemaId: number
    createdAt: number
    _all: number
  }


  export type AppFieldAvgAggregateInputType = {
    id?: true
    schemaId?: true
    relatedSchemaId?: true
  }

  export type AppFieldSumAggregateInputType = {
    id?: true
    schemaId?: true
    relatedSchemaId?: true
  }

  export type AppFieldMinAggregateInputType = {
    id?: true
    schemaId?: true
    name?: true
    type?: true
    relatedSchemaId?: true
    createdAt?: true
  }

  export type AppFieldMaxAggregateInputType = {
    id?: true
    schemaId?: true
    name?: true
    type?: true
    relatedSchemaId?: true
    createdAt?: true
  }

  export type AppFieldCountAggregateInputType = {
    id?: true
    schemaId?: true
    name?: true
    type?: true
    constraints?: true
    relatedSchemaId?: true
    createdAt?: true
    _all?: true
  }

  export type AppFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppField to aggregate.
     */
    where?: AppFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppFields to fetch.
     */
    orderBy?: AppFieldOrderByWithRelationInput | AppFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppFields
    **/
    _count?: true | AppFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppFieldMaxAggregateInputType
  }

  export type GetAppFieldAggregateType<T extends AppFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateAppField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppField[P]>
      : GetScalarType<T[P], AggregateAppField[P]>
  }




  export type AppFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppFieldWhereInput
    orderBy?: AppFieldOrderByWithAggregationInput | AppFieldOrderByWithAggregationInput[]
    by: AppFieldScalarFieldEnum[] | AppFieldScalarFieldEnum
    having?: AppFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppFieldCountAggregateInputType | true
    _avg?: AppFieldAvgAggregateInputType
    _sum?: AppFieldSumAggregateInputType
    _min?: AppFieldMinAggregateInputType
    _max?: AppFieldMaxAggregateInputType
  }

  export type AppFieldGroupByOutputType = {
    id: number
    schemaId: number
    name: string
    type: $Enums.FieldType
    constraints: JsonValue
    relatedSchemaId: number | null
    createdAt: Date
    _count: AppFieldCountAggregateOutputType | null
    _avg: AppFieldAvgAggregateOutputType | null
    _sum: AppFieldSumAggregateOutputType | null
    _min: AppFieldMinAggregateOutputType | null
    _max: AppFieldMaxAggregateOutputType | null
  }

  type GetAppFieldGroupByPayload<T extends AppFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppFieldGroupByOutputType[P]>
            : GetScalarType<T[P], AppFieldGroupByOutputType[P]>
        }
      >
    >


  export type AppFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaId?: boolean
    name?: boolean
    type?: boolean
    constraints?: boolean
    relatedSchemaId?: boolean
    createdAt?: boolean
    relatedSchema?: boolean | AppField$relatedSchemaArgs<ExtArgs>
    schema?: boolean | AppSchemaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appField"]>

  export type AppFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaId?: boolean
    name?: boolean
    type?: boolean
    constraints?: boolean
    relatedSchemaId?: boolean
    createdAt?: boolean
    relatedSchema?: boolean | AppField$relatedSchemaArgs<ExtArgs>
    schema?: boolean | AppSchemaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appField"]>

  export type AppFieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaId?: boolean
    name?: boolean
    type?: boolean
    constraints?: boolean
    relatedSchemaId?: boolean
    createdAt?: boolean
    relatedSchema?: boolean | AppField$relatedSchemaArgs<ExtArgs>
    schema?: boolean | AppSchemaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appField"]>

  export type AppFieldSelectScalar = {
    id?: boolean
    schemaId?: boolean
    name?: boolean
    type?: boolean
    constraints?: boolean
    relatedSchemaId?: boolean
    createdAt?: boolean
  }

  export type AppFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schemaId" | "name" | "type" | "constraints" | "relatedSchemaId" | "createdAt", ExtArgs["result"]["appField"]>
  export type AppFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relatedSchema?: boolean | AppField$relatedSchemaArgs<ExtArgs>
    schema?: boolean | AppSchemaDefaultArgs<ExtArgs>
  }
  export type AppFieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relatedSchema?: boolean | AppField$relatedSchemaArgs<ExtArgs>
    schema?: boolean | AppSchemaDefaultArgs<ExtArgs>
  }
  export type AppFieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    relatedSchema?: boolean | AppField$relatedSchemaArgs<ExtArgs>
    schema?: boolean | AppSchemaDefaultArgs<ExtArgs>
  }

  export type $AppFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppField"
    objects: {
      relatedSchema: Prisma.$AppSchemaPayload<ExtArgs> | null
      schema: Prisma.$AppSchemaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      schemaId: number
      name: string
      type: $Enums.FieldType
      constraints: Prisma.JsonValue
      relatedSchemaId: number | null
      createdAt: Date
    }, ExtArgs["result"]["appField"]>
    composites: {}
  }

  type AppFieldGetPayload<S extends boolean | null | undefined | AppFieldDefaultArgs> = $Result.GetResult<Prisma.$AppFieldPayload, S>

  type AppFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppFieldCountAggregateInputType | true
    }

  export interface AppFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppField'], meta: { name: 'AppField' } }
    /**
     * Find zero or one AppField that matches the filter.
     * @param {AppFieldFindUniqueArgs} args - Arguments to find a AppField
     * @example
     * // Get one AppField
     * const appField = await prisma.appField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppFieldFindUniqueArgs>(args: SelectSubset<T, AppFieldFindUniqueArgs<ExtArgs>>): Prisma__AppFieldClient<$Result.GetResult<Prisma.$AppFieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppFieldFindUniqueOrThrowArgs} args - Arguments to find a AppField
     * @example
     * // Get one AppField
     * const appField = await prisma.appField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, AppFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppFieldClient<$Result.GetResult<Prisma.$AppFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFieldFindFirstArgs} args - Arguments to find a AppField
     * @example
     * // Get one AppField
     * const appField = await prisma.appField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppFieldFindFirstArgs>(args?: SelectSubset<T, AppFieldFindFirstArgs<ExtArgs>>): Prisma__AppFieldClient<$Result.GetResult<Prisma.$AppFieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFieldFindFirstOrThrowArgs} args - Arguments to find a AppField
     * @example
     * // Get one AppField
     * const appField = await prisma.appField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, AppFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppFieldClient<$Result.GetResult<Prisma.$AppFieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppFields
     * const appFields = await prisma.appField.findMany()
     * 
     * // Get first 10 AppFields
     * const appFields = await prisma.appField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appFieldWithIdOnly = await prisma.appField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppFieldFindManyArgs>(args?: SelectSubset<T, AppFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppField.
     * @param {AppFieldCreateArgs} args - Arguments to create a AppField.
     * @example
     * // Create one AppField
     * const AppField = await prisma.appField.create({
     *   data: {
     *     // ... data to create a AppField
     *   }
     * })
     * 
     */
    create<T extends AppFieldCreateArgs>(args: SelectSubset<T, AppFieldCreateArgs<ExtArgs>>): Prisma__AppFieldClient<$Result.GetResult<Prisma.$AppFieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppFields.
     * @param {AppFieldCreateManyArgs} args - Arguments to create many AppFields.
     * @example
     * // Create many AppFields
     * const appField = await prisma.appField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppFieldCreateManyArgs>(args?: SelectSubset<T, AppFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppFields and returns the data saved in the database.
     * @param {AppFieldCreateManyAndReturnArgs} args - Arguments to create many AppFields.
     * @example
     * // Create many AppFields
     * const appField = await prisma.appField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppFields and only return the `id`
     * const appFieldWithIdOnly = await prisma.appField.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, AppFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppFieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppField.
     * @param {AppFieldDeleteArgs} args - Arguments to delete one AppField.
     * @example
     * // Delete one AppField
     * const AppField = await prisma.appField.delete({
     *   where: {
     *     // ... filter to delete one AppField
     *   }
     * })
     * 
     */
    delete<T extends AppFieldDeleteArgs>(args: SelectSubset<T, AppFieldDeleteArgs<ExtArgs>>): Prisma__AppFieldClient<$Result.GetResult<Prisma.$AppFieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppField.
     * @param {AppFieldUpdateArgs} args - Arguments to update one AppField.
     * @example
     * // Update one AppField
     * const appField = await prisma.appField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppFieldUpdateArgs>(args: SelectSubset<T, AppFieldUpdateArgs<ExtArgs>>): Prisma__AppFieldClient<$Result.GetResult<Prisma.$AppFieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppFields.
     * @param {AppFieldDeleteManyArgs} args - Arguments to filter AppFields to delete.
     * @example
     * // Delete a few AppFields
     * const { count } = await prisma.appField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppFieldDeleteManyArgs>(args?: SelectSubset<T, AppFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppFields
     * const appField = await prisma.appField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppFieldUpdateManyArgs>(args: SelectSubset<T, AppFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppFields and returns the data updated in the database.
     * @param {AppFieldUpdateManyAndReturnArgs} args - Arguments to update many AppFields.
     * @example
     * // Update many AppFields
     * const appField = await prisma.appField.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppFields and only return the `id`
     * const appFieldWithIdOnly = await prisma.appField.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppFieldUpdateManyAndReturnArgs>(args: SelectSubset<T, AppFieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppFieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppField.
     * @param {AppFieldUpsertArgs} args - Arguments to update or create a AppField.
     * @example
     * // Update or create a AppField
     * const appField = await prisma.appField.upsert({
     *   create: {
     *     // ... data to create a AppField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppField we want to update
     *   }
     * })
     */
    upsert<T extends AppFieldUpsertArgs>(args: SelectSubset<T, AppFieldUpsertArgs<ExtArgs>>): Prisma__AppFieldClient<$Result.GetResult<Prisma.$AppFieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFieldCountArgs} args - Arguments to filter AppFields to count.
     * @example
     * // Count the number of AppFields
     * const count = await prisma.appField.count({
     *   where: {
     *     // ... the filter for the AppFields we want to count
     *   }
     * })
    **/
    count<T extends AppFieldCountArgs>(
      args?: Subset<T, AppFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppFieldAggregateArgs>(args: Subset<T, AppFieldAggregateArgs>): Prisma.PrismaPromise<GetAppFieldAggregateType<T>>

    /**
     * Group by AppField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppFieldGroupByArgs['orderBy'] }
        : { orderBy?: AppFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppField model
   */
  readonly fields: AppFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    relatedSchema<T extends AppField$relatedSchemaArgs<ExtArgs> = {}>(args?: Subset<T, AppField$relatedSchemaArgs<ExtArgs>>): Prisma__AppSchemaClient<$Result.GetResult<Prisma.$AppSchemaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    schema<T extends AppSchemaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppSchemaDefaultArgs<ExtArgs>>): Prisma__AppSchemaClient<$Result.GetResult<Prisma.$AppSchemaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppField model
   */
  interface AppFieldFieldRefs {
    readonly id: FieldRef<"AppField", 'Int'>
    readonly schemaId: FieldRef<"AppField", 'Int'>
    readonly name: FieldRef<"AppField", 'String'>
    readonly type: FieldRef<"AppField", 'FieldType'>
    readonly constraints: FieldRef<"AppField", 'Json'>
    readonly relatedSchemaId: FieldRef<"AppField", 'Int'>
    readonly createdAt: FieldRef<"AppField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppField findUnique
   */
  export type AppFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppField
     */
    select?: AppFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppField
     */
    omit?: AppFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFieldInclude<ExtArgs> | null
    /**
     * Filter, which AppField to fetch.
     */
    where: AppFieldWhereUniqueInput
  }

  /**
   * AppField findUniqueOrThrow
   */
  export type AppFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppField
     */
    select?: AppFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppField
     */
    omit?: AppFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFieldInclude<ExtArgs> | null
    /**
     * Filter, which AppField to fetch.
     */
    where: AppFieldWhereUniqueInput
  }

  /**
   * AppField findFirst
   */
  export type AppFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppField
     */
    select?: AppFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppField
     */
    omit?: AppFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFieldInclude<ExtArgs> | null
    /**
     * Filter, which AppField to fetch.
     */
    where?: AppFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppFields to fetch.
     */
    orderBy?: AppFieldOrderByWithRelationInput | AppFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppFields.
     */
    cursor?: AppFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppFields.
     */
    distinct?: AppFieldScalarFieldEnum | AppFieldScalarFieldEnum[]
  }

  /**
   * AppField findFirstOrThrow
   */
  export type AppFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppField
     */
    select?: AppFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppField
     */
    omit?: AppFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFieldInclude<ExtArgs> | null
    /**
     * Filter, which AppField to fetch.
     */
    where?: AppFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppFields to fetch.
     */
    orderBy?: AppFieldOrderByWithRelationInput | AppFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppFields.
     */
    cursor?: AppFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppFields.
     */
    distinct?: AppFieldScalarFieldEnum | AppFieldScalarFieldEnum[]
  }

  /**
   * AppField findMany
   */
  export type AppFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppField
     */
    select?: AppFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppField
     */
    omit?: AppFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFieldInclude<ExtArgs> | null
    /**
     * Filter, which AppFields to fetch.
     */
    where?: AppFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppFields to fetch.
     */
    orderBy?: AppFieldOrderByWithRelationInput | AppFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppFields.
     */
    cursor?: AppFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppFields.
     */
    skip?: number
    distinct?: AppFieldScalarFieldEnum | AppFieldScalarFieldEnum[]
  }

  /**
   * AppField create
   */
  export type AppFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppField
     */
    select?: AppFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppField
     */
    omit?: AppFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a AppField.
     */
    data: XOR<AppFieldCreateInput, AppFieldUncheckedCreateInput>
  }

  /**
   * AppField createMany
   */
  export type AppFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppFields.
     */
    data: AppFieldCreateManyInput | AppFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppField createManyAndReturn
   */
  export type AppFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppField
     */
    select?: AppFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppField
     */
    omit?: AppFieldOmit<ExtArgs> | null
    /**
     * The data used to create many AppFields.
     */
    data: AppFieldCreateManyInput | AppFieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppField update
   */
  export type AppFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppField
     */
    select?: AppFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppField
     */
    omit?: AppFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a AppField.
     */
    data: XOR<AppFieldUpdateInput, AppFieldUncheckedUpdateInput>
    /**
     * Choose, which AppField to update.
     */
    where: AppFieldWhereUniqueInput
  }

  /**
   * AppField updateMany
   */
  export type AppFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppFields.
     */
    data: XOR<AppFieldUpdateManyMutationInput, AppFieldUncheckedUpdateManyInput>
    /**
     * Filter which AppFields to update
     */
    where?: AppFieldWhereInput
    /**
     * Limit how many AppFields to update.
     */
    limit?: number
  }

  /**
   * AppField updateManyAndReturn
   */
  export type AppFieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppField
     */
    select?: AppFieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppField
     */
    omit?: AppFieldOmit<ExtArgs> | null
    /**
     * The data used to update AppFields.
     */
    data: XOR<AppFieldUpdateManyMutationInput, AppFieldUncheckedUpdateManyInput>
    /**
     * Filter which AppFields to update
     */
    where?: AppFieldWhereInput
    /**
     * Limit how many AppFields to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFieldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppField upsert
   */
  export type AppFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppField
     */
    select?: AppFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppField
     */
    omit?: AppFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the AppField to update in case it exists.
     */
    where: AppFieldWhereUniqueInput
    /**
     * In case the AppField found by the `where` argument doesn't exist, create a new AppField with this data.
     */
    create: XOR<AppFieldCreateInput, AppFieldUncheckedCreateInput>
    /**
     * In case the AppField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppFieldUpdateInput, AppFieldUncheckedUpdateInput>
  }

  /**
   * AppField delete
   */
  export type AppFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppField
     */
    select?: AppFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppField
     */
    omit?: AppFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFieldInclude<ExtArgs> | null
    /**
     * Filter which AppField to delete.
     */
    where: AppFieldWhereUniqueInput
  }

  /**
   * AppField deleteMany
   */
  export type AppFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppFields to delete
     */
    where?: AppFieldWhereInput
    /**
     * Limit how many AppFields to delete.
     */
    limit?: number
  }

  /**
   * AppField.relatedSchema
   */
  export type AppField$relatedSchemaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppSchema
     */
    select?: AppSchemaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppSchema
     */
    omit?: AppSchemaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppSchemaInclude<ExtArgs> | null
    where?: AppSchemaWhereInput
  }

  /**
   * AppField without action
   */
  export type AppFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppField
     */
    select?: AppFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppField
     */
    omit?: AppFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppFieldInclude<ExtArgs> | null
  }


  /**
   * Model AppData
   */

  export type AggregateAppData = {
    _count: AppDataCountAggregateOutputType | null
    _avg: AppDataAvgAggregateOutputType | null
    _sum: AppDataSumAggregateOutputType | null
    _min: AppDataMinAggregateOutputType | null
    _max: AppDataMaxAggregateOutputType | null
  }

  export type AppDataAvgAggregateOutputType = {
    id: number | null
    schemaId: number | null
  }

  export type AppDataSumAggregateOutputType = {
    id: number | null
    schemaId: number | null
  }

  export type AppDataMinAggregateOutputType = {
    id: number | null
    schemaId: number | null
    createdAt: Date | null
  }

  export type AppDataMaxAggregateOutputType = {
    id: number | null
    schemaId: number | null
    createdAt: Date | null
  }

  export type AppDataCountAggregateOutputType = {
    id: number
    schemaId: number
    data: number
    createdAt: number
    _all: number
  }


  export type AppDataAvgAggregateInputType = {
    id?: true
    schemaId?: true
  }

  export type AppDataSumAggregateInputType = {
    id?: true
    schemaId?: true
  }

  export type AppDataMinAggregateInputType = {
    id?: true
    schemaId?: true
    createdAt?: true
  }

  export type AppDataMaxAggregateInputType = {
    id?: true
    schemaId?: true
    createdAt?: true
  }

  export type AppDataCountAggregateInputType = {
    id?: true
    schemaId?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type AppDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppData to aggregate.
     */
    where?: AppDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppData to fetch.
     */
    orderBy?: AppDataOrderByWithRelationInput | AppDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppData
    **/
    _count?: true | AppDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppDataMaxAggregateInputType
  }

  export type GetAppDataAggregateType<T extends AppDataAggregateArgs> = {
        [P in keyof T & keyof AggregateAppData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppData[P]>
      : GetScalarType<T[P], AggregateAppData[P]>
  }




  export type AppDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppDataWhereInput
    orderBy?: AppDataOrderByWithAggregationInput | AppDataOrderByWithAggregationInput[]
    by: AppDataScalarFieldEnum[] | AppDataScalarFieldEnum
    having?: AppDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppDataCountAggregateInputType | true
    _avg?: AppDataAvgAggregateInputType
    _sum?: AppDataSumAggregateInputType
    _min?: AppDataMinAggregateInputType
    _max?: AppDataMaxAggregateInputType
  }

  export type AppDataGroupByOutputType = {
    id: number
    schemaId: number
    data: JsonValue
    createdAt: Date
    _count: AppDataCountAggregateOutputType | null
    _avg: AppDataAvgAggregateOutputType | null
    _sum: AppDataSumAggregateOutputType | null
    _min: AppDataMinAggregateOutputType | null
    _max: AppDataMaxAggregateOutputType | null
  }

  type GetAppDataGroupByPayload<T extends AppDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppDataGroupByOutputType[P]>
            : GetScalarType<T[P], AppDataGroupByOutputType[P]>
        }
      >
    >


  export type AppDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaId?: boolean
    data?: boolean
    createdAt?: boolean
    schema?: boolean | AppSchemaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appData"]>

  export type AppDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaId?: boolean
    data?: boolean
    createdAt?: boolean
    schema?: boolean | AppSchemaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appData"]>

  export type AppDataSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    schemaId?: boolean
    data?: boolean
    createdAt?: boolean
    schema?: boolean | AppSchemaDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appData"]>

  export type AppDataSelectScalar = {
    id?: boolean
    schemaId?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type AppDataOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "schemaId" | "data" | "createdAt", ExtArgs["result"]["appData"]>
  export type AppDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schema?: boolean | AppSchemaDefaultArgs<ExtArgs>
  }
  export type AppDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schema?: boolean | AppSchemaDefaultArgs<ExtArgs>
  }
  export type AppDataIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    schema?: boolean | AppSchemaDefaultArgs<ExtArgs>
  }

  export type $AppDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppData"
    objects: {
      schema: Prisma.$AppSchemaPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      schemaId: number
      data: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["appData"]>
    composites: {}
  }

  type AppDataGetPayload<S extends boolean | null | undefined | AppDataDefaultArgs> = $Result.GetResult<Prisma.$AppDataPayload, S>

  type AppDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppDataFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppDataCountAggregateInputType | true
    }

  export interface AppDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppData'], meta: { name: 'AppData' } }
    /**
     * Find zero or one AppData that matches the filter.
     * @param {AppDataFindUniqueArgs} args - Arguments to find a AppData
     * @example
     * // Get one AppData
     * const appData = await prisma.appData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppDataFindUniqueArgs>(args: SelectSubset<T, AppDataFindUniqueArgs<ExtArgs>>): Prisma__AppDataClient<$Result.GetResult<Prisma.$AppDataPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppData that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppDataFindUniqueOrThrowArgs} args - Arguments to find a AppData
     * @example
     * // Get one AppData
     * const appData = await prisma.appData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppDataFindUniqueOrThrowArgs>(args: SelectSubset<T, AppDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppDataClient<$Result.GetResult<Prisma.$AppDataPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppDataFindFirstArgs} args - Arguments to find a AppData
     * @example
     * // Get one AppData
     * const appData = await prisma.appData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppDataFindFirstArgs>(args?: SelectSubset<T, AppDataFindFirstArgs<ExtArgs>>): Prisma__AppDataClient<$Result.GetResult<Prisma.$AppDataPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppDataFindFirstOrThrowArgs} args - Arguments to find a AppData
     * @example
     * // Get one AppData
     * const appData = await prisma.appData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppDataFindFirstOrThrowArgs>(args?: SelectSubset<T, AppDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppDataClient<$Result.GetResult<Prisma.$AppDataPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppData
     * const appData = await prisma.appData.findMany()
     * 
     * // Get first 10 AppData
     * const appData = await prisma.appData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appDataWithIdOnly = await prisma.appData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppDataFindManyArgs>(args?: SelectSubset<T, AppDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppDataPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppData.
     * @param {AppDataCreateArgs} args - Arguments to create a AppData.
     * @example
     * // Create one AppData
     * const AppData = await prisma.appData.create({
     *   data: {
     *     // ... data to create a AppData
     *   }
     * })
     * 
     */
    create<T extends AppDataCreateArgs>(args: SelectSubset<T, AppDataCreateArgs<ExtArgs>>): Prisma__AppDataClient<$Result.GetResult<Prisma.$AppDataPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppData.
     * @param {AppDataCreateManyArgs} args - Arguments to create many AppData.
     * @example
     * // Create many AppData
     * const appData = await prisma.appData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppDataCreateManyArgs>(args?: SelectSubset<T, AppDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppData and returns the data saved in the database.
     * @param {AppDataCreateManyAndReturnArgs} args - Arguments to create many AppData.
     * @example
     * // Create many AppData
     * const appData = await prisma.appData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppData and only return the `id`
     * const appDataWithIdOnly = await prisma.appData.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppDataCreateManyAndReturnArgs>(args?: SelectSubset<T, AppDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppDataPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppData.
     * @param {AppDataDeleteArgs} args - Arguments to delete one AppData.
     * @example
     * // Delete one AppData
     * const AppData = await prisma.appData.delete({
     *   where: {
     *     // ... filter to delete one AppData
     *   }
     * })
     * 
     */
    delete<T extends AppDataDeleteArgs>(args: SelectSubset<T, AppDataDeleteArgs<ExtArgs>>): Prisma__AppDataClient<$Result.GetResult<Prisma.$AppDataPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppData.
     * @param {AppDataUpdateArgs} args - Arguments to update one AppData.
     * @example
     * // Update one AppData
     * const appData = await prisma.appData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppDataUpdateArgs>(args: SelectSubset<T, AppDataUpdateArgs<ExtArgs>>): Prisma__AppDataClient<$Result.GetResult<Prisma.$AppDataPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppData.
     * @param {AppDataDeleteManyArgs} args - Arguments to filter AppData to delete.
     * @example
     * // Delete a few AppData
     * const { count } = await prisma.appData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppDataDeleteManyArgs>(args?: SelectSubset<T, AppDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppData
     * const appData = await prisma.appData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppDataUpdateManyArgs>(args: SelectSubset<T, AppDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppData and returns the data updated in the database.
     * @param {AppDataUpdateManyAndReturnArgs} args - Arguments to update many AppData.
     * @example
     * // Update many AppData
     * const appData = await prisma.appData.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppData and only return the `id`
     * const appDataWithIdOnly = await prisma.appData.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppDataUpdateManyAndReturnArgs>(args: SelectSubset<T, AppDataUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppDataPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppData.
     * @param {AppDataUpsertArgs} args - Arguments to update or create a AppData.
     * @example
     * // Update or create a AppData
     * const appData = await prisma.appData.upsert({
     *   create: {
     *     // ... data to create a AppData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppData we want to update
     *   }
     * })
     */
    upsert<T extends AppDataUpsertArgs>(args: SelectSubset<T, AppDataUpsertArgs<ExtArgs>>): Prisma__AppDataClient<$Result.GetResult<Prisma.$AppDataPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppDataCountArgs} args - Arguments to filter AppData to count.
     * @example
     * // Count the number of AppData
     * const count = await prisma.appData.count({
     *   where: {
     *     // ... the filter for the AppData we want to count
     *   }
     * })
    **/
    count<T extends AppDataCountArgs>(
      args?: Subset<T, AppDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppDataAggregateArgs>(args: Subset<T, AppDataAggregateArgs>): Prisma.PrismaPromise<GetAppDataAggregateType<T>>

    /**
     * Group by AppData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppDataGroupByArgs['orderBy'] }
        : { orderBy?: AppDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppData model
   */
  readonly fields: AppDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    schema<T extends AppSchemaDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppSchemaDefaultArgs<ExtArgs>>): Prisma__AppSchemaClient<$Result.GetResult<Prisma.$AppSchemaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppData model
   */
  interface AppDataFieldRefs {
    readonly id: FieldRef<"AppData", 'Int'>
    readonly schemaId: FieldRef<"AppData", 'Int'>
    readonly data: FieldRef<"AppData", 'Json'>
    readonly createdAt: FieldRef<"AppData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppData findUnique
   */
  export type AppDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppData
     */
    select?: AppDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppData
     */
    omit?: AppDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDataInclude<ExtArgs> | null
    /**
     * Filter, which AppData to fetch.
     */
    where: AppDataWhereUniqueInput
  }

  /**
   * AppData findUniqueOrThrow
   */
  export type AppDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppData
     */
    select?: AppDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppData
     */
    omit?: AppDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDataInclude<ExtArgs> | null
    /**
     * Filter, which AppData to fetch.
     */
    where: AppDataWhereUniqueInput
  }

  /**
   * AppData findFirst
   */
  export type AppDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppData
     */
    select?: AppDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppData
     */
    omit?: AppDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDataInclude<ExtArgs> | null
    /**
     * Filter, which AppData to fetch.
     */
    where?: AppDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppData to fetch.
     */
    orderBy?: AppDataOrderByWithRelationInput | AppDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppData.
     */
    cursor?: AppDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppData.
     */
    distinct?: AppDataScalarFieldEnum | AppDataScalarFieldEnum[]
  }

  /**
   * AppData findFirstOrThrow
   */
  export type AppDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppData
     */
    select?: AppDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppData
     */
    omit?: AppDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDataInclude<ExtArgs> | null
    /**
     * Filter, which AppData to fetch.
     */
    where?: AppDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppData to fetch.
     */
    orderBy?: AppDataOrderByWithRelationInput | AppDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppData.
     */
    cursor?: AppDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppData.
     */
    distinct?: AppDataScalarFieldEnum | AppDataScalarFieldEnum[]
  }

  /**
   * AppData findMany
   */
  export type AppDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppData
     */
    select?: AppDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppData
     */
    omit?: AppDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDataInclude<ExtArgs> | null
    /**
     * Filter, which AppData to fetch.
     */
    where?: AppDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppData to fetch.
     */
    orderBy?: AppDataOrderByWithRelationInput | AppDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppData.
     */
    cursor?: AppDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppData.
     */
    skip?: number
    distinct?: AppDataScalarFieldEnum | AppDataScalarFieldEnum[]
  }

  /**
   * AppData create
   */
  export type AppDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppData
     */
    select?: AppDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppData
     */
    omit?: AppDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDataInclude<ExtArgs> | null
    /**
     * The data needed to create a AppData.
     */
    data: XOR<AppDataCreateInput, AppDataUncheckedCreateInput>
  }

  /**
   * AppData createMany
   */
  export type AppDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppData.
     */
    data: AppDataCreateManyInput | AppDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppData createManyAndReturn
   */
  export type AppDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppData
     */
    select?: AppDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppData
     */
    omit?: AppDataOmit<ExtArgs> | null
    /**
     * The data used to create many AppData.
     */
    data: AppDataCreateManyInput | AppDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppData update
   */
  export type AppDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppData
     */
    select?: AppDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppData
     */
    omit?: AppDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDataInclude<ExtArgs> | null
    /**
     * The data needed to update a AppData.
     */
    data: XOR<AppDataUpdateInput, AppDataUncheckedUpdateInput>
    /**
     * Choose, which AppData to update.
     */
    where: AppDataWhereUniqueInput
  }

  /**
   * AppData updateMany
   */
  export type AppDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppData.
     */
    data: XOR<AppDataUpdateManyMutationInput, AppDataUncheckedUpdateManyInput>
    /**
     * Filter which AppData to update
     */
    where?: AppDataWhereInput
    /**
     * Limit how many AppData to update.
     */
    limit?: number
  }

  /**
   * AppData updateManyAndReturn
   */
  export type AppDataUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppData
     */
    select?: AppDataSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppData
     */
    omit?: AppDataOmit<ExtArgs> | null
    /**
     * The data used to update AppData.
     */
    data: XOR<AppDataUpdateManyMutationInput, AppDataUncheckedUpdateManyInput>
    /**
     * Filter which AppData to update
     */
    where?: AppDataWhereInput
    /**
     * Limit how many AppData to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDataIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppData upsert
   */
  export type AppDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppData
     */
    select?: AppDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppData
     */
    omit?: AppDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDataInclude<ExtArgs> | null
    /**
     * The filter to search for the AppData to update in case it exists.
     */
    where: AppDataWhereUniqueInput
    /**
     * In case the AppData found by the `where` argument doesn't exist, create a new AppData with this data.
     */
    create: XOR<AppDataCreateInput, AppDataUncheckedCreateInput>
    /**
     * In case the AppData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppDataUpdateInput, AppDataUncheckedUpdateInput>
  }

  /**
   * AppData delete
   */
  export type AppDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppData
     */
    select?: AppDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppData
     */
    omit?: AppDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDataInclude<ExtArgs> | null
    /**
     * Filter which AppData to delete.
     */
    where: AppDataWhereUniqueInput
  }

  /**
   * AppData deleteMany
   */
  export type AppDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppData to delete
     */
    where?: AppDataWhereInput
    /**
     * Limit how many AppData to delete.
     */
    limit?: number
  }

  /**
   * AppData without action
   */
  export type AppDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppData
     */
    select?: AppDataSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppData
     */
    omit?: AppDataOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppDataInclude<ExtArgs> | null
  }


  /**
   * Model Video
   */

  export type AggregateVideo = {
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  export type VideoAvgAggregateOutputType = {
    id: number | null
  }

  export type VideoSumAggregateOutputType = {
    id: number | null
  }

  export type VideoMinAggregateOutputType = {
    id: number | null
    title: string | null
    url: string | null
    category: string | null
    createdAt: Date | null
  }

  export type VideoMaxAggregateOutputType = {
    id: number | null
    title: string | null
    url: string | null
    category: string | null
    createdAt: Date | null
  }

  export type VideoCountAggregateOutputType = {
    id: number
    title: number
    url: number
    category: number
    createdAt: number
    _all: number
  }


  export type VideoAvgAggregateInputType = {
    id?: true
  }

  export type VideoSumAggregateInputType = {
    id?: true
  }

  export type VideoMinAggregateInputType = {
    id?: true
    title?: true
    url?: true
    category?: true
    createdAt?: true
  }

  export type VideoMaxAggregateInputType = {
    id?: true
    title?: true
    url?: true
    category?: true
    createdAt?: true
  }

  export type VideoCountAggregateInputType = {
    id?: true
    title?: true
    url?: true
    category?: true
    createdAt?: true
    _all?: true
  }

  export type VideoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Video to aggregate.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Videos
    **/
    _count?: true | VideoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VideoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VideoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VideoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VideoMaxAggregateInputType
  }

  export type GetVideoAggregateType<T extends VideoAggregateArgs> = {
        [P in keyof T & keyof AggregateVideo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVideo[P]>
      : GetScalarType<T[P], AggregateVideo[P]>
  }




  export type VideoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VideoWhereInput
    orderBy?: VideoOrderByWithAggregationInput | VideoOrderByWithAggregationInput[]
    by: VideoScalarFieldEnum[] | VideoScalarFieldEnum
    having?: VideoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VideoCountAggregateInputType | true
    _avg?: VideoAvgAggregateInputType
    _sum?: VideoSumAggregateInputType
    _min?: VideoMinAggregateInputType
    _max?: VideoMaxAggregateInputType
  }

  export type VideoGroupByOutputType = {
    id: number
    title: string
    url: string
    category: string
    createdAt: Date
    _count: VideoCountAggregateOutputType | null
    _avg: VideoAvgAggregateOutputType | null
    _sum: VideoSumAggregateOutputType | null
    _min: VideoMinAggregateOutputType | null
    _max: VideoMaxAggregateOutputType | null
  }

  type GetVideoGroupByPayload<T extends VideoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VideoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VideoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VideoGroupByOutputType[P]>
            : GetScalarType<T[P], VideoGroupByOutputType[P]>
        }
      >
    >


  export type VideoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    url?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["video"]>

  export type VideoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    url?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["video"]>

  export type VideoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    url?: boolean
    category?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["video"]>

  export type VideoSelectScalar = {
    id?: boolean
    title?: boolean
    url?: boolean
    category?: boolean
    createdAt?: boolean
  }

  export type VideoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "url" | "category" | "createdAt", ExtArgs["result"]["video"]>

  export type $VideoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Video"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      title: string
      url: string
      category: string
      createdAt: Date
    }, ExtArgs["result"]["video"]>
    composites: {}
  }

  type VideoGetPayload<S extends boolean | null | undefined | VideoDefaultArgs> = $Result.GetResult<Prisma.$VideoPayload, S>

  type VideoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VideoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VideoCountAggregateInputType | true
    }

  export interface VideoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Video'], meta: { name: 'Video' } }
    /**
     * Find zero or one Video that matches the filter.
     * @param {VideoFindUniqueArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VideoFindUniqueArgs>(args: SelectSubset<T, VideoFindUniqueArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Video that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VideoFindUniqueOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VideoFindUniqueOrThrowArgs>(args: SelectSubset<T, VideoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Video that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VideoFindFirstArgs>(args?: SelectSubset<T, VideoFindFirstArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Video that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindFirstOrThrowArgs} args - Arguments to find a Video
     * @example
     * // Get one Video
     * const video = await prisma.video.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VideoFindFirstOrThrowArgs>(args?: SelectSubset<T, VideoFindFirstOrThrowArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Videos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Videos
     * const videos = await prisma.video.findMany()
     * 
     * // Get first 10 Videos
     * const videos = await prisma.video.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const videoWithIdOnly = await prisma.video.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VideoFindManyArgs>(args?: SelectSubset<T, VideoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Video.
     * @param {VideoCreateArgs} args - Arguments to create a Video.
     * @example
     * // Create one Video
     * const Video = await prisma.video.create({
     *   data: {
     *     // ... data to create a Video
     *   }
     * })
     * 
     */
    create<T extends VideoCreateArgs>(args: SelectSubset<T, VideoCreateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Videos.
     * @param {VideoCreateManyArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VideoCreateManyArgs>(args?: SelectSubset<T, VideoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Videos and returns the data saved in the database.
     * @param {VideoCreateManyAndReturnArgs} args - Arguments to create many Videos.
     * @example
     * // Create many Videos
     * const video = await prisma.video.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Videos and only return the `id`
     * const videoWithIdOnly = await prisma.video.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VideoCreateManyAndReturnArgs>(args?: SelectSubset<T, VideoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Video.
     * @param {VideoDeleteArgs} args - Arguments to delete one Video.
     * @example
     * // Delete one Video
     * const Video = await prisma.video.delete({
     *   where: {
     *     // ... filter to delete one Video
     *   }
     * })
     * 
     */
    delete<T extends VideoDeleteArgs>(args: SelectSubset<T, VideoDeleteArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Video.
     * @param {VideoUpdateArgs} args - Arguments to update one Video.
     * @example
     * // Update one Video
     * const video = await prisma.video.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VideoUpdateArgs>(args: SelectSubset<T, VideoUpdateArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Videos.
     * @param {VideoDeleteManyArgs} args - Arguments to filter Videos to delete.
     * @example
     * // Delete a few Videos
     * const { count } = await prisma.video.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VideoDeleteManyArgs>(args?: SelectSubset<T, VideoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VideoUpdateManyArgs>(args: SelectSubset<T, VideoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Videos and returns the data updated in the database.
     * @param {VideoUpdateManyAndReturnArgs} args - Arguments to update many Videos.
     * @example
     * // Update many Videos
     * const video = await prisma.video.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Videos and only return the `id`
     * const videoWithIdOnly = await prisma.video.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VideoUpdateManyAndReturnArgs>(args: SelectSubset<T, VideoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Video.
     * @param {VideoUpsertArgs} args - Arguments to update or create a Video.
     * @example
     * // Update or create a Video
     * const video = await prisma.video.upsert({
     *   create: {
     *     // ... data to create a Video
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Video we want to update
     *   }
     * })
     */
    upsert<T extends VideoUpsertArgs>(args: SelectSubset<T, VideoUpsertArgs<ExtArgs>>): Prisma__VideoClient<$Result.GetResult<Prisma.$VideoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Videos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoCountArgs} args - Arguments to filter Videos to count.
     * @example
     * // Count the number of Videos
     * const count = await prisma.video.count({
     *   where: {
     *     // ... the filter for the Videos we want to count
     *   }
     * })
    **/
    count<T extends VideoCountArgs>(
      args?: Subset<T, VideoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VideoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VideoAggregateArgs>(args: Subset<T, VideoAggregateArgs>): Prisma.PrismaPromise<GetVideoAggregateType<T>>

    /**
     * Group by Video.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VideoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VideoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VideoGroupByArgs['orderBy'] }
        : { orderBy?: VideoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VideoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVideoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Video model
   */
  readonly fields: VideoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Video.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VideoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Video model
   */
  interface VideoFieldRefs {
    readonly id: FieldRef<"Video", 'Int'>
    readonly title: FieldRef<"Video", 'String'>
    readonly url: FieldRef<"Video", 'String'>
    readonly category: FieldRef<"Video", 'String'>
    readonly createdAt: FieldRef<"Video", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Video findUnique
   */
  export type VideoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findUniqueOrThrow
   */
  export type VideoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video findFirst
   */
  export type VideoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findFirstOrThrow
   */
  export type VideoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Filter, which Video to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Videos.
     */
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video findMany
   */
  export type VideoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Filter, which Videos to fetch.
     */
    where?: VideoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Videos to fetch.
     */
    orderBy?: VideoOrderByWithRelationInput | VideoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Videos.
     */
    cursor?: VideoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Videos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Videos.
     */
    skip?: number
    distinct?: VideoScalarFieldEnum | VideoScalarFieldEnum[]
  }

  /**
   * Video create
   */
  export type VideoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The data needed to create a Video.
     */
    data: XOR<VideoCreateInput, VideoUncheckedCreateInput>
  }

  /**
   * Video createMany
   */
  export type VideoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Video createManyAndReturn
   */
  export type VideoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The data used to create many Videos.
     */
    data: VideoCreateManyInput | VideoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Video update
   */
  export type VideoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The data needed to update a Video.
     */
    data: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
    /**
     * Choose, which Video to update.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video updateMany
   */
  export type VideoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to update.
     */
    limit?: number
  }

  /**
   * Video updateManyAndReturn
   */
  export type VideoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The data used to update Videos.
     */
    data: XOR<VideoUpdateManyMutationInput, VideoUncheckedUpdateManyInput>
    /**
     * Filter which Videos to update
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to update.
     */
    limit?: number
  }

  /**
   * Video upsert
   */
  export type VideoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * The filter to search for the Video to update in case it exists.
     */
    where: VideoWhereUniqueInput
    /**
     * In case the Video found by the `where` argument doesn't exist, create a new Video with this data.
     */
    create: XOR<VideoCreateInput, VideoUncheckedCreateInput>
    /**
     * In case the Video was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VideoUpdateInput, VideoUncheckedUpdateInput>
  }

  /**
   * Video delete
   */
  export type VideoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
    /**
     * Filter which Video to delete.
     */
    where: VideoWhereUniqueInput
  }

  /**
   * Video deleteMany
   */
  export type VideoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Videos to delete
     */
    where?: VideoWhereInput
    /**
     * Limit how many Videos to delete.
     */
    limit?: number
  }

  /**
   * Video without action
   */
  export type VideoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Video
     */
    select?: VideoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Video
     */
    omit?: VideoOmit<ExtArgs> | null
  }


  /**
   * Model AppMetric
   */

  export type AggregateAppMetric = {
    _count: AppMetricCountAggregateOutputType | null
    _avg: AppMetricAvgAggregateOutputType | null
    _sum: AppMetricSumAggregateOutputType | null
    _min: AppMetricMinAggregateOutputType | null
    _max: AppMetricMaxAggregateOutputType | null
  }

  export type AppMetricAvgAggregateOutputType = {
    id: number | null
    appId: number | null
    activeDays: number | null
    downtime: number | null
    totalUsers: number | null
    traffic: number | null
  }

  export type AppMetricSumAggregateOutputType = {
    id: number | null
    appId: number | null
    activeDays: number | null
    downtime: number | null
    totalUsers: number | null
    traffic: number | null
  }

  export type AppMetricMinAggregateOutputType = {
    id: number | null
    appId: number | null
    activeDays: number | null
    downtime: number | null
    totalUsers: number | null
    traffic: number | null
    createdAt: Date | null
  }

  export type AppMetricMaxAggregateOutputType = {
    id: number | null
    appId: number | null
    activeDays: number | null
    downtime: number | null
    totalUsers: number | null
    traffic: number | null
    createdAt: Date | null
  }

  export type AppMetricCountAggregateOutputType = {
    id: number
    appId: number
    activeDays: number
    downtime: number
    totalUsers: number
    traffic: number
    createdAt: number
    _all: number
  }


  export type AppMetricAvgAggregateInputType = {
    id?: true
    appId?: true
    activeDays?: true
    downtime?: true
    totalUsers?: true
    traffic?: true
  }

  export type AppMetricSumAggregateInputType = {
    id?: true
    appId?: true
    activeDays?: true
    downtime?: true
    totalUsers?: true
    traffic?: true
  }

  export type AppMetricMinAggregateInputType = {
    id?: true
    appId?: true
    activeDays?: true
    downtime?: true
    totalUsers?: true
    traffic?: true
    createdAt?: true
  }

  export type AppMetricMaxAggregateInputType = {
    id?: true
    appId?: true
    activeDays?: true
    downtime?: true
    totalUsers?: true
    traffic?: true
    createdAt?: true
  }

  export type AppMetricCountAggregateInputType = {
    id?: true
    appId?: true
    activeDays?: true
    downtime?: true
    totalUsers?: true
    traffic?: true
    createdAt?: true
    _all?: true
  }

  export type AppMetricAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppMetric to aggregate.
     */
    where?: AppMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppMetrics to fetch.
     */
    orderBy?: AppMetricOrderByWithRelationInput | AppMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppMetrics
    **/
    _count?: true | AppMetricCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppMetricAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppMetricSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppMetricMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppMetricMaxAggregateInputType
  }

  export type GetAppMetricAggregateType<T extends AppMetricAggregateArgs> = {
        [P in keyof T & keyof AggregateAppMetric]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppMetric[P]>
      : GetScalarType<T[P], AggregateAppMetric[P]>
  }




  export type AppMetricGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppMetricWhereInput
    orderBy?: AppMetricOrderByWithAggregationInput | AppMetricOrderByWithAggregationInput[]
    by: AppMetricScalarFieldEnum[] | AppMetricScalarFieldEnum
    having?: AppMetricScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppMetricCountAggregateInputType | true
    _avg?: AppMetricAvgAggregateInputType
    _sum?: AppMetricSumAggregateInputType
    _min?: AppMetricMinAggregateInputType
    _max?: AppMetricMaxAggregateInputType
  }

  export type AppMetricGroupByOutputType = {
    id: number
    appId: number
    activeDays: number
    downtime: number
    totalUsers: number
    traffic: number
    createdAt: Date
    _count: AppMetricCountAggregateOutputType | null
    _avg: AppMetricAvgAggregateOutputType | null
    _sum: AppMetricSumAggregateOutputType | null
    _min: AppMetricMinAggregateOutputType | null
    _max: AppMetricMaxAggregateOutputType | null
  }

  type GetAppMetricGroupByPayload<T extends AppMetricGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppMetricGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppMetricGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppMetricGroupByOutputType[P]>
            : GetScalarType<T[P], AppMetricGroupByOutputType[P]>
        }
      >
    >


  export type AppMetricSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    activeDays?: boolean
    downtime?: boolean
    totalUsers?: boolean
    traffic?: boolean
    createdAt?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appMetric"]>

  export type AppMetricSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    activeDays?: boolean
    downtime?: boolean
    totalUsers?: boolean
    traffic?: boolean
    createdAt?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appMetric"]>

  export type AppMetricSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    activeDays?: boolean
    downtime?: boolean
    totalUsers?: boolean
    traffic?: boolean
    createdAt?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appMetric"]>

  export type AppMetricSelectScalar = {
    id?: boolean
    appId?: boolean
    activeDays?: boolean
    downtime?: boolean
    totalUsers?: boolean
    traffic?: boolean
    createdAt?: boolean
  }

  export type AppMetricOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appId" | "activeDays" | "downtime" | "totalUsers" | "traffic" | "createdAt", ExtArgs["result"]["appMetric"]>
  export type AppMetricInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }
  export type AppMetricIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }
  export type AppMetricIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }

  export type $AppMetricPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppMetric"
    objects: {
      app: Prisma.$AppPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      appId: number
      activeDays: number
      downtime: number
      totalUsers: number
      traffic: number
      createdAt: Date
    }, ExtArgs["result"]["appMetric"]>
    composites: {}
  }

  type AppMetricGetPayload<S extends boolean | null | undefined | AppMetricDefaultArgs> = $Result.GetResult<Prisma.$AppMetricPayload, S>

  type AppMetricCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppMetricFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppMetricCountAggregateInputType | true
    }

  export interface AppMetricDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppMetric'], meta: { name: 'AppMetric' } }
    /**
     * Find zero or one AppMetric that matches the filter.
     * @param {AppMetricFindUniqueArgs} args - Arguments to find a AppMetric
     * @example
     * // Get one AppMetric
     * const appMetric = await prisma.appMetric.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppMetricFindUniqueArgs>(args: SelectSubset<T, AppMetricFindUniqueArgs<ExtArgs>>): Prisma__AppMetricClient<$Result.GetResult<Prisma.$AppMetricPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppMetric that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppMetricFindUniqueOrThrowArgs} args - Arguments to find a AppMetric
     * @example
     * // Get one AppMetric
     * const appMetric = await prisma.appMetric.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppMetricFindUniqueOrThrowArgs>(args: SelectSubset<T, AppMetricFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppMetricClient<$Result.GetResult<Prisma.$AppMetricPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppMetric that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppMetricFindFirstArgs} args - Arguments to find a AppMetric
     * @example
     * // Get one AppMetric
     * const appMetric = await prisma.appMetric.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppMetricFindFirstArgs>(args?: SelectSubset<T, AppMetricFindFirstArgs<ExtArgs>>): Prisma__AppMetricClient<$Result.GetResult<Prisma.$AppMetricPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppMetric that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppMetricFindFirstOrThrowArgs} args - Arguments to find a AppMetric
     * @example
     * // Get one AppMetric
     * const appMetric = await prisma.appMetric.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppMetricFindFirstOrThrowArgs>(args?: SelectSubset<T, AppMetricFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppMetricClient<$Result.GetResult<Prisma.$AppMetricPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppMetrics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppMetricFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppMetrics
     * const appMetrics = await prisma.appMetric.findMany()
     * 
     * // Get first 10 AppMetrics
     * const appMetrics = await prisma.appMetric.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appMetricWithIdOnly = await prisma.appMetric.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppMetricFindManyArgs>(args?: SelectSubset<T, AppMetricFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppMetricPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppMetric.
     * @param {AppMetricCreateArgs} args - Arguments to create a AppMetric.
     * @example
     * // Create one AppMetric
     * const AppMetric = await prisma.appMetric.create({
     *   data: {
     *     // ... data to create a AppMetric
     *   }
     * })
     * 
     */
    create<T extends AppMetricCreateArgs>(args: SelectSubset<T, AppMetricCreateArgs<ExtArgs>>): Prisma__AppMetricClient<$Result.GetResult<Prisma.$AppMetricPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppMetrics.
     * @param {AppMetricCreateManyArgs} args - Arguments to create many AppMetrics.
     * @example
     * // Create many AppMetrics
     * const appMetric = await prisma.appMetric.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppMetricCreateManyArgs>(args?: SelectSubset<T, AppMetricCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppMetrics and returns the data saved in the database.
     * @param {AppMetricCreateManyAndReturnArgs} args - Arguments to create many AppMetrics.
     * @example
     * // Create many AppMetrics
     * const appMetric = await prisma.appMetric.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppMetrics and only return the `id`
     * const appMetricWithIdOnly = await prisma.appMetric.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppMetricCreateManyAndReturnArgs>(args?: SelectSubset<T, AppMetricCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppMetricPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppMetric.
     * @param {AppMetricDeleteArgs} args - Arguments to delete one AppMetric.
     * @example
     * // Delete one AppMetric
     * const AppMetric = await prisma.appMetric.delete({
     *   where: {
     *     // ... filter to delete one AppMetric
     *   }
     * })
     * 
     */
    delete<T extends AppMetricDeleteArgs>(args: SelectSubset<T, AppMetricDeleteArgs<ExtArgs>>): Prisma__AppMetricClient<$Result.GetResult<Prisma.$AppMetricPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppMetric.
     * @param {AppMetricUpdateArgs} args - Arguments to update one AppMetric.
     * @example
     * // Update one AppMetric
     * const appMetric = await prisma.appMetric.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppMetricUpdateArgs>(args: SelectSubset<T, AppMetricUpdateArgs<ExtArgs>>): Prisma__AppMetricClient<$Result.GetResult<Prisma.$AppMetricPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppMetrics.
     * @param {AppMetricDeleteManyArgs} args - Arguments to filter AppMetrics to delete.
     * @example
     * // Delete a few AppMetrics
     * const { count } = await prisma.appMetric.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppMetricDeleteManyArgs>(args?: SelectSubset<T, AppMetricDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppMetricUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppMetrics
     * const appMetric = await prisma.appMetric.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppMetricUpdateManyArgs>(args: SelectSubset<T, AppMetricUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppMetrics and returns the data updated in the database.
     * @param {AppMetricUpdateManyAndReturnArgs} args - Arguments to update many AppMetrics.
     * @example
     * // Update many AppMetrics
     * const appMetric = await prisma.appMetric.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppMetrics and only return the `id`
     * const appMetricWithIdOnly = await prisma.appMetric.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppMetricUpdateManyAndReturnArgs>(args: SelectSubset<T, AppMetricUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppMetricPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppMetric.
     * @param {AppMetricUpsertArgs} args - Arguments to update or create a AppMetric.
     * @example
     * // Update or create a AppMetric
     * const appMetric = await prisma.appMetric.upsert({
     *   create: {
     *     // ... data to create a AppMetric
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppMetric we want to update
     *   }
     * })
     */
    upsert<T extends AppMetricUpsertArgs>(args: SelectSubset<T, AppMetricUpsertArgs<ExtArgs>>): Prisma__AppMetricClient<$Result.GetResult<Prisma.$AppMetricPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppMetrics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppMetricCountArgs} args - Arguments to filter AppMetrics to count.
     * @example
     * // Count the number of AppMetrics
     * const count = await prisma.appMetric.count({
     *   where: {
     *     // ... the filter for the AppMetrics we want to count
     *   }
     * })
    **/
    count<T extends AppMetricCountArgs>(
      args?: Subset<T, AppMetricCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppMetricCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppMetricAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppMetricAggregateArgs>(args: Subset<T, AppMetricAggregateArgs>): Prisma.PrismaPromise<GetAppMetricAggregateType<T>>

    /**
     * Group by AppMetric.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppMetricGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppMetricGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppMetricGroupByArgs['orderBy'] }
        : { orderBy?: AppMetricGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppMetricGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppMetricGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppMetric model
   */
  readonly fields: AppMetricFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppMetric.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppMetricClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app<T extends AppDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppDefaultArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppMetric model
   */
  interface AppMetricFieldRefs {
    readonly id: FieldRef<"AppMetric", 'Int'>
    readonly appId: FieldRef<"AppMetric", 'Int'>
    readonly activeDays: FieldRef<"AppMetric", 'Int'>
    readonly downtime: FieldRef<"AppMetric", 'Float'>
    readonly totalUsers: FieldRef<"AppMetric", 'Int'>
    readonly traffic: FieldRef<"AppMetric", 'Int'>
    readonly createdAt: FieldRef<"AppMetric", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppMetric findUnique
   */
  export type AppMetricFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppMetric
     */
    select?: AppMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppMetric
     */
    omit?: AppMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppMetricInclude<ExtArgs> | null
    /**
     * Filter, which AppMetric to fetch.
     */
    where: AppMetricWhereUniqueInput
  }

  /**
   * AppMetric findUniqueOrThrow
   */
  export type AppMetricFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppMetric
     */
    select?: AppMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppMetric
     */
    omit?: AppMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppMetricInclude<ExtArgs> | null
    /**
     * Filter, which AppMetric to fetch.
     */
    where: AppMetricWhereUniqueInput
  }

  /**
   * AppMetric findFirst
   */
  export type AppMetricFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppMetric
     */
    select?: AppMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppMetric
     */
    omit?: AppMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppMetricInclude<ExtArgs> | null
    /**
     * Filter, which AppMetric to fetch.
     */
    where?: AppMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppMetrics to fetch.
     */
    orderBy?: AppMetricOrderByWithRelationInput | AppMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppMetrics.
     */
    cursor?: AppMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppMetrics.
     */
    distinct?: AppMetricScalarFieldEnum | AppMetricScalarFieldEnum[]
  }

  /**
   * AppMetric findFirstOrThrow
   */
  export type AppMetricFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppMetric
     */
    select?: AppMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppMetric
     */
    omit?: AppMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppMetricInclude<ExtArgs> | null
    /**
     * Filter, which AppMetric to fetch.
     */
    where?: AppMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppMetrics to fetch.
     */
    orderBy?: AppMetricOrderByWithRelationInput | AppMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppMetrics.
     */
    cursor?: AppMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppMetrics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppMetrics.
     */
    distinct?: AppMetricScalarFieldEnum | AppMetricScalarFieldEnum[]
  }

  /**
   * AppMetric findMany
   */
  export type AppMetricFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppMetric
     */
    select?: AppMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppMetric
     */
    omit?: AppMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppMetricInclude<ExtArgs> | null
    /**
     * Filter, which AppMetrics to fetch.
     */
    where?: AppMetricWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppMetrics to fetch.
     */
    orderBy?: AppMetricOrderByWithRelationInput | AppMetricOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppMetrics.
     */
    cursor?: AppMetricWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppMetrics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppMetrics.
     */
    skip?: number
    distinct?: AppMetricScalarFieldEnum | AppMetricScalarFieldEnum[]
  }

  /**
   * AppMetric create
   */
  export type AppMetricCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppMetric
     */
    select?: AppMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppMetric
     */
    omit?: AppMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppMetricInclude<ExtArgs> | null
    /**
     * The data needed to create a AppMetric.
     */
    data: XOR<AppMetricCreateInput, AppMetricUncheckedCreateInput>
  }

  /**
   * AppMetric createMany
   */
  export type AppMetricCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppMetrics.
     */
    data: AppMetricCreateManyInput | AppMetricCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppMetric createManyAndReturn
   */
  export type AppMetricCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppMetric
     */
    select?: AppMetricSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppMetric
     */
    omit?: AppMetricOmit<ExtArgs> | null
    /**
     * The data used to create many AppMetrics.
     */
    data: AppMetricCreateManyInput | AppMetricCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppMetricIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppMetric update
   */
  export type AppMetricUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppMetric
     */
    select?: AppMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppMetric
     */
    omit?: AppMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppMetricInclude<ExtArgs> | null
    /**
     * The data needed to update a AppMetric.
     */
    data: XOR<AppMetricUpdateInput, AppMetricUncheckedUpdateInput>
    /**
     * Choose, which AppMetric to update.
     */
    where: AppMetricWhereUniqueInput
  }

  /**
   * AppMetric updateMany
   */
  export type AppMetricUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppMetrics.
     */
    data: XOR<AppMetricUpdateManyMutationInput, AppMetricUncheckedUpdateManyInput>
    /**
     * Filter which AppMetrics to update
     */
    where?: AppMetricWhereInput
    /**
     * Limit how many AppMetrics to update.
     */
    limit?: number
  }

  /**
   * AppMetric updateManyAndReturn
   */
  export type AppMetricUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppMetric
     */
    select?: AppMetricSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppMetric
     */
    omit?: AppMetricOmit<ExtArgs> | null
    /**
     * The data used to update AppMetrics.
     */
    data: XOR<AppMetricUpdateManyMutationInput, AppMetricUncheckedUpdateManyInput>
    /**
     * Filter which AppMetrics to update
     */
    where?: AppMetricWhereInput
    /**
     * Limit how many AppMetrics to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppMetricIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppMetric upsert
   */
  export type AppMetricUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppMetric
     */
    select?: AppMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppMetric
     */
    omit?: AppMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppMetricInclude<ExtArgs> | null
    /**
     * The filter to search for the AppMetric to update in case it exists.
     */
    where: AppMetricWhereUniqueInput
    /**
     * In case the AppMetric found by the `where` argument doesn't exist, create a new AppMetric with this data.
     */
    create: XOR<AppMetricCreateInput, AppMetricUncheckedCreateInput>
    /**
     * In case the AppMetric was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppMetricUpdateInput, AppMetricUncheckedUpdateInput>
  }

  /**
   * AppMetric delete
   */
  export type AppMetricDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppMetric
     */
    select?: AppMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppMetric
     */
    omit?: AppMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppMetricInclude<ExtArgs> | null
    /**
     * Filter which AppMetric to delete.
     */
    where: AppMetricWhereUniqueInput
  }

  /**
   * AppMetric deleteMany
   */
  export type AppMetricDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppMetrics to delete
     */
    where?: AppMetricWhereInput
    /**
     * Limit how many AppMetrics to delete.
     */
    limit?: number
  }

  /**
   * AppMetric without action
   */
  export type AppMetricDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppMetric
     */
    select?: AppMetricSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppMetric
     */
    omit?: AppMetricOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppMetricInclude<ExtArgs> | null
  }


  /**
   * Model AppIssue
   */

  export type AggregateAppIssue = {
    _count: AppIssueCountAggregateOutputType | null
    _avg: AppIssueAvgAggregateOutputType | null
    _sum: AppIssueSumAggregateOutputType | null
    _min: AppIssueMinAggregateOutputType | null
    _max: AppIssueMaxAggregateOutputType | null
  }

  export type AppIssueAvgAggregateOutputType = {
    id: number | null
    appId: number | null
  }

  export type AppIssueSumAggregateOutputType = {
    id: number | null
    appId: number | null
  }

  export type AppIssueMinAggregateOutputType = {
    id: number | null
    appId: number | null
    severity: $Enums.IssueSeverity | null
    description: string | null
    status: $Enums.IssueStatus | null
    createdAt: Date | null
  }

  export type AppIssueMaxAggregateOutputType = {
    id: number | null
    appId: number | null
    severity: $Enums.IssueSeverity | null
    description: string | null
    status: $Enums.IssueStatus | null
    createdAt: Date | null
  }

  export type AppIssueCountAggregateOutputType = {
    id: number
    appId: number
    severity: number
    description: number
    status: number
    createdAt: number
    _all: number
  }


  export type AppIssueAvgAggregateInputType = {
    id?: true
    appId?: true
  }

  export type AppIssueSumAggregateInputType = {
    id?: true
    appId?: true
  }

  export type AppIssueMinAggregateInputType = {
    id?: true
    appId?: true
    severity?: true
    description?: true
    status?: true
    createdAt?: true
  }

  export type AppIssueMaxAggregateInputType = {
    id?: true
    appId?: true
    severity?: true
    description?: true
    status?: true
    createdAt?: true
  }

  export type AppIssueCountAggregateInputType = {
    id?: true
    appId?: true
    severity?: true
    description?: true
    status?: true
    createdAt?: true
    _all?: true
  }

  export type AppIssueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppIssue to aggregate.
     */
    where?: AppIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppIssues to fetch.
     */
    orderBy?: AppIssueOrderByWithRelationInput | AppIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppIssues
    **/
    _count?: true | AppIssueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppIssueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppIssueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppIssueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppIssueMaxAggregateInputType
  }

  export type GetAppIssueAggregateType<T extends AppIssueAggregateArgs> = {
        [P in keyof T & keyof AggregateAppIssue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppIssue[P]>
      : GetScalarType<T[P], AggregateAppIssue[P]>
  }




  export type AppIssueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppIssueWhereInput
    orderBy?: AppIssueOrderByWithAggregationInput | AppIssueOrderByWithAggregationInput[]
    by: AppIssueScalarFieldEnum[] | AppIssueScalarFieldEnum
    having?: AppIssueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppIssueCountAggregateInputType | true
    _avg?: AppIssueAvgAggregateInputType
    _sum?: AppIssueSumAggregateInputType
    _min?: AppIssueMinAggregateInputType
    _max?: AppIssueMaxAggregateInputType
  }

  export type AppIssueGroupByOutputType = {
    id: number
    appId: number
    severity: $Enums.IssueSeverity
    description: string
    status: $Enums.IssueStatus
    createdAt: Date
    _count: AppIssueCountAggregateOutputType | null
    _avg: AppIssueAvgAggregateOutputType | null
    _sum: AppIssueSumAggregateOutputType | null
    _min: AppIssueMinAggregateOutputType | null
    _max: AppIssueMaxAggregateOutputType | null
  }

  type GetAppIssueGroupByPayload<T extends AppIssueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppIssueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppIssueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppIssueGroupByOutputType[P]>
            : GetScalarType<T[P], AppIssueGroupByOutputType[P]>
        }
      >
    >


  export type AppIssueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    severity?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appIssue"]>

  export type AppIssueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    severity?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appIssue"]>

  export type AppIssueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    severity?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appIssue"]>

  export type AppIssueSelectScalar = {
    id?: boolean
    appId?: boolean
    severity?: boolean
    description?: boolean
    status?: boolean
    createdAt?: boolean
  }

  export type AppIssueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appId" | "severity" | "description" | "status" | "createdAt", ExtArgs["result"]["appIssue"]>
  export type AppIssueInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }
  export type AppIssueIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }
  export type AppIssueIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }

  export type $AppIssuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppIssue"
    objects: {
      app: Prisma.$AppPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      appId: number
      severity: $Enums.IssueSeverity
      description: string
      status: $Enums.IssueStatus
      createdAt: Date
    }, ExtArgs["result"]["appIssue"]>
    composites: {}
  }

  type AppIssueGetPayload<S extends boolean | null | undefined | AppIssueDefaultArgs> = $Result.GetResult<Prisma.$AppIssuePayload, S>

  type AppIssueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppIssueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppIssueCountAggregateInputType | true
    }

  export interface AppIssueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppIssue'], meta: { name: 'AppIssue' } }
    /**
     * Find zero or one AppIssue that matches the filter.
     * @param {AppIssueFindUniqueArgs} args - Arguments to find a AppIssue
     * @example
     * // Get one AppIssue
     * const appIssue = await prisma.appIssue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppIssueFindUniqueArgs>(args: SelectSubset<T, AppIssueFindUniqueArgs<ExtArgs>>): Prisma__AppIssueClient<$Result.GetResult<Prisma.$AppIssuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppIssue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppIssueFindUniqueOrThrowArgs} args - Arguments to find a AppIssue
     * @example
     * // Get one AppIssue
     * const appIssue = await prisma.appIssue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppIssueFindUniqueOrThrowArgs>(args: SelectSubset<T, AppIssueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppIssueClient<$Result.GetResult<Prisma.$AppIssuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppIssue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIssueFindFirstArgs} args - Arguments to find a AppIssue
     * @example
     * // Get one AppIssue
     * const appIssue = await prisma.appIssue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppIssueFindFirstArgs>(args?: SelectSubset<T, AppIssueFindFirstArgs<ExtArgs>>): Prisma__AppIssueClient<$Result.GetResult<Prisma.$AppIssuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppIssue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIssueFindFirstOrThrowArgs} args - Arguments to find a AppIssue
     * @example
     * // Get one AppIssue
     * const appIssue = await prisma.appIssue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppIssueFindFirstOrThrowArgs>(args?: SelectSubset<T, AppIssueFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppIssueClient<$Result.GetResult<Prisma.$AppIssuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppIssues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIssueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppIssues
     * const appIssues = await prisma.appIssue.findMany()
     * 
     * // Get first 10 AppIssues
     * const appIssues = await prisma.appIssue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appIssueWithIdOnly = await prisma.appIssue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppIssueFindManyArgs>(args?: SelectSubset<T, AppIssueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppIssuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppIssue.
     * @param {AppIssueCreateArgs} args - Arguments to create a AppIssue.
     * @example
     * // Create one AppIssue
     * const AppIssue = await prisma.appIssue.create({
     *   data: {
     *     // ... data to create a AppIssue
     *   }
     * })
     * 
     */
    create<T extends AppIssueCreateArgs>(args: SelectSubset<T, AppIssueCreateArgs<ExtArgs>>): Prisma__AppIssueClient<$Result.GetResult<Prisma.$AppIssuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppIssues.
     * @param {AppIssueCreateManyArgs} args - Arguments to create many AppIssues.
     * @example
     * // Create many AppIssues
     * const appIssue = await prisma.appIssue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppIssueCreateManyArgs>(args?: SelectSubset<T, AppIssueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppIssues and returns the data saved in the database.
     * @param {AppIssueCreateManyAndReturnArgs} args - Arguments to create many AppIssues.
     * @example
     * // Create many AppIssues
     * const appIssue = await prisma.appIssue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppIssues and only return the `id`
     * const appIssueWithIdOnly = await prisma.appIssue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppIssueCreateManyAndReturnArgs>(args?: SelectSubset<T, AppIssueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppIssuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppIssue.
     * @param {AppIssueDeleteArgs} args - Arguments to delete one AppIssue.
     * @example
     * // Delete one AppIssue
     * const AppIssue = await prisma.appIssue.delete({
     *   where: {
     *     // ... filter to delete one AppIssue
     *   }
     * })
     * 
     */
    delete<T extends AppIssueDeleteArgs>(args: SelectSubset<T, AppIssueDeleteArgs<ExtArgs>>): Prisma__AppIssueClient<$Result.GetResult<Prisma.$AppIssuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppIssue.
     * @param {AppIssueUpdateArgs} args - Arguments to update one AppIssue.
     * @example
     * // Update one AppIssue
     * const appIssue = await prisma.appIssue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppIssueUpdateArgs>(args: SelectSubset<T, AppIssueUpdateArgs<ExtArgs>>): Prisma__AppIssueClient<$Result.GetResult<Prisma.$AppIssuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppIssues.
     * @param {AppIssueDeleteManyArgs} args - Arguments to filter AppIssues to delete.
     * @example
     * // Delete a few AppIssues
     * const { count } = await prisma.appIssue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppIssueDeleteManyArgs>(args?: SelectSubset<T, AppIssueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppIssues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIssueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppIssues
     * const appIssue = await prisma.appIssue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppIssueUpdateManyArgs>(args: SelectSubset<T, AppIssueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppIssues and returns the data updated in the database.
     * @param {AppIssueUpdateManyAndReturnArgs} args - Arguments to update many AppIssues.
     * @example
     * // Update many AppIssues
     * const appIssue = await prisma.appIssue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppIssues and only return the `id`
     * const appIssueWithIdOnly = await prisma.appIssue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppIssueUpdateManyAndReturnArgs>(args: SelectSubset<T, AppIssueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppIssuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppIssue.
     * @param {AppIssueUpsertArgs} args - Arguments to update or create a AppIssue.
     * @example
     * // Update or create a AppIssue
     * const appIssue = await prisma.appIssue.upsert({
     *   create: {
     *     // ... data to create a AppIssue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppIssue we want to update
     *   }
     * })
     */
    upsert<T extends AppIssueUpsertArgs>(args: SelectSubset<T, AppIssueUpsertArgs<ExtArgs>>): Prisma__AppIssueClient<$Result.GetResult<Prisma.$AppIssuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppIssues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIssueCountArgs} args - Arguments to filter AppIssues to count.
     * @example
     * // Count the number of AppIssues
     * const count = await prisma.appIssue.count({
     *   where: {
     *     // ... the filter for the AppIssues we want to count
     *   }
     * })
    **/
    count<T extends AppIssueCountArgs>(
      args?: Subset<T, AppIssueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppIssueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppIssue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIssueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppIssueAggregateArgs>(args: Subset<T, AppIssueAggregateArgs>): Prisma.PrismaPromise<GetAppIssueAggregateType<T>>

    /**
     * Group by AppIssue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppIssueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppIssueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppIssueGroupByArgs['orderBy'] }
        : { orderBy?: AppIssueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppIssueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppIssueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppIssue model
   */
  readonly fields: AppIssueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppIssue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppIssueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app<T extends AppDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppDefaultArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppIssue model
   */
  interface AppIssueFieldRefs {
    readonly id: FieldRef<"AppIssue", 'Int'>
    readonly appId: FieldRef<"AppIssue", 'Int'>
    readonly severity: FieldRef<"AppIssue", 'IssueSeverity'>
    readonly description: FieldRef<"AppIssue", 'String'>
    readonly status: FieldRef<"AppIssue", 'IssueStatus'>
    readonly createdAt: FieldRef<"AppIssue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppIssue findUnique
   */
  export type AppIssueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIssue
     */
    select?: AppIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppIssue
     */
    omit?: AppIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIssueInclude<ExtArgs> | null
    /**
     * Filter, which AppIssue to fetch.
     */
    where: AppIssueWhereUniqueInput
  }

  /**
   * AppIssue findUniqueOrThrow
   */
  export type AppIssueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIssue
     */
    select?: AppIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppIssue
     */
    omit?: AppIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIssueInclude<ExtArgs> | null
    /**
     * Filter, which AppIssue to fetch.
     */
    where: AppIssueWhereUniqueInput
  }

  /**
   * AppIssue findFirst
   */
  export type AppIssueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIssue
     */
    select?: AppIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppIssue
     */
    omit?: AppIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIssueInclude<ExtArgs> | null
    /**
     * Filter, which AppIssue to fetch.
     */
    where?: AppIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppIssues to fetch.
     */
    orderBy?: AppIssueOrderByWithRelationInput | AppIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppIssues.
     */
    cursor?: AppIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppIssues.
     */
    distinct?: AppIssueScalarFieldEnum | AppIssueScalarFieldEnum[]
  }

  /**
   * AppIssue findFirstOrThrow
   */
  export type AppIssueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIssue
     */
    select?: AppIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppIssue
     */
    omit?: AppIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIssueInclude<ExtArgs> | null
    /**
     * Filter, which AppIssue to fetch.
     */
    where?: AppIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppIssues to fetch.
     */
    orderBy?: AppIssueOrderByWithRelationInput | AppIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppIssues.
     */
    cursor?: AppIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppIssues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppIssues.
     */
    distinct?: AppIssueScalarFieldEnum | AppIssueScalarFieldEnum[]
  }

  /**
   * AppIssue findMany
   */
  export type AppIssueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIssue
     */
    select?: AppIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppIssue
     */
    omit?: AppIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIssueInclude<ExtArgs> | null
    /**
     * Filter, which AppIssues to fetch.
     */
    where?: AppIssueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppIssues to fetch.
     */
    orderBy?: AppIssueOrderByWithRelationInput | AppIssueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppIssues.
     */
    cursor?: AppIssueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppIssues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppIssues.
     */
    skip?: number
    distinct?: AppIssueScalarFieldEnum | AppIssueScalarFieldEnum[]
  }

  /**
   * AppIssue create
   */
  export type AppIssueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIssue
     */
    select?: AppIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppIssue
     */
    omit?: AppIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIssueInclude<ExtArgs> | null
    /**
     * The data needed to create a AppIssue.
     */
    data: XOR<AppIssueCreateInput, AppIssueUncheckedCreateInput>
  }

  /**
   * AppIssue createMany
   */
  export type AppIssueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppIssues.
     */
    data: AppIssueCreateManyInput | AppIssueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppIssue createManyAndReturn
   */
  export type AppIssueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIssue
     */
    select?: AppIssueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppIssue
     */
    omit?: AppIssueOmit<ExtArgs> | null
    /**
     * The data used to create many AppIssues.
     */
    data: AppIssueCreateManyInput | AppIssueCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIssueIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppIssue update
   */
  export type AppIssueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIssue
     */
    select?: AppIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppIssue
     */
    omit?: AppIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIssueInclude<ExtArgs> | null
    /**
     * The data needed to update a AppIssue.
     */
    data: XOR<AppIssueUpdateInput, AppIssueUncheckedUpdateInput>
    /**
     * Choose, which AppIssue to update.
     */
    where: AppIssueWhereUniqueInput
  }

  /**
   * AppIssue updateMany
   */
  export type AppIssueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppIssues.
     */
    data: XOR<AppIssueUpdateManyMutationInput, AppIssueUncheckedUpdateManyInput>
    /**
     * Filter which AppIssues to update
     */
    where?: AppIssueWhereInput
    /**
     * Limit how many AppIssues to update.
     */
    limit?: number
  }

  /**
   * AppIssue updateManyAndReturn
   */
  export type AppIssueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIssue
     */
    select?: AppIssueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppIssue
     */
    omit?: AppIssueOmit<ExtArgs> | null
    /**
     * The data used to update AppIssues.
     */
    data: XOR<AppIssueUpdateManyMutationInput, AppIssueUncheckedUpdateManyInput>
    /**
     * Filter which AppIssues to update
     */
    where?: AppIssueWhereInput
    /**
     * Limit how many AppIssues to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIssueIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppIssue upsert
   */
  export type AppIssueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIssue
     */
    select?: AppIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppIssue
     */
    omit?: AppIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIssueInclude<ExtArgs> | null
    /**
     * The filter to search for the AppIssue to update in case it exists.
     */
    where: AppIssueWhereUniqueInput
    /**
     * In case the AppIssue found by the `where` argument doesn't exist, create a new AppIssue with this data.
     */
    create: XOR<AppIssueCreateInput, AppIssueUncheckedCreateInput>
    /**
     * In case the AppIssue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppIssueUpdateInput, AppIssueUncheckedUpdateInput>
  }

  /**
   * AppIssue delete
   */
  export type AppIssueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIssue
     */
    select?: AppIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppIssue
     */
    omit?: AppIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIssueInclude<ExtArgs> | null
    /**
     * Filter which AppIssue to delete.
     */
    where: AppIssueWhereUniqueInput
  }

  /**
   * AppIssue deleteMany
   */
  export type AppIssueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppIssues to delete
     */
    where?: AppIssueWhereInput
    /**
     * Limit how many AppIssues to delete.
     */
    limit?: number
  }

  /**
   * AppIssue without action
   */
  export type AppIssueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppIssue
     */
    select?: AppIssueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppIssue
     */
    omit?: AppIssueOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppIssueInclude<ExtArgs> | null
  }


  /**
   * Model AppWarning
   */

  export type AggregateAppWarning = {
    _count: AppWarningCountAggregateOutputType | null
    _avg: AppWarningAvgAggregateOutputType | null
    _sum: AppWarningSumAggregateOutputType | null
    _min: AppWarningMinAggregateOutputType | null
    _max: AppWarningMaxAggregateOutputType | null
  }

  export type AppWarningAvgAggregateOutputType = {
    id: number | null
    appId: number | null
  }

  export type AppWarningSumAggregateOutputType = {
    id: number | null
    appId: number | null
  }

  export type AppWarningMinAggregateOutputType = {
    id: number | null
    appId: number | null
    message: string | null
    createdAt: Date | null
  }

  export type AppWarningMaxAggregateOutputType = {
    id: number | null
    appId: number | null
    message: string | null
    createdAt: Date | null
  }

  export type AppWarningCountAggregateOutputType = {
    id: number
    appId: number
    message: number
    createdAt: number
    _all: number
  }


  export type AppWarningAvgAggregateInputType = {
    id?: true
    appId?: true
  }

  export type AppWarningSumAggregateInputType = {
    id?: true
    appId?: true
  }

  export type AppWarningMinAggregateInputType = {
    id?: true
    appId?: true
    message?: true
    createdAt?: true
  }

  export type AppWarningMaxAggregateInputType = {
    id?: true
    appId?: true
    message?: true
    createdAt?: true
  }

  export type AppWarningCountAggregateInputType = {
    id?: true
    appId?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type AppWarningAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppWarning to aggregate.
     */
    where?: AppWarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppWarnings to fetch.
     */
    orderBy?: AppWarningOrderByWithRelationInput | AppWarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AppWarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppWarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppWarnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AppWarnings
    **/
    _count?: true | AppWarningCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AppWarningAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AppWarningSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AppWarningMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AppWarningMaxAggregateInputType
  }

  export type GetAppWarningAggregateType<T extends AppWarningAggregateArgs> = {
        [P in keyof T & keyof AggregateAppWarning]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAppWarning[P]>
      : GetScalarType<T[P], AggregateAppWarning[P]>
  }




  export type AppWarningGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AppWarningWhereInput
    orderBy?: AppWarningOrderByWithAggregationInput | AppWarningOrderByWithAggregationInput[]
    by: AppWarningScalarFieldEnum[] | AppWarningScalarFieldEnum
    having?: AppWarningScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AppWarningCountAggregateInputType | true
    _avg?: AppWarningAvgAggregateInputType
    _sum?: AppWarningSumAggregateInputType
    _min?: AppWarningMinAggregateInputType
    _max?: AppWarningMaxAggregateInputType
  }

  export type AppWarningGroupByOutputType = {
    id: number
    appId: number
    message: string
    createdAt: Date
    _count: AppWarningCountAggregateOutputType | null
    _avg: AppWarningAvgAggregateOutputType | null
    _sum: AppWarningSumAggregateOutputType | null
    _min: AppWarningMinAggregateOutputType | null
    _max: AppWarningMaxAggregateOutputType | null
  }

  type GetAppWarningGroupByPayload<T extends AppWarningGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AppWarningGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AppWarningGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AppWarningGroupByOutputType[P]>
            : GetScalarType<T[P], AppWarningGroupByOutputType[P]>
        }
      >
    >


  export type AppWarningSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    message?: boolean
    createdAt?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appWarning"]>

  export type AppWarningSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    message?: boolean
    createdAt?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appWarning"]>

  export type AppWarningSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    message?: boolean
    createdAt?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["appWarning"]>

  export type AppWarningSelectScalar = {
    id?: boolean
    appId?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type AppWarningOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appId" | "message" | "createdAt", ExtArgs["result"]["appWarning"]>
  export type AppWarningInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }
  export type AppWarningIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }
  export type AppWarningIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }

  export type $AppWarningPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AppWarning"
    objects: {
      app: Prisma.$AppPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      appId: number
      message: string
      createdAt: Date
    }, ExtArgs["result"]["appWarning"]>
    composites: {}
  }

  type AppWarningGetPayload<S extends boolean | null | undefined | AppWarningDefaultArgs> = $Result.GetResult<Prisma.$AppWarningPayload, S>

  type AppWarningCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AppWarningFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AppWarningCountAggregateInputType | true
    }

  export interface AppWarningDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AppWarning'], meta: { name: 'AppWarning' } }
    /**
     * Find zero or one AppWarning that matches the filter.
     * @param {AppWarningFindUniqueArgs} args - Arguments to find a AppWarning
     * @example
     * // Get one AppWarning
     * const appWarning = await prisma.appWarning.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AppWarningFindUniqueArgs>(args: SelectSubset<T, AppWarningFindUniqueArgs<ExtArgs>>): Prisma__AppWarningClient<$Result.GetResult<Prisma.$AppWarningPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AppWarning that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AppWarningFindUniqueOrThrowArgs} args - Arguments to find a AppWarning
     * @example
     * // Get one AppWarning
     * const appWarning = await prisma.appWarning.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AppWarningFindUniqueOrThrowArgs>(args: SelectSubset<T, AppWarningFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AppWarningClient<$Result.GetResult<Prisma.$AppWarningPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppWarning that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppWarningFindFirstArgs} args - Arguments to find a AppWarning
     * @example
     * // Get one AppWarning
     * const appWarning = await prisma.appWarning.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AppWarningFindFirstArgs>(args?: SelectSubset<T, AppWarningFindFirstArgs<ExtArgs>>): Prisma__AppWarningClient<$Result.GetResult<Prisma.$AppWarningPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AppWarning that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppWarningFindFirstOrThrowArgs} args - Arguments to find a AppWarning
     * @example
     * // Get one AppWarning
     * const appWarning = await prisma.appWarning.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AppWarningFindFirstOrThrowArgs>(args?: SelectSubset<T, AppWarningFindFirstOrThrowArgs<ExtArgs>>): Prisma__AppWarningClient<$Result.GetResult<Prisma.$AppWarningPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AppWarnings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppWarningFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AppWarnings
     * const appWarnings = await prisma.appWarning.findMany()
     * 
     * // Get first 10 AppWarnings
     * const appWarnings = await prisma.appWarning.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const appWarningWithIdOnly = await prisma.appWarning.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AppWarningFindManyArgs>(args?: SelectSubset<T, AppWarningFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppWarningPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AppWarning.
     * @param {AppWarningCreateArgs} args - Arguments to create a AppWarning.
     * @example
     * // Create one AppWarning
     * const AppWarning = await prisma.appWarning.create({
     *   data: {
     *     // ... data to create a AppWarning
     *   }
     * })
     * 
     */
    create<T extends AppWarningCreateArgs>(args: SelectSubset<T, AppWarningCreateArgs<ExtArgs>>): Prisma__AppWarningClient<$Result.GetResult<Prisma.$AppWarningPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AppWarnings.
     * @param {AppWarningCreateManyArgs} args - Arguments to create many AppWarnings.
     * @example
     * // Create many AppWarnings
     * const appWarning = await prisma.appWarning.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AppWarningCreateManyArgs>(args?: SelectSubset<T, AppWarningCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AppWarnings and returns the data saved in the database.
     * @param {AppWarningCreateManyAndReturnArgs} args - Arguments to create many AppWarnings.
     * @example
     * // Create many AppWarnings
     * const appWarning = await prisma.appWarning.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AppWarnings and only return the `id`
     * const appWarningWithIdOnly = await prisma.appWarning.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AppWarningCreateManyAndReturnArgs>(args?: SelectSubset<T, AppWarningCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppWarningPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AppWarning.
     * @param {AppWarningDeleteArgs} args - Arguments to delete one AppWarning.
     * @example
     * // Delete one AppWarning
     * const AppWarning = await prisma.appWarning.delete({
     *   where: {
     *     // ... filter to delete one AppWarning
     *   }
     * })
     * 
     */
    delete<T extends AppWarningDeleteArgs>(args: SelectSubset<T, AppWarningDeleteArgs<ExtArgs>>): Prisma__AppWarningClient<$Result.GetResult<Prisma.$AppWarningPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AppWarning.
     * @param {AppWarningUpdateArgs} args - Arguments to update one AppWarning.
     * @example
     * // Update one AppWarning
     * const appWarning = await prisma.appWarning.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AppWarningUpdateArgs>(args: SelectSubset<T, AppWarningUpdateArgs<ExtArgs>>): Prisma__AppWarningClient<$Result.GetResult<Prisma.$AppWarningPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AppWarnings.
     * @param {AppWarningDeleteManyArgs} args - Arguments to filter AppWarnings to delete.
     * @example
     * // Delete a few AppWarnings
     * const { count } = await prisma.appWarning.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AppWarningDeleteManyArgs>(args?: SelectSubset<T, AppWarningDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppWarnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppWarningUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AppWarnings
     * const appWarning = await prisma.appWarning.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AppWarningUpdateManyArgs>(args: SelectSubset<T, AppWarningUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AppWarnings and returns the data updated in the database.
     * @param {AppWarningUpdateManyAndReturnArgs} args - Arguments to update many AppWarnings.
     * @example
     * // Update many AppWarnings
     * const appWarning = await prisma.appWarning.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AppWarnings and only return the `id`
     * const appWarningWithIdOnly = await prisma.appWarning.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AppWarningUpdateManyAndReturnArgs>(args: SelectSubset<T, AppWarningUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AppWarningPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AppWarning.
     * @param {AppWarningUpsertArgs} args - Arguments to update or create a AppWarning.
     * @example
     * // Update or create a AppWarning
     * const appWarning = await prisma.appWarning.upsert({
     *   create: {
     *     // ... data to create a AppWarning
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AppWarning we want to update
     *   }
     * })
     */
    upsert<T extends AppWarningUpsertArgs>(args: SelectSubset<T, AppWarningUpsertArgs<ExtArgs>>): Prisma__AppWarningClient<$Result.GetResult<Prisma.$AppWarningPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AppWarnings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppWarningCountArgs} args - Arguments to filter AppWarnings to count.
     * @example
     * // Count the number of AppWarnings
     * const count = await prisma.appWarning.count({
     *   where: {
     *     // ... the filter for the AppWarnings we want to count
     *   }
     * })
    **/
    count<T extends AppWarningCountArgs>(
      args?: Subset<T, AppWarningCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AppWarningCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AppWarning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppWarningAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AppWarningAggregateArgs>(args: Subset<T, AppWarningAggregateArgs>): Prisma.PrismaPromise<GetAppWarningAggregateType<T>>

    /**
     * Group by AppWarning.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AppWarningGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AppWarningGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AppWarningGroupByArgs['orderBy'] }
        : { orderBy?: AppWarningGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AppWarningGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAppWarningGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AppWarning model
   */
  readonly fields: AppWarningFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AppWarning.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AppWarningClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app<T extends AppDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppDefaultArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AppWarning model
   */
  interface AppWarningFieldRefs {
    readonly id: FieldRef<"AppWarning", 'Int'>
    readonly appId: FieldRef<"AppWarning", 'Int'>
    readonly message: FieldRef<"AppWarning", 'String'>
    readonly createdAt: FieldRef<"AppWarning", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AppWarning findUnique
   */
  export type AppWarningFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppWarning
     */
    select?: AppWarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppWarning
     */
    omit?: AppWarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppWarningInclude<ExtArgs> | null
    /**
     * Filter, which AppWarning to fetch.
     */
    where: AppWarningWhereUniqueInput
  }

  /**
   * AppWarning findUniqueOrThrow
   */
  export type AppWarningFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppWarning
     */
    select?: AppWarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppWarning
     */
    omit?: AppWarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppWarningInclude<ExtArgs> | null
    /**
     * Filter, which AppWarning to fetch.
     */
    where: AppWarningWhereUniqueInput
  }

  /**
   * AppWarning findFirst
   */
  export type AppWarningFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppWarning
     */
    select?: AppWarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppWarning
     */
    omit?: AppWarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppWarningInclude<ExtArgs> | null
    /**
     * Filter, which AppWarning to fetch.
     */
    where?: AppWarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppWarnings to fetch.
     */
    orderBy?: AppWarningOrderByWithRelationInput | AppWarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppWarnings.
     */
    cursor?: AppWarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppWarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppWarnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppWarnings.
     */
    distinct?: AppWarningScalarFieldEnum | AppWarningScalarFieldEnum[]
  }

  /**
   * AppWarning findFirstOrThrow
   */
  export type AppWarningFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppWarning
     */
    select?: AppWarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppWarning
     */
    omit?: AppWarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppWarningInclude<ExtArgs> | null
    /**
     * Filter, which AppWarning to fetch.
     */
    where?: AppWarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppWarnings to fetch.
     */
    orderBy?: AppWarningOrderByWithRelationInput | AppWarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AppWarnings.
     */
    cursor?: AppWarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppWarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppWarnings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AppWarnings.
     */
    distinct?: AppWarningScalarFieldEnum | AppWarningScalarFieldEnum[]
  }

  /**
   * AppWarning findMany
   */
  export type AppWarningFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppWarning
     */
    select?: AppWarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppWarning
     */
    omit?: AppWarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppWarningInclude<ExtArgs> | null
    /**
     * Filter, which AppWarnings to fetch.
     */
    where?: AppWarningWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AppWarnings to fetch.
     */
    orderBy?: AppWarningOrderByWithRelationInput | AppWarningOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AppWarnings.
     */
    cursor?: AppWarningWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AppWarnings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AppWarnings.
     */
    skip?: number
    distinct?: AppWarningScalarFieldEnum | AppWarningScalarFieldEnum[]
  }

  /**
   * AppWarning create
   */
  export type AppWarningCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppWarning
     */
    select?: AppWarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppWarning
     */
    omit?: AppWarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppWarningInclude<ExtArgs> | null
    /**
     * The data needed to create a AppWarning.
     */
    data: XOR<AppWarningCreateInput, AppWarningUncheckedCreateInput>
  }

  /**
   * AppWarning createMany
   */
  export type AppWarningCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AppWarnings.
     */
    data: AppWarningCreateManyInput | AppWarningCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AppWarning createManyAndReturn
   */
  export type AppWarningCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppWarning
     */
    select?: AppWarningSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppWarning
     */
    omit?: AppWarningOmit<ExtArgs> | null
    /**
     * The data used to create many AppWarnings.
     */
    data: AppWarningCreateManyInput | AppWarningCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppWarningIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppWarning update
   */
  export type AppWarningUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppWarning
     */
    select?: AppWarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppWarning
     */
    omit?: AppWarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppWarningInclude<ExtArgs> | null
    /**
     * The data needed to update a AppWarning.
     */
    data: XOR<AppWarningUpdateInput, AppWarningUncheckedUpdateInput>
    /**
     * Choose, which AppWarning to update.
     */
    where: AppWarningWhereUniqueInput
  }

  /**
   * AppWarning updateMany
   */
  export type AppWarningUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AppWarnings.
     */
    data: XOR<AppWarningUpdateManyMutationInput, AppWarningUncheckedUpdateManyInput>
    /**
     * Filter which AppWarnings to update
     */
    where?: AppWarningWhereInput
    /**
     * Limit how many AppWarnings to update.
     */
    limit?: number
  }

  /**
   * AppWarning updateManyAndReturn
   */
  export type AppWarningUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppWarning
     */
    select?: AppWarningSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AppWarning
     */
    omit?: AppWarningOmit<ExtArgs> | null
    /**
     * The data used to update AppWarnings.
     */
    data: XOR<AppWarningUpdateManyMutationInput, AppWarningUncheckedUpdateManyInput>
    /**
     * Filter which AppWarnings to update
     */
    where?: AppWarningWhereInput
    /**
     * Limit how many AppWarnings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppWarningIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AppWarning upsert
   */
  export type AppWarningUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppWarning
     */
    select?: AppWarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppWarning
     */
    omit?: AppWarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppWarningInclude<ExtArgs> | null
    /**
     * The filter to search for the AppWarning to update in case it exists.
     */
    where: AppWarningWhereUniqueInput
    /**
     * In case the AppWarning found by the `where` argument doesn't exist, create a new AppWarning with this data.
     */
    create: XOR<AppWarningCreateInput, AppWarningUncheckedCreateInput>
    /**
     * In case the AppWarning was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AppWarningUpdateInput, AppWarningUncheckedUpdateInput>
  }

  /**
   * AppWarning delete
   */
  export type AppWarningDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppWarning
     */
    select?: AppWarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppWarning
     */
    omit?: AppWarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppWarningInclude<ExtArgs> | null
    /**
     * Filter which AppWarning to delete.
     */
    where: AppWarningWhereUniqueInput
  }

  /**
   * AppWarning deleteMany
   */
  export type AppWarningDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AppWarnings to delete
     */
    where?: AppWarningWhereInput
    /**
     * Limit how many AppWarnings to delete.
     */
    limit?: number
  }

  /**
   * AppWarning without action
   */
  export type AppWarningDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AppWarning
     */
    select?: AppWarningSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AppWarning
     */
    omit?: AppWarningOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppWarningInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationSumAggregateOutputType = {
    id: number | null
    userId: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: number | null
    userId: number | null
    type: string | null
    message: string | null
    read: boolean | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    message: number
    read: number
    createdAt: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationSumAggregateInputType = {
    id?: true
    userId?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    read?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    message?: true
    read?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: number
    userId: number
    type: string
    message: string
    read: boolean
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    message?: boolean
    read?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "message" | "read" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      userId: number
      type: string
      message: string
      read: boolean
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'Int'>
    readonly userId: FieldRef<"Notification", 'Int'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model BlacklistedToken
   */

  export type AggregateBlacklistedToken = {
    _count: BlacklistedTokenCountAggregateOutputType | null
    _avg: BlacklistedTokenAvgAggregateOutputType | null
    _sum: BlacklistedTokenSumAggregateOutputType | null
    _min: BlacklistedTokenMinAggregateOutputType | null
    _max: BlacklistedTokenMaxAggregateOutputType | null
  }

  export type BlacklistedTokenAvgAggregateOutputType = {
    id: number | null
  }

  export type BlacklistedTokenSumAggregateOutputType = {
    id: number | null
  }

  export type BlacklistedTokenMinAggregateOutputType = {
    id: number | null
    token: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type BlacklistedTokenMaxAggregateOutputType = {
    id: number | null
    token: string | null
    createdAt: Date | null
    expiresAt: Date | null
  }

  export type BlacklistedTokenCountAggregateOutputType = {
    id: number
    token: number
    createdAt: number
    expiresAt: number
    _all: number
  }


  export type BlacklistedTokenAvgAggregateInputType = {
    id?: true
  }

  export type BlacklistedTokenSumAggregateInputType = {
    id?: true
  }

  export type BlacklistedTokenMinAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    expiresAt?: true
  }

  export type BlacklistedTokenMaxAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    expiresAt?: true
  }

  export type BlacklistedTokenCountAggregateInputType = {
    id?: true
    token?: true
    createdAt?: true
    expiresAt?: true
    _all?: true
  }

  export type BlacklistedTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlacklistedToken to aggregate.
     */
    where?: BlacklistedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistedTokens to fetch.
     */
    orderBy?: BlacklistedTokenOrderByWithRelationInput | BlacklistedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BlacklistedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BlacklistedTokens
    **/
    _count?: true | BlacklistedTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BlacklistedTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BlacklistedTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BlacklistedTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BlacklistedTokenMaxAggregateInputType
  }

  export type GetBlacklistedTokenAggregateType<T extends BlacklistedTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateBlacklistedToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBlacklistedToken[P]>
      : GetScalarType<T[P], AggregateBlacklistedToken[P]>
  }




  export type BlacklistedTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BlacklistedTokenWhereInput
    orderBy?: BlacklistedTokenOrderByWithAggregationInput | BlacklistedTokenOrderByWithAggregationInput[]
    by: BlacklistedTokenScalarFieldEnum[] | BlacklistedTokenScalarFieldEnum
    having?: BlacklistedTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BlacklistedTokenCountAggregateInputType | true
    _avg?: BlacklistedTokenAvgAggregateInputType
    _sum?: BlacklistedTokenSumAggregateInputType
    _min?: BlacklistedTokenMinAggregateInputType
    _max?: BlacklistedTokenMaxAggregateInputType
  }

  export type BlacklistedTokenGroupByOutputType = {
    id: number
    token: string
    createdAt: Date
    expiresAt: Date
    _count: BlacklistedTokenCountAggregateOutputType | null
    _avg: BlacklistedTokenAvgAggregateOutputType | null
    _sum: BlacklistedTokenSumAggregateOutputType | null
    _min: BlacklistedTokenMinAggregateOutputType | null
    _max: BlacklistedTokenMaxAggregateOutputType | null
  }

  type GetBlacklistedTokenGroupByPayload<T extends BlacklistedTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BlacklistedTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BlacklistedTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BlacklistedTokenGroupByOutputType[P]>
            : GetScalarType<T[P], BlacklistedTokenGroupByOutputType[P]>
        }
      >
    >


  export type BlacklistedTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["blacklistedToken"]>

  export type BlacklistedTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["blacklistedToken"]>

  export type BlacklistedTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }, ExtArgs["result"]["blacklistedToken"]>

  export type BlacklistedTokenSelectScalar = {
    id?: boolean
    token?: boolean
    createdAt?: boolean
    expiresAt?: boolean
  }

  export type BlacklistedTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "createdAt" | "expiresAt", ExtArgs["result"]["blacklistedToken"]>

  export type $BlacklistedTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BlacklistedToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      token: string
      createdAt: Date
      expiresAt: Date
    }, ExtArgs["result"]["blacklistedToken"]>
    composites: {}
  }

  type BlacklistedTokenGetPayload<S extends boolean | null | undefined | BlacklistedTokenDefaultArgs> = $Result.GetResult<Prisma.$BlacklistedTokenPayload, S>

  type BlacklistedTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BlacklistedTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BlacklistedTokenCountAggregateInputType | true
    }

  export interface BlacklistedTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BlacklistedToken'], meta: { name: 'BlacklistedToken' } }
    /**
     * Find zero or one BlacklistedToken that matches the filter.
     * @param {BlacklistedTokenFindUniqueArgs} args - Arguments to find a BlacklistedToken
     * @example
     * // Get one BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BlacklistedTokenFindUniqueArgs>(args: SelectSubset<T, BlacklistedTokenFindUniqueArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BlacklistedToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BlacklistedTokenFindUniqueOrThrowArgs} args - Arguments to find a BlacklistedToken
     * @example
     * // Get one BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BlacklistedTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, BlacklistedTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlacklistedToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenFindFirstArgs} args - Arguments to find a BlacklistedToken
     * @example
     * // Get one BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BlacklistedTokenFindFirstArgs>(args?: SelectSubset<T, BlacklistedTokenFindFirstArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BlacklistedToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenFindFirstOrThrowArgs} args - Arguments to find a BlacklistedToken
     * @example
     * // Get one BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BlacklistedTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, BlacklistedTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BlacklistedTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BlacklistedTokens
     * const blacklistedTokens = await prisma.blacklistedToken.findMany()
     * 
     * // Get first 10 BlacklistedTokens
     * const blacklistedTokens = await prisma.blacklistedToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const blacklistedTokenWithIdOnly = await prisma.blacklistedToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BlacklistedTokenFindManyArgs>(args?: SelectSubset<T, BlacklistedTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BlacklistedToken.
     * @param {BlacklistedTokenCreateArgs} args - Arguments to create a BlacklistedToken.
     * @example
     * // Create one BlacklistedToken
     * const BlacklistedToken = await prisma.blacklistedToken.create({
     *   data: {
     *     // ... data to create a BlacklistedToken
     *   }
     * })
     * 
     */
    create<T extends BlacklistedTokenCreateArgs>(args: SelectSubset<T, BlacklistedTokenCreateArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BlacklistedTokens.
     * @param {BlacklistedTokenCreateManyArgs} args - Arguments to create many BlacklistedTokens.
     * @example
     * // Create many BlacklistedTokens
     * const blacklistedToken = await prisma.blacklistedToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BlacklistedTokenCreateManyArgs>(args?: SelectSubset<T, BlacklistedTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BlacklistedTokens and returns the data saved in the database.
     * @param {BlacklistedTokenCreateManyAndReturnArgs} args - Arguments to create many BlacklistedTokens.
     * @example
     * // Create many BlacklistedTokens
     * const blacklistedToken = await prisma.blacklistedToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BlacklistedTokens and only return the `id`
     * const blacklistedTokenWithIdOnly = await prisma.blacklistedToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BlacklistedTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, BlacklistedTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BlacklistedToken.
     * @param {BlacklistedTokenDeleteArgs} args - Arguments to delete one BlacklistedToken.
     * @example
     * // Delete one BlacklistedToken
     * const BlacklistedToken = await prisma.blacklistedToken.delete({
     *   where: {
     *     // ... filter to delete one BlacklistedToken
     *   }
     * })
     * 
     */
    delete<T extends BlacklistedTokenDeleteArgs>(args: SelectSubset<T, BlacklistedTokenDeleteArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BlacklistedToken.
     * @param {BlacklistedTokenUpdateArgs} args - Arguments to update one BlacklistedToken.
     * @example
     * // Update one BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BlacklistedTokenUpdateArgs>(args: SelectSubset<T, BlacklistedTokenUpdateArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BlacklistedTokens.
     * @param {BlacklistedTokenDeleteManyArgs} args - Arguments to filter BlacklistedTokens to delete.
     * @example
     * // Delete a few BlacklistedTokens
     * const { count } = await prisma.blacklistedToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BlacklistedTokenDeleteManyArgs>(args?: SelectSubset<T, BlacklistedTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlacklistedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BlacklistedTokens
     * const blacklistedToken = await prisma.blacklistedToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BlacklistedTokenUpdateManyArgs>(args: SelectSubset<T, BlacklistedTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BlacklistedTokens and returns the data updated in the database.
     * @param {BlacklistedTokenUpdateManyAndReturnArgs} args - Arguments to update many BlacklistedTokens.
     * @example
     * // Update many BlacklistedTokens
     * const blacklistedToken = await prisma.blacklistedToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BlacklistedTokens and only return the `id`
     * const blacklistedTokenWithIdOnly = await prisma.blacklistedToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BlacklistedTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, BlacklistedTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BlacklistedToken.
     * @param {BlacklistedTokenUpsertArgs} args - Arguments to update or create a BlacklistedToken.
     * @example
     * // Update or create a BlacklistedToken
     * const blacklistedToken = await prisma.blacklistedToken.upsert({
     *   create: {
     *     // ... data to create a BlacklistedToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BlacklistedToken we want to update
     *   }
     * })
     */
    upsert<T extends BlacklistedTokenUpsertArgs>(args: SelectSubset<T, BlacklistedTokenUpsertArgs<ExtArgs>>): Prisma__BlacklistedTokenClient<$Result.GetResult<Prisma.$BlacklistedTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BlacklistedTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenCountArgs} args - Arguments to filter BlacklistedTokens to count.
     * @example
     * // Count the number of BlacklistedTokens
     * const count = await prisma.blacklistedToken.count({
     *   where: {
     *     // ... the filter for the BlacklistedTokens we want to count
     *   }
     * })
    **/
    count<T extends BlacklistedTokenCountArgs>(
      args?: Subset<T, BlacklistedTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BlacklistedTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BlacklistedToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BlacklistedTokenAggregateArgs>(args: Subset<T, BlacklistedTokenAggregateArgs>): Prisma.PrismaPromise<GetBlacklistedTokenAggregateType<T>>

    /**
     * Group by BlacklistedToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BlacklistedTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BlacklistedTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BlacklistedTokenGroupByArgs['orderBy'] }
        : { orderBy?: BlacklistedTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BlacklistedTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBlacklistedTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BlacklistedToken model
   */
  readonly fields: BlacklistedTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BlacklistedToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BlacklistedTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BlacklistedToken model
   */
  interface BlacklistedTokenFieldRefs {
    readonly id: FieldRef<"BlacklistedToken", 'Int'>
    readonly token: FieldRef<"BlacklistedToken", 'String'>
    readonly createdAt: FieldRef<"BlacklistedToken", 'DateTime'>
    readonly expiresAt: FieldRef<"BlacklistedToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BlacklistedToken findUnique
   */
  export type BlacklistedTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Filter, which BlacklistedToken to fetch.
     */
    where: BlacklistedTokenWhereUniqueInput
  }

  /**
   * BlacklistedToken findUniqueOrThrow
   */
  export type BlacklistedTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Filter, which BlacklistedToken to fetch.
     */
    where: BlacklistedTokenWhereUniqueInput
  }

  /**
   * BlacklistedToken findFirst
   */
  export type BlacklistedTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Filter, which BlacklistedToken to fetch.
     */
    where?: BlacklistedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistedTokens to fetch.
     */
    orderBy?: BlacklistedTokenOrderByWithRelationInput | BlacklistedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlacklistedTokens.
     */
    cursor?: BlacklistedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlacklistedTokens.
     */
    distinct?: BlacklistedTokenScalarFieldEnum | BlacklistedTokenScalarFieldEnum[]
  }

  /**
   * BlacklistedToken findFirstOrThrow
   */
  export type BlacklistedTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Filter, which BlacklistedToken to fetch.
     */
    where?: BlacklistedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistedTokens to fetch.
     */
    orderBy?: BlacklistedTokenOrderByWithRelationInput | BlacklistedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BlacklistedTokens.
     */
    cursor?: BlacklistedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistedTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BlacklistedTokens.
     */
    distinct?: BlacklistedTokenScalarFieldEnum | BlacklistedTokenScalarFieldEnum[]
  }

  /**
   * BlacklistedToken findMany
   */
  export type BlacklistedTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Filter, which BlacklistedTokens to fetch.
     */
    where?: BlacklistedTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BlacklistedTokens to fetch.
     */
    orderBy?: BlacklistedTokenOrderByWithRelationInput | BlacklistedTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BlacklistedTokens.
     */
    cursor?: BlacklistedTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BlacklistedTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BlacklistedTokens.
     */
    skip?: number
    distinct?: BlacklistedTokenScalarFieldEnum | BlacklistedTokenScalarFieldEnum[]
  }

  /**
   * BlacklistedToken create
   */
  export type BlacklistedTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a BlacklistedToken.
     */
    data: XOR<BlacklistedTokenCreateInput, BlacklistedTokenUncheckedCreateInput>
  }

  /**
   * BlacklistedToken createMany
   */
  export type BlacklistedTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BlacklistedTokens.
     */
    data: BlacklistedTokenCreateManyInput | BlacklistedTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlacklistedToken createManyAndReturn
   */
  export type BlacklistedTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * The data used to create many BlacklistedTokens.
     */
    data: BlacklistedTokenCreateManyInput | BlacklistedTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BlacklistedToken update
   */
  export type BlacklistedTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a BlacklistedToken.
     */
    data: XOR<BlacklistedTokenUpdateInput, BlacklistedTokenUncheckedUpdateInput>
    /**
     * Choose, which BlacklistedToken to update.
     */
    where: BlacklistedTokenWhereUniqueInput
  }

  /**
   * BlacklistedToken updateMany
   */
  export type BlacklistedTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BlacklistedTokens.
     */
    data: XOR<BlacklistedTokenUpdateManyMutationInput, BlacklistedTokenUncheckedUpdateManyInput>
    /**
     * Filter which BlacklistedTokens to update
     */
    where?: BlacklistedTokenWhereInput
    /**
     * Limit how many BlacklistedTokens to update.
     */
    limit?: number
  }

  /**
   * BlacklistedToken updateManyAndReturn
   */
  export type BlacklistedTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * The data used to update BlacklistedTokens.
     */
    data: XOR<BlacklistedTokenUpdateManyMutationInput, BlacklistedTokenUncheckedUpdateManyInput>
    /**
     * Filter which BlacklistedTokens to update
     */
    where?: BlacklistedTokenWhereInput
    /**
     * Limit how many BlacklistedTokens to update.
     */
    limit?: number
  }

  /**
   * BlacklistedToken upsert
   */
  export type BlacklistedTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the BlacklistedToken to update in case it exists.
     */
    where: BlacklistedTokenWhereUniqueInput
    /**
     * In case the BlacklistedToken found by the `where` argument doesn't exist, create a new BlacklistedToken with this data.
     */
    create: XOR<BlacklistedTokenCreateInput, BlacklistedTokenUncheckedCreateInput>
    /**
     * In case the BlacklistedToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BlacklistedTokenUpdateInput, BlacklistedTokenUncheckedUpdateInput>
  }

  /**
   * BlacklistedToken delete
   */
  export type BlacklistedTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
    /**
     * Filter which BlacklistedToken to delete.
     */
    where: BlacklistedTokenWhereUniqueInput
  }

  /**
   * BlacklistedToken deleteMany
   */
  export type BlacklistedTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BlacklistedTokens to delete
     */
    where?: BlacklistedTokenWhereInput
    /**
     * Limit how many BlacklistedTokens to delete.
     */
    limit?: number
  }

  /**
   * BlacklistedToken without action
   */
  export type BlacklistedTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BlacklistedToken
     */
    select?: BlacklistedTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BlacklistedToken
     */
    omit?: BlacklistedTokenOmit<ExtArgs> | null
  }


  /**
   * Model Canvas
   */

  export type AggregateCanvas = {
    _count: CanvasCountAggregateOutputType | null
    _avg: CanvasAvgAggregateOutputType | null
    _sum: CanvasSumAggregateOutputType | null
    _min: CanvasMinAggregateOutputType | null
    _max: CanvasMaxAggregateOutputType | null
  }

  export type CanvasAvgAggregateOutputType = {
    id: number | null
    appId: number | null
    width: number | null
    height: number | null
    zoomLevel: number | null
  }

  export type CanvasSumAggregateOutputType = {
    id: number | null
    appId: number | null
    width: number | null
    height: number | null
    zoomLevel: number | null
  }

  export type CanvasMinAggregateOutputType = {
    id: number | null
    appId: number | null
    name: string | null
    description: string | null
    width: number | null
    height: number | null
    gridEnabled: boolean | null
    snapEnabled: boolean | null
    zoomLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CanvasMaxAggregateOutputType = {
    id: number | null
    appId: number | null
    name: string | null
    description: string | null
    width: number | null
    height: number | null
    gridEnabled: boolean | null
    snapEnabled: boolean | null
    zoomLevel: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CanvasCountAggregateOutputType = {
    id: number
    appId: number
    name: number
    description: number
    width: number
    height: number
    background: number
    gridEnabled: number
    snapEnabled: number
    zoomLevel: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CanvasAvgAggregateInputType = {
    id?: true
    appId?: true
    width?: true
    height?: true
    zoomLevel?: true
  }

  export type CanvasSumAggregateInputType = {
    id?: true
    appId?: true
    width?: true
    height?: true
    zoomLevel?: true
  }

  export type CanvasMinAggregateInputType = {
    id?: true
    appId?: true
    name?: true
    description?: true
    width?: true
    height?: true
    gridEnabled?: true
    snapEnabled?: true
    zoomLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CanvasMaxAggregateInputType = {
    id?: true
    appId?: true
    name?: true
    description?: true
    width?: true
    height?: true
    gridEnabled?: true
    snapEnabled?: true
    zoomLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CanvasCountAggregateInputType = {
    id?: true
    appId?: true
    name?: true
    description?: true
    width?: true
    height?: true
    background?: true
    gridEnabled?: true
    snapEnabled?: true
    zoomLevel?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CanvasAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Canvas to aggregate.
     */
    where?: CanvasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvas to fetch.
     */
    orderBy?: CanvasOrderByWithRelationInput | CanvasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CanvasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Canvas
    **/
    _count?: true | CanvasCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CanvasAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CanvasSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CanvasMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CanvasMaxAggregateInputType
  }

  export type GetCanvasAggregateType<T extends CanvasAggregateArgs> = {
        [P in keyof T & keyof AggregateCanvas]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCanvas[P]>
      : GetScalarType<T[P], AggregateCanvas[P]>
  }




  export type CanvasGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasWhereInput
    orderBy?: CanvasOrderByWithAggregationInput | CanvasOrderByWithAggregationInput[]
    by: CanvasScalarFieldEnum[] | CanvasScalarFieldEnum
    having?: CanvasScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CanvasCountAggregateInputType | true
    _avg?: CanvasAvgAggregateInputType
    _sum?: CanvasSumAggregateInputType
    _min?: CanvasMinAggregateInputType
    _max?: CanvasMaxAggregateInputType
  }

  export type CanvasGroupByOutputType = {
    id: number
    appId: number
    name: string
    description: string | null
    width: number
    height: number
    background: JsonValue
    gridEnabled: boolean
    snapEnabled: boolean
    zoomLevel: number
    createdAt: Date
    updatedAt: Date
    _count: CanvasCountAggregateOutputType | null
    _avg: CanvasAvgAggregateOutputType | null
    _sum: CanvasSumAggregateOutputType | null
    _min: CanvasMinAggregateOutputType | null
    _max: CanvasMaxAggregateOutputType | null
  }

  type GetCanvasGroupByPayload<T extends CanvasGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CanvasGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CanvasGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CanvasGroupByOutputType[P]>
            : GetScalarType<T[P], CanvasGroupByOutputType[P]>
        }
      >
    >


  export type CanvasSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    name?: boolean
    description?: boolean
    width?: boolean
    height?: boolean
    background?: boolean
    gridEnabled?: boolean
    snapEnabled?: boolean
    zoomLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
    elements?: boolean | Canvas$elementsArgs<ExtArgs>
    history?: boolean | Canvas$historyArgs<ExtArgs>
    _count?: boolean | CanvasCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvas"]>

  export type CanvasSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    name?: boolean
    description?: boolean
    width?: boolean
    height?: boolean
    background?: boolean
    gridEnabled?: boolean
    snapEnabled?: boolean
    zoomLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvas"]>

  export type CanvasSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    appId?: boolean
    name?: boolean
    description?: boolean
    width?: boolean
    height?: boolean
    background?: boolean
    gridEnabled?: boolean
    snapEnabled?: boolean
    zoomLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    app?: boolean | AppDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvas"]>

  export type CanvasSelectScalar = {
    id?: boolean
    appId?: boolean
    name?: boolean
    description?: boolean
    width?: boolean
    height?: boolean
    background?: boolean
    gridEnabled?: boolean
    snapEnabled?: boolean
    zoomLevel?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CanvasOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "appId" | "name" | "description" | "width" | "height" | "background" | "gridEnabled" | "snapEnabled" | "zoomLevel" | "createdAt" | "updatedAt", ExtArgs["result"]["canvas"]>
  export type CanvasInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
    elements?: boolean | Canvas$elementsArgs<ExtArgs>
    history?: boolean | Canvas$historyArgs<ExtArgs>
    _count?: boolean | CanvasCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CanvasIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }
  export type CanvasIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    app?: boolean | AppDefaultArgs<ExtArgs>
  }

  export type $CanvasPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Canvas"
    objects: {
      app: Prisma.$AppPayload<ExtArgs>
      elements: Prisma.$CanvasElementPayload<ExtArgs>[]
      history: Prisma.$CanvasHistoryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      appId: number
      name: string
      description: string | null
      width: number
      height: number
      background: Prisma.JsonValue
      gridEnabled: boolean
      snapEnabled: boolean
      zoomLevel: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["canvas"]>
    composites: {}
  }

  type CanvasGetPayload<S extends boolean | null | undefined | CanvasDefaultArgs> = $Result.GetResult<Prisma.$CanvasPayload, S>

  type CanvasCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CanvasFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CanvasCountAggregateInputType | true
    }

  export interface CanvasDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Canvas'], meta: { name: 'Canvas' } }
    /**
     * Find zero or one Canvas that matches the filter.
     * @param {CanvasFindUniqueArgs} args - Arguments to find a Canvas
     * @example
     * // Get one Canvas
     * const canvas = await prisma.canvas.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CanvasFindUniqueArgs>(args: SelectSubset<T, CanvasFindUniqueArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Canvas that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CanvasFindUniqueOrThrowArgs} args - Arguments to find a Canvas
     * @example
     * // Get one Canvas
     * const canvas = await prisma.canvas.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CanvasFindUniqueOrThrowArgs>(args: SelectSubset<T, CanvasFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Canvas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasFindFirstArgs} args - Arguments to find a Canvas
     * @example
     * // Get one Canvas
     * const canvas = await prisma.canvas.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CanvasFindFirstArgs>(args?: SelectSubset<T, CanvasFindFirstArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Canvas that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasFindFirstOrThrowArgs} args - Arguments to find a Canvas
     * @example
     * // Get one Canvas
     * const canvas = await prisma.canvas.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CanvasFindFirstOrThrowArgs>(args?: SelectSubset<T, CanvasFindFirstOrThrowArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Canvas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Canvas
     * const canvas = await prisma.canvas.findMany()
     * 
     * // Get first 10 Canvas
     * const canvas = await prisma.canvas.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const canvasWithIdOnly = await prisma.canvas.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CanvasFindManyArgs>(args?: SelectSubset<T, CanvasFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Canvas.
     * @param {CanvasCreateArgs} args - Arguments to create a Canvas.
     * @example
     * // Create one Canvas
     * const Canvas = await prisma.canvas.create({
     *   data: {
     *     // ... data to create a Canvas
     *   }
     * })
     * 
     */
    create<T extends CanvasCreateArgs>(args: SelectSubset<T, CanvasCreateArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Canvas.
     * @param {CanvasCreateManyArgs} args - Arguments to create many Canvas.
     * @example
     * // Create many Canvas
     * const canvas = await prisma.canvas.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CanvasCreateManyArgs>(args?: SelectSubset<T, CanvasCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Canvas and returns the data saved in the database.
     * @param {CanvasCreateManyAndReturnArgs} args - Arguments to create many Canvas.
     * @example
     * // Create many Canvas
     * const canvas = await prisma.canvas.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Canvas and only return the `id`
     * const canvasWithIdOnly = await prisma.canvas.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CanvasCreateManyAndReturnArgs>(args?: SelectSubset<T, CanvasCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Canvas.
     * @param {CanvasDeleteArgs} args - Arguments to delete one Canvas.
     * @example
     * // Delete one Canvas
     * const Canvas = await prisma.canvas.delete({
     *   where: {
     *     // ... filter to delete one Canvas
     *   }
     * })
     * 
     */
    delete<T extends CanvasDeleteArgs>(args: SelectSubset<T, CanvasDeleteArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Canvas.
     * @param {CanvasUpdateArgs} args - Arguments to update one Canvas.
     * @example
     * // Update one Canvas
     * const canvas = await prisma.canvas.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CanvasUpdateArgs>(args: SelectSubset<T, CanvasUpdateArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Canvas.
     * @param {CanvasDeleteManyArgs} args - Arguments to filter Canvas to delete.
     * @example
     * // Delete a few Canvas
     * const { count } = await prisma.canvas.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CanvasDeleteManyArgs>(args?: SelectSubset<T, CanvasDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Canvas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Canvas
     * const canvas = await prisma.canvas.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CanvasUpdateManyArgs>(args: SelectSubset<T, CanvasUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Canvas and returns the data updated in the database.
     * @param {CanvasUpdateManyAndReturnArgs} args - Arguments to update many Canvas.
     * @example
     * // Update many Canvas
     * const canvas = await prisma.canvas.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Canvas and only return the `id`
     * const canvasWithIdOnly = await prisma.canvas.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CanvasUpdateManyAndReturnArgs>(args: SelectSubset<T, CanvasUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Canvas.
     * @param {CanvasUpsertArgs} args - Arguments to update or create a Canvas.
     * @example
     * // Update or create a Canvas
     * const canvas = await prisma.canvas.upsert({
     *   create: {
     *     // ... data to create a Canvas
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Canvas we want to update
     *   }
     * })
     */
    upsert<T extends CanvasUpsertArgs>(args: SelectSubset<T, CanvasUpsertArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Canvas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasCountArgs} args - Arguments to filter Canvas to count.
     * @example
     * // Count the number of Canvas
     * const count = await prisma.canvas.count({
     *   where: {
     *     // ... the filter for the Canvas we want to count
     *   }
     * })
    **/
    count<T extends CanvasCountArgs>(
      args?: Subset<T, CanvasCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CanvasCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Canvas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CanvasAggregateArgs>(args: Subset<T, CanvasAggregateArgs>): Prisma.PrismaPromise<GetCanvasAggregateType<T>>

    /**
     * Group by Canvas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CanvasGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CanvasGroupByArgs['orderBy'] }
        : { orderBy?: CanvasGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CanvasGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCanvasGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Canvas model
   */
  readonly fields: CanvasFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Canvas.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CanvasClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    app<T extends AppDefaultArgs<ExtArgs> = {}>(args?: Subset<T, AppDefaultArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    elements<T extends Canvas$elementsArgs<ExtArgs> = {}>(args?: Subset<T, Canvas$elementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    history<T extends Canvas$historyArgs<ExtArgs> = {}>(args?: Subset<T, Canvas$historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Canvas model
   */
  interface CanvasFieldRefs {
    readonly id: FieldRef<"Canvas", 'Int'>
    readonly appId: FieldRef<"Canvas", 'Int'>
    readonly name: FieldRef<"Canvas", 'String'>
    readonly description: FieldRef<"Canvas", 'String'>
    readonly width: FieldRef<"Canvas", 'Int'>
    readonly height: FieldRef<"Canvas", 'Int'>
    readonly background: FieldRef<"Canvas", 'Json'>
    readonly gridEnabled: FieldRef<"Canvas", 'Boolean'>
    readonly snapEnabled: FieldRef<"Canvas", 'Boolean'>
    readonly zoomLevel: FieldRef<"Canvas", 'Float'>
    readonly createdAt: FieldRef<"Canvas", 'DateTime'>
    readonly updatedAt: FieldRef<"Canvas", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Canvas findUnique
   */
  export type CanvasFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * Filter, which Canvas to fetch.
     */
    where: CanvasWhereUniqueInput
  }

  /**
   * Canvas findUniqueOrThrow
   */
  export type CanvasFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * Filter, which Canvas to fetch.
     */
    where: CanvasWhereUniqueInput
  }

  /**
   * Canvas findFirst
   */
  export type CanvasFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * Filter, which Canvas to fetch.
     */
    where?: CanvasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvas to fetch.
     */
    orderBy?: CanvasOrderByWithRelationInput | CanvasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Canvas.
     */
    cursor?: CanvasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Canvas.
     */
    distinct?: CanvasScalarFieldEnum | CanvasScalarFieldEnum[]
  }

  /**
   * Canvas findFirstOrThrow
   */
  export type CanvasFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * Filter, which Canvas to fetch.
     */
    where?: CanvasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvas to fetch.
     */
    orderBy?: CanvasOrderByWithRelationInput | CanvasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Canvas.
     */
    cursor?: CanvasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Canvas.
     */
    distinct?: CanvasScalarFieldEnum | CanvasScalarFieldEnum[]
  }

  /**
   * Canvas findMany
   */
  export type CanvasFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * Filter, which Canvas to fetch.
     */
    where?: CanvasWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Canvas to fetch.
     */
    orderBy?: CanvasOrderByWithRelationInput | CanvasOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Canvas.
     */
    cursor?: CanvasWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Canvas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Canvas.
     */
    skip?: number
    distinct?: CanvasScalarFieldEnum | CanvasScalarFieldEnum[]
  }

  /**
   * Canvas create
   */
  export type CanvasCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * The data needed to create a Canvas.
     */
    data: XOR<CanvasCreateInput, CanvasUncheckedCreateInput>
  }

  /**
   * Canvas createMany
   */
  export type CanvasCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Canvas.
     */
    data: CanvasCreateManyInput | CanvasCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Canvas createManyAndReturn
   */
  export type CanvasCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * The data used to create many Canvas.
     */
    data: CanvasCreateManyInput | CanvasCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Canvas update
   */
  export type CanvasUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * The data needed to update a Canvas.
     */
    data: XOR<CanvasUpdateInput, CanvasUncheckedUpdateInput>
    /**
     * Choose, which Canvas to update.
     */
    where: CanvasWhereUniqueInput
  }

  /**
   * Canvas updateMany
   */
  export type CanvasUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Canvas.
     */
    data: XOR<CanvasUpdateManyMutationInput, CanvasUncheckedUpdateManyInput>
    /**
     * Filter which Canvas to update
     */
    where?: CanvasWhereInput
    /**
     * Limit how many Canvas to update.
     */
    limit?: number
  }

  /**
   * Canvas updateManyAndReturn
   */
  export type CanvasUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * The data used to update Canvas.
     */
    data: XOR<CanvasUpdateManyMutationInput, CanvasUncheckedUpdateManyInput>
    /**
     * Filter which Canvas to update
     */
    where?: CanvasWhereInput
    /**
     * Limit how many Canvas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Canvas upsert
   */
  export type CanvasUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * The filter to search for the Canvas to update in case it exists.
     */
    where: CanvasWhereUniqueInput
    /**
     * In case the Canvas found by the `where` argument doesn't exist, create a new Canvas with this data.
     */
    create: XOR<CanvasCreateInput, CanvasUncheckedCreateInput>
    /**
     * In case the Canvas was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CanvasUpdateInput, CanvasUncheckedUpdateInput>
  }

  /**
   * Canvas delete
   */
  export type CanvasDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
    /**
     * Filter which Canvas to delete.
     */
    where: CanvasWhereUniqueInput
  }

  /**
   * Canvas deleteMany
   */
  export type CanvasDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Canvas to delete
     */
    where?: CanvasWhereInput
    /**
     * Limit how many Canvas to delete.
     */
    limit?: number
  }

  /**
   * Canvas.elements
   */
  export type Canvas$elementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElement
     */
    select?: CanvasElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasElement
     */
    omit?: CanvasElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasElementInclude<ExtArgs> | null
    where?: CanvasElementWhereInput
    orderBy?: CanvasElementOrderByWithRelationInput | CanvasElementOrderByWithRelationInput[]
    cursor?: CanvasElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvasElementScalarFieldEnum | CanvasElementScalarFieldEnum[]
  }

  /**
   * Canvas.history
   */
  export type Canvas$historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasHistory
     */
    select?: CanvasHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasHistory
     */
    omit?: CanvasHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasHistoryInclude<ExtArgs> | null
    where?: CanvasHistoryWhereInput
    orderBy?: CanvasHistoryOrderByWithRelationInput | CanvasHistoryOrderByWithRelationInput[]
    cursor?: CanvasHistoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvasHistoryScalarFieldEnum | CanvasHistoryScalarFieldEnum[]
  }

  /**
   * Canvas without action
   */
  export type CanvasDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Canvas
     */
    select?: CanvasSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Canvas
     */
    omit?: CanvasOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasInclude<ExtArgs> | null
  }


  /**
   * Model CanvasElement
   */

  export type AggregateCanvasElement = {
    _count: CanvasElementCountAggregateOutputType | null
    _avg: CanvasElementAvgAggregateOutputType | null
    _sum: CanvasElementSumAggregateOutputType | null
    _min: CanvasElementMinAggregateOutputType | null
    _max: CanvasElementMaxAggregateOutputType | null
  }

  export type CanvasElementAvgAggregateOutputType = {
    id: number | null
    canvasId: number | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    rotation: number | null
    zIndex: number | null
    parentId: number | null
  }

  export type CanvasElementSumAggregateOutputType = {
    id: number | null
    canvasId: number | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    rotation: number | null
    zIndex: number | null
    parentId: number | null
  }

  export type CanvasElementMinAggregateOutputType = {
    id: number | null
    canvasId: number | null
    elementId: string | null
    type: $Enums.ElementType | null
    name: string | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    rotation: number | null
    zIndex: number | null
    locked: boolean | null
    visible: boolean | null
    groupId: string | null
    parentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CanvasElementMaxAggregateOutputType = {
    id: number | null
    canvasId: number | null
    elementId: string | null
    type: $Enums.ElementType | null
    name: string | null
    x: number | null
    y: number | null
    width: number | null
    height: number | null
    rotation: number | null
    zIndex: number | null
    locked: boolean | null
    visible: boolean | null
    groupId: string | null
    parentId: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CanvasElementCountAggregateOutputType = {
    id: number
    canvasId: number
    elementId: number
    type: number
    name: number
    x: number
    y: number
    width: number
    height: number
    rotation: number
    zIndex: number
    locked: number
    visible: number
    groupId: number
    parentId: number
    properties: number
    styles: number
    constraints: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CanvasElementAvgAggregateInputType = {
    id?: true
    canvasId?: true
    x?: true
    y?: true
    width?: true
    height?: true
    rotation?: true
    zIndex?: true
    parentId?: true
  }

  export type CanvasElementSumAggregateInputType = {
    id?: true
    canvasId?: true
    x?: true
    y?: true
    width?: true
    height?: true
    rotation?: true
    zIndex?: true
    parentId?: true
  }

  export type CanvasElementMinAggregateInputType = {
    id?: true
    canvasId?: true
    elementId?: true
    type?: true
    name?: true
    x?: true
    y?: true
    width?: true
    height?: true
    rotation?: true
    zIndex?: true
    locked?: true
    visible?: true
    groupId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CanvasElementMaxAggregateInputType = {
    id?: true
    canvasId?: true
    elementId?: true
    type?: true
    name?: true
    x?: true
    y?: true
    width?: true
    height?: true
    rotation?: true
    zIndex?: true
    locked?: true
    visible?: true
    groupId?: true
    parentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CanvasElementCountAggregateInputType = {
    id?: true
    canvasId?: true
    elementId?: true
    type?: true
    name?: true
    x?: true
    y?: true
    width?: true
    height?: true
    rotation?: true
    zIndex?: true
    locked?: true
    visible?: true
    groupId?: true
    parentId?: true
    properties?: true
    styles?: true
    constraints?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CanvasElementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvasElement to aggregate.
     */
    where?: CanvasElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasElements to fetch.
     */
    orderBy?: CanvasElementOrderByWithRelationInput | CanvasElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CanvasElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CanvasElements
    **/
    _count?: true | CanvasElementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CanvasElementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CanvasElementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CanvasElementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CanvasElementMaxAggregateInputType
  }

  export type GetCanvasElementAggregateType<T extends CanvasElementAggregateArgs> = {
        [P in keyof T & keyof AggregateCanvasElement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCanvasElement[P]>
      : GetScalarType<T[P], AggregateCanvasElement[P]>
  }




  export type CanvasElementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasElementWhereInput
    orderBy?: CanvasElementOrderByWithAggregationInput | CanvasElementOrderByWithAggregationInput[]
    by: CanvasElementScalarFieldEnum[] | CanvasElementScalarFieldEnum
    having?: CanvasElementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CanvasElementCountAggregateInputType | true
    _avg?: CanvasElementAvgAggregateInputType
    _sum?: CanvasElementSumAggregateInputType
    _min?: CanvasElementMinAggregateInputType
    _max?: CanvasElementMaxAggregateInputType
  }

  export type CanvasElementGroupByOutputType = {
    id: number
    canvasId: number
    elementId: string
    type: $Enums.ElementType
    name: string
    x: number
    y: number
    width: number
    height: number
    rotation: number
    zIndex: number
    locked: boolean
    visible: boolean
    groupId: string | null
    parentId: number | null
    properties: JsonValue
    styles: JsonValue
    constraints: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: CanvasElementCountAggregateOutputType | null
    _avg: CanvasElementAvgAggregateOutputType | null
    _sum: CanvasElementSumAggregateOutputType | null
    _min: CanvasElementMinAggregateOutputType | null
    _max: CanvasElementMaxAggregateOutputType | null
  }

  type GetCanvasElementGroupByPayload<T extends CanvasElementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CanvasElementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CanvasElementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CanvasElementGroupByOutputType[P]>
            : GetScalarType<T[P], CanvasElementGroupByOutputType[P]>
        }
      >
    >


  export type CanvasElementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    elementId?: boolean
    type?: boolean
    name?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    rotation?: boolean
    zIndex?: boolean
    locked?: boolean
    visible?: boolean
    groupId?: boolean
    parentId?: boolean
    properties?: boolean
    styles?: boolean
    constraints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    parent?: boolean | CanvasElement$parentArgs<ExtArgs>
    children?: boolean | CanvasElement$childrenArgs<ExtArgs>
    interactions?: boolean | CanvasElement$interactionsArgs<ExtArgs>
    validations?: boolean | CanvasElement$validationsArgs<ExtArgs>
    _count?: boolean | CanvasElementCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasElement"]>

  export type CanvasElementSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    elementId?: boolean
    type?: boolean
    name?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    rotation?: boolean
    zIndex?: boolean
    locked?: boolean
    visible?: boolean
    groupId?: boolean
    parentId?: boolean
    properties?: boolean
    styles?: boolean
    constraints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    parent?: boolean | CanvasElement$parentArgs<ExtArgs>
  }, ExtArgs["result"]["canvasElement"]>

  export type CanvasElementSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    elementId?: boolean
    type?: boolean
    name?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    rotation?: boolean
    zIndex?: boolean
    locked?: boolean
    visible?: boolean
    groupId?: boolean
    parentId?: boolean
    properties?: boolean
    styles?: boolean
    constraints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    parent?: boolean | CanvasElement$parentArgs<ExtArgs>
  }, ExtArgs["result"]["canvasElement"]>

  export type CanvasElementSelectScalar = {
    id?: boolean
    canvasId?: boolean
    elementId?: boolean
    type?: boolean
    name?: boolean
    x?: boolean
    y?: boolean
    width?: boolean
    height?: boolean
    rotation?: boolean
    zIndex?: boolean
    locked?: boolean
    visible?: boolean
    groupId?: boolean
    parentId?: boolean
    properties?: boolean
    styles?: boolean
    constraints?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type CanvasElementOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "canvasId" | "elementId" | "type" | "name" | "x" | "y" | "width" | "height" | "rotation" | "zIndex" | "locked" | "visible" | "groupId" | "parentId" | "properties" | "styles" | "constraints" | "createdAt" | "updatedAt", ExtArgs["result"]["canvasElement"]>
  export type CanvasElementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    parent?: boolean | CanvasElement$parentArgs<ExtArgs>
    children?: boolean | CanvasElement$childrenArgs<ExtArgs>
    interactions?: boolean | CanvasElement$interactionsArgs<ExtArgs>
    validations?: boolean | CanvasElement$validationsArgs<ExtArgs>
    _count?: boolean | CanvasElementCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CanvasElementIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    parent?: boolean | CanvasElement$parentArgs<ExtArgs>
  }
  export type CanvasElementIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    parent?: boolean | CanvasElement$parentArgs<ExtArgs>
  }

  export type $CanvasElementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CanvasElement"
    objects: {
      canvas: Prisma.$CanvasPayload<ExtArgs>
      parent: Prisma.$CanvasElementPayload<ExtArgs> | null
      children: Prisma.$CanvasElementPayload<ExtArgs>[]
      interactions: Prisma.$ElementInteractionPayload<ExtArgs>[]
      validations: Prisma.$ElementValidationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      canvasId: number
      elementId: string
      type: $Enums.ElementType
      name: string
      x: number
      y: number
      width: number
      height: number
      rotation: number
      zIndex: number
      locked: boolean
      visible: boolean
      groupId: string | null
      parentId: number | null
      properties: Prisma.JsonValue
      styles: Prisma.JsonValue
      constraints: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["canvasElement"]>
    composites: {}
  }

  type CanvasElementGetPayload<S extends boolean | null | undefined | CanvasElementDefaultArgs> = $Result.GetResult<Prisma.$CanvasElementPayload, S>

  type CanvasElementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CanvasElementFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CanvasElementCountAggregateInputType | true
    }

  export interface CanvasElementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CanvasElement'], meta: { name: 'CanvasElement' } }
    /**
     * Find zero or one CanvasElement that matches the filter.
     * @param {CanvasElementFindUniqueArgs} args - Arguments to find a CanvasElement
     * @example
     * // Get one CanvasElement
     * const canvasElement = await prisma.canvasElement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CanvasElementFindUniqueArgs>(args: SelectSubset<T, CanvasElementFindUniqueArgs<ExtArgs>>): Prisma__CanvasElementClient<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CanvasElement that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CanvasElementFindUniqueOrThrowArgs} args - Arguments to find a CanvasElement
     * @example
     * // Get one CanvasElement
     * const canvasElement = await prisma.canvasElement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CanvasElementFindUniqueOrThrowArgs>(args: SelectSubset<T, CanvasElementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CanvasElementClient<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CanvasElement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasElementFindFirstArgs} args - Arguments to find a CanvasElement
     * @example
     * // Get one CanvasElement
     * const canvasElement = await prisma.canvasElement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CanvasElementFindFirstArgs>(args?: SelectSubset<T, CanvasElementFindFirstArgs<ExtArgs>>): Prisma__CanvasElementClient<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CanvasElement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasElementFindFirstOrThrowArgs} args - Arguments to find a CanvasElement
     * @example
     * // Get one CanvasElement
     * const canvasElement = await prisma.canvasElement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CanvasElementFindFirstOrThrowArgs>(args?: SelectSubset<T, CanvasElementFindFirstOrThrowArgs<ExtArgs>>): Prisma__CanvasElementClient<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CanvasElements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasElementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CanvasElements
     * const canvasElements = await prisma.canvasElement.findMany()
     * 
     * // Get first 10 CanvasElements
     * const canvasElements = await prisma.canvasElement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const canvasElementWithIdOnly = await prisma.canvasElement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CanvasElementFindManyArgs>(args?: SelectSubset<T, CanvasElementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CanvasElement.
     * @param {CanvasElementCreateArgs} args - Arguments to create a CanvasElement.
     * @example
     * // Create one CanvasElement
     * const CanvasElement = await prisma.canvasElement.create({
     *   data: {
     *     // ... data to create a CanvasElement
     *   }
     * })
     * 
     */
    create<T extends CanvasElementCreateArgs>(args: SelectSubset<T, CanvasElementCreateArgs<ExtArgs>>): Prisma__CanvasElementClient<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CanvasElements.
     * @param {CanvasElementCreateManyArgs} args - Arguments to create many CanvasElements.
     * @example
     * // Create many CanvasElements
     * const canvasElement = await prisma.canvasElement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CanvasElementCreateManyArgs>(args?: SelectSubset<T, CanvasElementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CanvasElements and returns the data saved in the database.
     * @param {CanvasElementCreateManyAndReturnArgs} args - Arguments to create many CanvasElements.
     * @example
     * // Create many CanvasElements
     * const canvasElement = await prisma.canvasElement.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CanvasElements and only return the `id`
     * const canvasElementWithIdOnly = await prisma.canvasElement.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CanvasElementCreateManyAndReturnArgs>(args?: SelectSubset<T, CanvasElementCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CanvasElement.
     * @param {CanvasElementDeleteArgs} args - Arguments to delete one CanvasElement.
     * @example
     * // Delete one CanvasElement
     * const CanvasElement = await prisma.canvasElement.delete({
     *   where: {
     *     // ... filter to delete one CanvasElement
     *   }
     * })
     * 
     */
    delete<T extends CanvasElementDeleteArgs>(args: SelectSubset<T, CanvasElementDeleteArgs<ExtArgs>>): Prisma__CanvasElementClient<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CanvasElement.
     * @param {CanvasElementUpdateArgs} args - Arguments to update one CanvasElement.
     * @example
     * // Update one CanvasElement
     * const canvasElement = await prisma.canvasElement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CanvasElementUpdateArgs>(args: SelectSubset<T, CanvasElementUpdateArgs<ExtArgs>>): Prisma__CanvasElementClient<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CanvasElements.
     * @param {CanvasElementDeleteManyArgs} args - Arguments to filter CanvasElements to delete.
     * @example
     * // Delete a few CanvasElements
     * const { count } = await prisma.canvasElement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CanvasElementDeleteManyArgs>(args?: SelectSubset<T, CanvasElementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvasElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasElementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CanvasElements
     * const canvasElement = await prisma.canvasElement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CanvasElementUpdateManyArgs>(args: SelectSubset<T, CanvasElementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvasElements and returns the data updated in the database.
     * @param {CanvasElementUpdateManyAndReturnArgs} args - Arguments to update many CanvasElements.
     * @example
     * // Update many CanvasElements
     * const canvasElement = await prisma.canvasElement.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CanvasElements and only return the `id`
     * const canvasElementWithIdOnly = await prisma.canvasElement.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CanvasElementUpdateManyAndReturnArgs>(args: SelectSubset<T, CanvasElementUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CanvasElement.
     * @param {CanvasElementUpsertArgs} args - Arguments to update or create a CanvasElement.
     * @example
     * // Update or create a CanvasElement
     * const canvasElement = await prisma.canvasElement.upsert({
     *   create: {
     *     // ... data to create a CanvasElement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CanvasElement we want to update
     *   }
     * })
     */
    upsert<T extends CanvasElementUpsertArgs>(args: SelectSubset<T, CanvasElementUpsertArgs<ExtArgs>>): Prisma__CanvasElementClient<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CanvasElements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasElementCountArgs} args - Arguments to filter CanvasElements to count.
     * @example
     * // Count the number of CanvasElements
     * const count = await prisma.canvasElement.count({
     *   where: {
     *     // ... the filter for the CanvasElements we want to count
     *   }
     * })
    **/
    count<T extends CanvasElementCountArgs>(
      args?: Subset<T, CanvasElementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CanvasElementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CanvasElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasElementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CanvasElementAggregateArgs>(args: Subset<T, CanvasElementAggregateArgs>): Prisma.PrismaPromise<GetCanvasElementAggregateType<T>>

    /**
     * Group by CanvasElement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasElementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CanvasElementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CanvasElementGroupByArgs['orderBy'] }
        : { orderBy?: CanvasElementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CanvasElementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCanvasElementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CanvasElement model
   */
  readonly fields: CanvasElementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CanvasElement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CanvasElementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    canvas<T extends CanvasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvasDefaultArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    parent<T extends CanvasElement$parentArgs<ExtArgs> = {}>(args?: Subset<T, CanvasElement$parentArgs<ExtArgs>>): Prisma__CanvasElementClient<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    children<T extends CanvasElement$childrenArgs<ExtArgs> = {}>(args?: Subset<T, CanvasElement$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    interactions<T extends CanvasElement$interactionsArgs<ExtArgs> = {}>(args?: Subset<T, CanvasElement$interactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElementInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    validations<T extends CanvasElement$validationsArgs<ExtArgs> = {}>(args?: Subset<T, CanvasElement$validationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElementValidationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CanvasElement model
   */
  interface CanvasElementFieldRefs {
    readonly id: FieldRef<"CanvasElement", 'Int'>
    readonly canvasId: FieldRef<"CanvasElement", 'Int'>
    readonly elementId: FieldRef<"CanvasElement", 'String'>
    readonly type: FieldRef<"CanvasElement", 'ElementType'>
    readonly name: FieldRef<"CanvasElement", 'String'>
    readonly x: FieldRef<"CanvasElement", 'Float'>
    readonly y: FieldRef<"CanvasElement", 'Float'>
    readonly width: FieldRef<"CanvasElement", 'Float'>
    readonly height: FieldRef<"CanvasElement", 'Float'>
    readonly rotation: FieldRef<"CanvasElement", 'Float'>
    readonly zIndex: FieldRef<"CanvasElement", 'Int'>
    readonly locked: FieldRef<"CanvasElement", 'Boolean'>
    readonly visible: FieldRef<"CanvasElement", 'Boolean'>
    readonly groupId: FieldRef<"CanvasElement", 'String'>
    readonly parentId: FieldRef<"CanvasElement", 'Int'>
    readonly properties: FieldRef<"CanvasElement", 'Json'>
    readonly styles: FieldRef<"CanvasElement", 'Json'>
    readonly constraints: FieldRef<"CanvasElement", 'Json'>
    readonly createdAt: FieldRef<"CanvasElement", 'DateTime'>
    readonly updatedAt: FieldRef<"CanvasElement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CanvasElement findUnique
   */
  export type CanvasElementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElement
     */
    select?: CanvasElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasElement
     */
    omit?: CanvasElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasElementInclude<ExtArgs> | null
    /**
     * Filter, which CanvasElement to fetch.
     */
    where: CanvasElementWhereUniqueInput
  }

  /**
   * CanvasElement findUniqueOrThrow
   */
  export type CanvasElementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElement
     */
    select?: CanvasElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasElement
     */
    omit?: CanvasElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasElementInclude<ExtArgs> | null
    /**
     * Filter, which CanvasElement to fetch.
     */
    where: CanvasElementWhereUniqueInput
  }

  /**
   * CanvasElement findFirst
   */
  export type CanvasElementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElement
     */
    select?: CanvasElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasElement
     */
    omit?: CanvasElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasElementInclude<ExtArgs> | null
    /**
     * Filter, which CanvasElement to fetch.
     */
    where?: CanvasElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasElements to fetch.
     */
    orderBy?: CanvasElementOrderByWithRelationInput | CanvasElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvasElements.
     */
    cursor?: CanvasElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvasElements.
     */
    distinct?: CanvasElementScalarFieldEnum | CanvasElementScalarFieldEnum[]
  }

  /**
   * CanvasElement findFirstOrThrow
   */
  export type CanvasElementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElement
     */
    select?: CanvasElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasElement
     */
    omit?: CanvasElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasElementInclude<ExtArgs> | null
    /**
     * Filter, which CanvasElement to fetch.
     */
    where?: CanvasElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasElements to fetch.
     */
    orderBy?: CanvasElementOrderByWithRelationInput | CanvasElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvasElements.
     */
    cursor?: CanvasElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasElements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvasElements.
     */
    distinct?: CanvasElementScalarFieldEnum | CanvasElementScalarFieldEnum[]
  }

  /**
   * CanvasElement findMany
   */
  export type CanvasElementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElement
     */
    select?: CanvasElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasElement
     */
    omit?: CanvasElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasElementInclude<ExtArgs> | null
    /**
     * Filter, which CanvasElements to fetch.
     */
    where?: CanvasElementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasElements to fetch.
     */
    orderBy?: CanvasElementOrderByWithRelationInput | CanvasElementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CanvasElements.
     */
    cursor?: CanvasElementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasElements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasElements.
     */
    skip?: number
    distinct?: CanvasElementScalarFieldEnum | CanvasElementScalarFieldEnum[]
  }

  /**
   * CanvasElement create
   */
  export type CanvasElementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElement
     */
    select?: CanvasElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasElement
     */
    omit?: CanvasElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasElementInclude<ExtArgs> | null
    /**
     * The data needed to create a CanvasElement.
     */
    data: XOR<CanvasElementCreateInput, CanvasElementUncheckedCreateInput>
  }

  /**
   * CanvasElement createMany
   */
  export type CanvasElementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CanvasElements.
     */
    data: CanvasElementCreateManyInput | CanvasElementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CanvasElement createManyAndReturn
   */
  export type CanvasElementCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElement
     */
    select?: CanvasElementSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasElement
     */
    omit?: CanvasElementOmit<ExtArgs> | null
    /**
     * The data used to create many CanvasElements.
     */
    data: CanvasElementCreateManyInput | CanvasElementCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasElementIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CanvasElement update
   */
  export type CanvasElementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElement
     */
    select?: CanvasElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasElement
     */
    omit?: CanvasElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasElementInclude<ExtArgs> | null
    /**
     * The data needed to update a CanvasElement.
     */
    data: XOR<CanvasElementUpdateInput, CanvasElementUncheckedUpdateInput>
    /**
     * Choose, which CanvasElement to update.
     */
    where: CanvasElementWhereUniqueInput
  }

  /**
   * CanvasElement updateMany
   */
  export type CanvasElementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CanvasElements.
     */
    data: XOR<CanvasElementUpdateManyMutationInput, CanvasElementUncheckedUpdateManyInput>
    /**
     * Filter which CanvasElements to update
     */
    where?: CanvasElementWhereInput
    /**
     * Limit how many CanvasElements to update.
     */
    limit?: number
  }

  /**
   * CanvasElement updateManyAndReturn
   */
  export type CanvasElementUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElement
     */
    select?: CanvasElementSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasElement
     */
    omit?: CanvasElementOmit<ExtArgs> | null
    /**
     * The data used to update CanvasElements.
     */
    data: XOR<CanvasElementUpdateManyMutationInput, CanvasElementUncheckedUpdateManyInput>
    /**
     * Filter which CanvasElements to update
     */
    where?: CanvasElementWhereInput
    /**
     * Limit how many CanvasElements to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasElementIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CanvasElement upsert
   */
  export type CanvasElementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElement
     */
    select?: CanvasElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasElement
     */
    omit?: CanvasElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasElementInclude<ExtArgs> | null
    /**
     * The filter to search for the CanvasElement to update in case it exists.
     */
    where: CanvasElementWhereUniqueInput
    /**
     * In case the CanvasElement found by the `where` argument doesn't exist, create a new CanvasElement with this data.
     */
    create: XOR<CanvasElementCreateInput, CanvasElementUncheckedCreateInput>
    /**
     * In case the CanvasElement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CanvasElementUpdateInput, CanvasElementUncheckedUpdateInput>
  }

  /**
   * CanvasElement delete
   */
  export type CanvasElementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElement
     */
    select?: CanvasElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasElement
     */
    omit?: CanvasElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasElementInclude<ExtArgs> | null
    /**
     * Filter which CanvasElement to delete.
     */
    where: CanvasElementWhereUniqueInput
  }

  /**
   * CanvasElement deleteMany
   */
  export type CanvasElementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvasElements to delete
     */
    where?: CanvasElementWhereInput
    /**
     * Limit how many CanvasElements to delete.
     */
    limit?: number
  }

  /**
   * CanvasElement.parent
   */
  export type CanvasElement$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElement
     */
    select?: CanvasElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasElement
     */
    omit?: CanvasElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasElementInclude<ExtArgs> | null
    where?: CanvasElementWhereInput
  }

  /**
   * CanvasElement.children
   */
  export type CanvasElement$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElement
     */
    select?: CanvasElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasElement
     */
    omit?: CanvasElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasElementInclude<ExtArgs> | null
    where?: CanvasElementWhereInput
    orderBy?: CanvasElementOrderByWithRelationInput | CanvasElementOrderByWithRelationInput[]
    cursor?: CanvasElementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CanvasElementScalarFieldEnum | CanvasElementScalarFieldEnum[]
  }

  /**
   * CanvasElement.interactions
   */
  export type CanvasElement$interactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementInteraction
     */
    select?: ElementInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementInteraction
     */
    omit?: ElementInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInteractionInclude<ExtArgs> | null
    where?: ElementInteractionWhereInput
    orderBy?: ElementInteractionOrderByWithRelationInput | ElementInteractionOrderByWithRelationInput[]
    cursor?: ElementInteractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ElementInteractionScalarFieldEnum | ElementInteractionScalarFieldEnum[]
  }

  /**
   * CanvasElement.validations
   */
  export type CanvasElement$validationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementValidation
     */
    select?: ElementValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementValidation
     */
    omit?: ElementValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementValidationInclude<ExtArgs> | null
    where?: ElementValidationWhereInput
    orderBy?: ElementValidationOrderByWithRelationInput | ElementValidationOrderByWithRelationInput[]
    cursor?: ElementValidationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ElementValidationScalarFieldEnum | ElementValidationScalarFieldEnum[]
  }

  /**
   * CanvasElement without action
   */
  export type CanvasElementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasElement
     */
    select?: CanvasElementSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasElement
     */
    omit?: CanvasElementOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasElementInclude<ExtArgs> | null
  }


  /**
   * Model ElementInteraction
   */

  export type AggregateElementInteraction = {
    _count: ElementInteractionCountAggregateOutputType | null
    _avg: ElementInteractionAvgAggregateOutputType | null
    _sum: ElementInteractionSumAggregateOutputType | null
    _min: ElementInteractionMinAggregateOutputType | null
    _max: ElementInteractionMaxAggregateOutputType | null
  }

  export type ElementInteractionAvgAggregateOutputType = {
    id: number | null
    elementId: number | null
  }

  export type ElementInteractionSumAggregateOutputType = {
    id: number | null
    elementId: number | null
  }

  export type ElementInteractionMinAggregateOutputType = {
    id: number | null
    elementId: number | null
    event: string | null
    createdAt: Date | null
  }

  export type ElementInteractionMaxAggregateOutputType = {
    id: number | null
    elementId: number | null
    event: string | null
    createdAt: Date | null
  }

  export type ElementInteractionCountAggregateOutputType = {
    id: number
    elementId: number
    event: number
    action: number
    createdAt: number
    _all: number
  }


  export type ElementInteractionAvgAggregateInputType = {
    id?: true
    elementId?: true
  }

  export type ElementInteractionSumAggregateInputType = {
    id?: true
    elementId?: true
  }

  export type ElementInteractionMinAggregateInputType = {
    id?: true
    elementId?: true
    event?: true
    createdAt?: true
  }

  export type ElementInteractionMaxAggregateInputType = {
    id?: true
    elementId?: true
    event?: true
    createdAt?: true
  }

  export type ElementInteractionCountAggregateInputType = {
    id?: true
    elementId?: true
    event?: true
    action?: true
    createdAt?: true
    _all?: true
  }

  export type ElementInteractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElementInteraction to aggregate.
     */
    where?: ElementInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElementInteractions to fetch.
     */
    orderBy?: ElementInteractionOrderByWithRelationInput | ElementInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ElementInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElementInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElementInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ElementInteractions
    **/
    _count?: true | ElementInteractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ElementInteractionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ElementInteractionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ElementInteractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ElementInteractionMaxAggregateInputType
  }

  export type GetElementInteractionAggregateType<T extends ElementInteractionAggregateArgs> = {
        [P in keyof T & keyof AggregateElementInteraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElementInteraction[P]>
      : GetScalarType<T[P], AggregateElementInteraction[P]>
  }




  export type ElementInteractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElementInteractionWhereInput
    orderBy?: ElementInteractionOrderByWithAggregationInput | ElementInteractionOrderByWithAggregationInput[]
    by: ElementInteractionScalarFieldEnum[] | ElementInteractionScalarFieldEnum
    having?: ElementInteractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ElementInteractionCountAggregateInputType | true
    _avg?: ElementInteractionAvgAggregateInputType
    _sum?: ElementInteractionSumAggregateInputType
    _min?: ElementInteractionMinAggregateInputType
    _max?: ElementInteractionMaxAggregateInputType
  }

  export type ElementInteractionGroupByOutputType = {
    id: number
    elementId: number
    event: string
    action: JsonValue
    createdAt: Date
    _count: ElementInteractionCountAggregateOutputType | null
    _avg: ElementInteractionAvgAggregateOutputType | null
    _sum: ElementInteractionSumAggregateOutputType | null
    _min: ElementInteractionMinAggregateOutputType | null
    _max: ElementInteractionMaxAggregateOutputType | null
  }

  type GetElementInteractionGroupByPayload<T extends ElementInteractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ElementInteractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ElementInteractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ElementInteractionGroupByOutputType[P]>
            : GetScalarType<T[P], ElementInteractionGroupByOutputType[P]>
        }
      >
    >


  export type ElementInteractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    elementId?: boolean
    event?: boolean
    action?: boolean
    createdAt?: boolean
    element?: boolean | CanvasElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elementInteraction"]>

  export type ElementInteractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    elementId?: boolean
    event?: boolean
    action?: boolean
    createdAt?: boolean
    element?: boolean | CanvasElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elementInteraction"]>

  export type ElementInteractionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    elementId?: boolean
    event?: boolean
    action?: boolean
    createdAt?: boolean
    element?: boolean | CanvasElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elementInteraction"]>

  export type ElementInteractionSelectScalar = {
    id?: boolean
    elementId?: boolean
    event?: boolean
    action?: boolean
    createdAt?: boolean
  }

  export type ElementInteractionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "elementId" | "event" | "action" | "createdAt", ExtArgs["result"]["elementInteraction"]>
  export type ElementInteractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    element?: boolean | CanvasElementDefaultArgs<ExtArgs>
  }
  export type ElementInteractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    element?: boolean | CanvasElementDefaultArgs<ExtArgs>
  }
  export type ElementInteractionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    element?: boolean | CanvasElementDefaultArgs<ExtArgs>
  }

  export type $ElementInteractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ElementInteraction"
    objects: {
      element: Prisma.$CanvasElementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      elementId: number
      event: string
      action: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["elementInteraction"]>
    composites: {}
  }

  type ElementInteractionGetPayload<S extends boolean | null | undefined | ElementInteractionDefaultArgs> = $Result.GetResult<Prisma.$ElementInteractionPayload, S>

  type ElementInteractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ElementInteractionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ElementInteractionCountAggregateInputType | true
    }

  export interface ElementInteractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ElementInteraction'], meta: { name: 'ElementInteraction' } }
    /**
     * Find zero or one ElementInteraction that matches the filter.
     * @param {ElementInteractionFindUniqueArgs} args - Arguments to find a ElementInteraction
     * @example
     * // Get one ElementInteraction
     * const elementInteraction = await prisma.elementInteraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ElementInteractionFindUniqueArgs>(args: SelectSubset<T, ElementInteractionFindUniqueArgs<ExtArgs>>): Prisma__ElementInteractionClient<$Result.GetResult<Prisma.$ElementInteractionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ElementInteraction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ElementInteractionFindUniqueOrThrowArgs} args - Arguments to find a ElementInteraction
     * @example
     * // Get one ElementInteraction
     * const elementInteraction = await prisma.elementInteraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ElementInteractionFindUniqueOrThrowArgs>(args: SelectSubset<T, ElementInteractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ElementInteractionClient<$Result.GetResult<Prisma.$ElementInteractionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElementInteraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementInteractionFindFirstArgs} args - Arguments to find a ElementInteraction
     * @example
     * // Get one ElementInteraction
     * const elementInteraction = await prisma.elementInteraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ElementInteractionFindFirstArgs>(args?: SelectSubset<T, ElementInteractionFindFirstArgs<ExtArgs>>): Prisma__ElementInteractionClient<$Result.GetResult<Prisma.$ElementInteractionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElementInteraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementInteractionFindFirstOrThrowArgs} args - Arguments to find a ElementInteraction
     * @example
     * // Get one ElementInteraction
     * const elementInteraction = await prisma.elementInteraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ElementInteractionFindFirstOrThrowArgs>(args?: SelectSubset<T, ElementInteractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ElementInteractionClient<$Result.GetResult<Prisma.$ElementInteractionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ElementInteractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementInteractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ElementInteractions
     * const elementInteractions = await prisma.elementInteraction.findMany()
     * 
     * // Get first 10 ElementInteractions
     * const elementInteractions = await prisma.elementInteraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const elementInteractionWithIdOnly = await prisma.elementInteraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ElementInteractionFindManyArgs>(args?: SelectSubset<T, ElementInteractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElementInteractionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ElementInteraction.
     * @param {ElementInteractionCreateArgs} args - Arguments to create a ElementInteraction.
     * @example
     * // Create one ElementInteraction
     * const ElementInteraction = await prisma.elementInteraction.create({
     *   data: {
     *     // ... data to create a ElementInteraction
     *   }
     * })
     * 
     */
    create<T extends ElementInteractionCreateArgs>(args: SelectSubset<T, ElementInteractionCreateArgs<ExtArgs>>): Prisma__ElementInteractionClient<$Result.GetResult<Prisma.$ElementInteractionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ElementInteractions.
     * @param {ElementInteractionCreateManyArgs} args - Arguments to create many ElementInteractions.
     * @example
     * // Create many ElementInteractions
     * const elementInteraction = await prisma.elementInteraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ElementInteractionCreateManyArgs>(args?: SelectSubset<T, ElementInteractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ElementInteractions and returns the data saved in the database.
     * @param {ElementInteractionCreateManyAndReturnArgs} args - Arguments to create many ElementInteractions.
     * @example
     * // Create many ElementInteractions
     * const elementInteraction = await prisma.elementInteraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ElementInteractions and only return the `id`
     * const elementInteractionWithIdOnly = await prisma.elementInteraction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ElementInteractionCreateManyAndReturnArgs>(args?: SelectSubset<T, ElementInteractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElementInteractionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ElementInteraction.
     * @param {ElementInteractionDeleteArgs} args - Arguments to delete one ElementInteraction.
     * @example
     * // Delete one ElementInteraction
     * const ElementInteraction = await prisma.elementInteraction.delete({
     *   where: {
     *     // ... filter to delete one ElementInteraction
     *   }
     * })
     * 
     */
    delete<T extends ElementInteractionDeleteArgs>(args: SelectSubset<T, ElementInteractionDeleteArgs<ExtArgs>>): Prisma__ElementInteractionClient<$Result.GetResult<Prisma.$ElementInteractionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ElementInteraction.
     * @param {ElementInteractionUpdateArgs} args - Arguments to update one ElementInteraction.
     * @example
     * // Update one ElementInteraction
     * const elementInteraction = await prisma.elementInteraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ElementInteractionUpdateArgs>(args: SelectSubset<T, ElementInteractionUpdateArgs<ExtArgs>>): Prisma__ElementInteractionClient<$Result.GetResult<Prisma.$ElementInteractionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ElementInteractions.
     * @param {ElementInteractionDeleteManyArgs} args - Arguments to filter ElementInteractions to delete.
     * @example
     * // Delete a few ElementInteractions
     * const { count } = await prisma.elementInteraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ElementInteractionDeleteManyArgs>(args?: SelectSubset<T, ElementInteractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElementInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementInteractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ElementInteractions
     * const elementInteraction = await prisma.elementInteraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ElementInteractionUpdateManyArgs>(args: SelectSubset<T, ElementInteractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElementInteractions and returns the data updated in the database.
     * @param {ElementInteractionUpdateManyAndReturnArgs} args - Arguments to update many ElementInteractions.
     * @example
     * // Update many ElementInteractions
     * const elementInteraction = await prisma.elementInteraction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ElementInteractions and only return the `id`
     * const elementInteractionWithIdOnly = await prisma.elementInteraction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ElementInteractionUpdateManyAndReturnArgs>(args: SelectSubset<T, ElementInteractionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElementInteractionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ElementInteraction.
     * @param {ElementInteractionUpsertArgs} args - Arguments to update or create a ElementInteraction.
     * @example
     * // Update or create a ElementInteraction
     * const elementInteraction = await prisma.elementInteraction.upsert({
     *   create: {
     *     // ... data to create a ElementInteraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ElementInteraction we want to update
     *   }
     * })
     */
    upsert<T extends ElementInteractionUpsertArgs>(args: SelectSubset<T, ElementInteractionUpsertArgs<ExtArgs>>): Prisma__ElementInteractionClient<$Result.GetResult<Prisma.$ElementInteractionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ElementInteractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementInteractionCountArgs} args - Arguments to filter ElementInteractions to count.
     * @example
     * // Count the number of ElementInteractions
     * const count = await prisma.elementInteraction.count({
     *   where: {
     *     // ... the filter for the ElementInteractions we want to count
     *   }
     * })
    **/
    count<T extends ElementInteractionCountArgs>(
      args?: Subset<T, ElementInteractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElementInteractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ElementInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementInteractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElementInteractionAggregateArgs>(args: Subset<T, ElementInteractionAggregateArgs>): Prisma.PrismaPromise<GetElementInteractionAggregateType<T>>

    /**
     * Group by ElementInteraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementInteractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ElementInteractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ElementInteractionGroupByArgs['orderBy'] }
        : { orderBy?: ElementInteractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ElementInteractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetElementInteractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ElementInteraction model
   */
  readonly fields: ElementInteractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ElementInteraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ElementInteractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    element<T extends CanvasElementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvasElementDefaultArgs<ExtArgs>>): Prisma__CanvasElementClient<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ElementInteraction model
   */
  interface ElementInteractionFieldRefs {
    readonly id: FieldRef<"ElementInteraction", 'Int'>
    readonly elementId: FieldRef<"ElementInteraction", 'Int'>
    readonly event: FieldRef<"ElementInteraction", 'String'>
    readonly action: FieldRef<"ElementInteraction", 'Json'>
    readonly createdAt: FieldRef<"ElementInteraction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ElementInteraction findUnique
   */
  export type ElementInteractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementInteraction
     */
    select?: ElementInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementInteraction
     */
    omit?: ElementInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInteractionInclude<ExtArgs> | null
    /**
     * Filter, which ElementInteraction to fetch.
     */
    where: ElementInteractionWhereUniqueInput
  }

  /**
   * ElementInteraction findUniqueOrThrow
   */
  export type ElementInteractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementInteraction
     */
    select?: ElementInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementInteraction
     */
    omit?: ElementInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInteractionInclude<ExtArgs> | null
    /**
     * Filter, which ElementInteraction to fetch.
     */
    where: ElementInteractionWhereUniqueInput
  }

  /**
   * ElementInteraction findFirst
   */
  export type ElementInteractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementInteraction
     */
    select?: ElementInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementInteraction
     */
    omit?: ElementInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInteractionInclude<ExtArgs> | null
    /**
     * Filter, which ElementInteraction to fetch.
     */
    where?: ElementInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElementInteractions to fetch.
     */
    orderBy?: ElementInteractionOrderByWithRelationInput | ElementInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElementInteractions.
     */
    cursor?: ElementInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElementInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElementInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElementInteractions.
     */
    distinct?: ElementInteractionScalarFieldEnum | ElementInteractionScalarFieldEnum[]
  }

  /**
   * ElementInteraction findFirstOrThrow
   */
  export type ElementInteractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementInteraction
     */
    select?: ElementInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementInteraction
     */
    omit?: ElementInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInteractionInclude<ExtArgs> | null
    /**
     * Filter, which ElementInteraction to fetch.
     */
    where?: ElementInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElementInteractions to fetch.
     */
    orderBy?: ElementInteractionOrderByWithRelationInput | ElementInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElementInteractions.
     */
    cursor?: ElementInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElementInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElementInteractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElementInteractions.
     */
    distinct?: ElementInteractionScalarFieldEnum | ElementInteractionScalarFieldEnum[]
  }

  /**
   * ElementInteraction findMany
   */
  export type ElementInteractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementInteraction
     */
    select?: ElementInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementInteraction
     */
    omit?: ElementInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInteractionInclude<ExtArgs> | null
    /**
     * Filter, which ElementInteractions to fetch.
     */
    where?: ElementInteractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElementInteractions to fetch.
     */
    orderBy?: ElementInteractionOrderByWithRelationInput | ElementInteractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ElementInteractions.
     */
    cursor?: ElementInteractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElementInteractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElementInteractions.
     */
    skip?: number
    distinct?: ElementInteractionScalarFieldEnum | ElementInteractionScalarFieldEnum[]
  }

  /**
   * ElementInteraction create
   */
  export type ElementInteractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementInteraction
     */
    select?: ElementInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementInteraction
     */
    omit?: ElementInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInteractionInclude<ExtArgs> | null
    /**
     * The data needed to create a ElementInteraction.
     */
    data: XOR<ElementInteractionCreateInput, ElementInteractionUncheckedCreateInput>
  }

  /**
   * ElementInteraction createMany
   */
  export type ElementInteractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ElementInteractions.
     */
    data: ElementInteractionCreateManyInput | ElementInteractionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ElementInteraction createManyAndReturn
   */
  export type ElementInteractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementInteraction
     */
    select?: ElementInteractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElementInteraction
     */
    omit?: ElementInteractionOmit<ExtArgs> | null
    /**
     * The data used to create many ElementInteractions.
     */
    data: ElementInteractionCreateManyInput | ElementInteractionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInteractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ElementInteraction update
   */
  export type ElementInteractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementInteraction
     */
    select?: ElementInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementInteraction
     */
    omit?: ElementInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInteractionInclude<ExtArgs> | null
    /**
     * The data needed to update a ElementInteraction.
     */
    data: XOR<ElementInteractionUpdateInput, ElementInteractionUncheckedUpdateInput>
    /**
     * Choose, which ElementInteraction to update.
     */
    where: ElementInteractionWhereUniqueInput
  }

  /**
   * ElementInteraction updateMany
   */
  export type ElementInteractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ElementInteractions.
     */
    data: XOR<ElementInteractionUpdateManyMutationInput, ElementInteractionUncheckedUpdateManyInput>
    /**
     * Filter which ElementInteractions to update
     */
    where?: ElementInteractionWhereInput
    /**
     * Limit how many ElementInteractions to update.
     */
    limit?: number
  }

  /**
   * ElementInteraction updateManyAndReturn
   */
  export type ElementInteractionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementInteraction
     */
    select?: ElementInteractionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElementInteraction
     */
    omit?: ElementInteractionOmit<ExtArgs> | null
    /**
     * The data used to update ElementInteractions.
     */
    data: XOR<ElementInteractionUpdateManyMutationInput, ElementInteractionUncheckedUpdateManyInput>
    /**
     * Filter which ElementInteractions to update
     */
    where?: ElementInteractionWhereInput
    /**
     * Limit how many ElementInteractions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInteractionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ElementInteraction upsert
   */
  export type ElementInteractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementInteraction
     */
    select?: ElementInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementInteraction
     */
    omit?: ElementInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInteractionInclude<ExtArgs> | null
    /**
     * The filter to search for the ElementInteraction to update in case it exists.
     */
    where: ElementInteractionWhereUniqueInput
    /**
     * In case the ElementInteraction found by the `where` argument doesn't exist, create a new ElementInteraction with this data.
     */
    create: XOR<ElementInteractionCreateInput, ElementInteractionUncheckedCreateInput>
    /**
     * In case the ElementInteraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ElementInteractionUpdateInput, ElementInteractionUncheckedUpdateInput>
  }

  /**
   * ElementInteraction delete
   */
  export type ElementInteractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementInteraction
     */
    select?: ElementInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementInteraction
     */
    omit?: ElementInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInteractionInclude<ExtArgs> | null
    /**
     * Filter which ElementInteraction to delete.
     */
    where: ElementInteractionWhereUniqueInput
  }

  /**
   * ElementInteraction deleteMany
   */
  export type ElementInteractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElementInteractions to delete
     */
    where?: ElementInteractionWhereInput
    /**
     * Limit how many ElementInteractions to delete.
     */
    limit?: number
  }

  /**
   * ElementInteraction without action
   */
  export type ElementInteractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementInteraction
     */
    select?: ElementInteractionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementInteraction
     */
    omit?: ElementInteractionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementInteractionInclude<ExtArgs> | null
  }


  /**
   * Model ElementValidation
   */

  export type AggregateElementValidation = {
    _count: ElementValidationCountAggregateOutputType | null
    _avg: ElementValidationAvgAggregateOutputType | null
    _sum: ElementValidationSumAggregateOutputType | null
    _min: ElementValidationMinAggregateOutputType | null
    _max: ElementValidationMaxAggregateOutputType | null
  }

  export type ElementValidationAvgAggregateOutputType = {
    id: number | null
    elementId: number | null
  }

  export type ElementValidationSumAggregateOutputType = {
    id: number | null
    elementId: number | null
  }

  export type ElementValidationMinAggregateOutputType = {
    id: number | null
    elementId: number | null
    rule: string | null
    message: string | null
    createdAt: Date | null
  }

  export type ElementValidationMaxAggregateOutputType = {
    id: number | null
    elementId: number | null
    rule: string | null
    message: string | null
    createdAt: Date | null
  }

  export type ElementValidationCountAggregateOutputType = {
    id: number
    elementId: number
    rule: number
    value: number
    message: number
    createdAt: number
    _all: number
  }


  export type ElementValidationAvgAggregateInputType = {
    id?: true
    elementId?: true
  }

  export type ElementValidationSumAggregateInputType = {
    id?: true
    elementId?: true
  }

  export type ElementValidationMinAggregateInputType = {
    id?: true
    elementId?: true
    rule?: true
    message?: true
    createdAt?: true
  }

  export type ElementValidationMaxAggregateInputType = {
    id?: true
    elementId?: true
    rule?: true
    message?: true
    createdAt?: true
  }

  export type ElementValidationCountAggregateInputType = {
    id?: true
    elementId?: true
    rule?: true
    value?: true
    message?: true
    createdAt?: true
    _all?: true
  }

  export type ElementValidationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElementValidation to aggregate.
     */
    where?: ElementValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElementValidations to fetch.
     */
    orderBy?: ElementValidationOrderByWithRelationInput | ElementValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ElementValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElementValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElementValidations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ElementValidations
    **/
    _count?: true | ElementValidationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ElementValidationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ElementValidationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ElementValidationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ElementValidationMaxAggregateInputType
  }

  export type GetElementValidationAggregateType<T extends ElementValidationAggregateArgs> = {
        [P in keyof T & keyof AggregateElementValidation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateElementValidation[P]>
      : GetScalarType<T[P], AggregateElementValidation[P]>
  }




  export type ElementValidationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ElementValidationWhereInput
    orderBy?: ElementValidationOrderByWithAggregationInput | ElementValidationOrderByWithAggregationInput[]
    by: ElementValidationScalarFieldEnum[] | ElementValidationScalarFieldEnum
    having?: ElementValidationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ElementValidationCountAggregateInputType | true
    _avg?: ElementValidationAvgAggregateInputType
    _sum?: ElementValidationSumAggregateInputType
    _min?: ElementValidationMinAggregateInputType
    _max?: ElementValidationMaxAggregateInputType
  }

  export type ElementValidationGroupByOutputType = {
    id: number
    elementId: number
    rule: string
    value: JsonValue
    message: string
    createdAt: Date
    _count: ElementValidationCountAggregateOutputType | null
    _avg: ElementValidationAvgAggregateOutputType | null
    _sum: ElementValidationSumAggregateOutputType | null
    _min: ElementValidationMinAggregateOutputType | null
    _max: ElementValidationMaxAggregateOutputType | null
  }

  type GetElementValidationGroupByPayload<T extends ElementValidationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ElementValidationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ElementValidationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ElementValidationGroupByOutputType[P]>
            : GetScalarType<T[P], ElementValidationGroupByOutputType[P]>
        }
      >
    >


  export type ElementValidationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    elementId?: boolean
    rule?: boolean
    value?: boolean
    message?: boolean
    createdAt?: boolean
    element?: boolean | CanvasElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elementValidation"]>

  export type ElementValidationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    elementId?: boolean
    rule?: boolean
    value?: boolean
    message?: boolean
    createdAt?: boolean
    element?: boolean | CanvasElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elementValidation"]>

  export type ElementValidationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    elementId?: boolean
    rule?: boolean
    value?: boolean
    message?: boolean
    createdAt?: boolean
    element?: boolean | CanvasElementDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["elementValidation"]>

  export type ElementValidationSelectScalar = {
    id?: boolean
    elementId?: boolean
    rule?: boolean
    value?: boolean
    message?: boolean
    createdAt?: boolean
  }

  export type ElementValidationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "elementId" | "rule" | "value" | "message" | "createdAt", ExtArgs["result"]["elementValidation"]>
  export type ElementValidationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    element?: boolean | CanvasElementDefaultArgs<ExtArgs>
  }
  export type ElementValidationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    element?: boolean | CanvasElementDefaultArgs<ExtArgs>
  }
  export type ElementValidationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    element?: boolean | CanvasElementDefaultArgs<ExtArgs>
  }

  export type $ElementValidationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ElementValidation"
    objects: {
      element: Prisma.$CanvasElementPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      elementId: number
      rule: string
      value: Prisma.JsonValue
      message: string
      createdAt: Date
    }, ExtArgs["result"]["elementValidation"]>
    composites: {}
  }

  type ElementValidationGetPayload<S extends boolean | null | undefined | ElementValidationDefaultArgs> = $Result.GetResult<Prisma.$ElementValidationPayload, S>

  type ElementValidationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ElementValidationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ElementValidationCountAggregateInputType | true
    }

  export interface ElementValidationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ElementValidation'], meta: { name: 'ElementValidation' } }
    /**
     * Find zero or one ElementValidation that matches the filter.
     * @param {ElementValidationFindUniqueArgs} args - Arguments to find a ElementValidation
     * @example
     * // Get one ElementValidation
     * const elementValidation = await prisma.elementValidation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ElementValidationFindUniqueArgs>(args: SelectSubset<T, ElementValidationFindUniqueArgs<ExtArgs>>): Prisma__ElementValidationClient<$Result.GetResult<Prisma.$ElementValidationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ElementValidation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ElementValidationFindUniqueOrThrowArgs} args - Arguments to find a ElementValidation
     * @example
     * // Get one ElementValidation
     * const elementValidation = await prisma.elementValidation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ElementValidationFindUniqueOrThrowArgs>(args: SelectSubset<T, ElementValidationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ElementValidationClient<$Result.GetResult<Prisma.$ElementValidationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElementValidation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementValidationFindFirstArgs} args - Arguments to find a ElementValidation
     * @example
     * // Get one ElementValidation
     * const elementValidation = await prisma.elementValidation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ElementValidationFindFirstArgs>(args?: SelectSubset<T, ElementValidationFindFirstArgs<ExtArgs>>): Prisma__ElementValidationClient<$Result.GetResult<Prisma.$ElementValidationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ElementValidation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementValidationFindFirstOrThrowArgs} args - Arguments to find a ElementValidation
     * @example
     * // Get one ElementValidation
     * const elementValidation = await prisma.elementValidation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ElementValidationFindFirstOrThrowArgs>(args?: SelectSubset<T, ElementValidationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ElementValidationClient<$Result.GetResult<Prisma.$ElementValidationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ElementValidations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementValidationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ElementValidations
     * const elementValidations = await prisma.elementValidation.findMany()
     * 
     * // Get first 10 ElementValidations
     * const elementValidations = await prisma.elementValidation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const elementValidationWithIdOnly = await prisma.elementValidation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ElementValidationFindManyArgs>(args?: SelectSubset<T, ElementValidationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElementValidationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ElementValidation.
     * @param {ElementValidationCreateArgs} args - Arguments to create a ElementValidation.
     * @example
     * // Create one ElementValidation
     * const ElementValidation = await prisma.elementValidation.create({
     *   data: {
     *     // ... data to create a ElementValidation
     *   }
     * })
     * 
     */
    create<T extends ElementValidationCreateArgs>(args: SelectSubset<T, ElementValidationCreateArgs<ExtArgs>>): Prisma__ElementValidationClient<$Result.GetResult<Prisma.$ElementValidationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ElementValidations.
     * @param {ElementValidationCreateManyArgs} args - Arguments to create many ElementValidations.
     * @example
     * // Create many ElementValidations
     * const elementValidation = await prisma.elementValidation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ElementValidationCreateManyArgs>(args?: SelectSubset<T, ElementValidationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ElementValidations and returns the data saved in the database.
     * @param {ElementValidationCreateManyAndReturnArgs} args - Arguments to create many ElementValidations.
     * @example
     * // Create many ElementValidations
     * const elementValidation = await prisma.elementValidation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ElementValidations and only return the `id`
     * const elementValidationWithIdOnly = await prisma.elementValidation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ElementValidationCreateManyAndReturnArgs>(args?: SelectSubset<T, ElementValidationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElementValidationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ElementValidation.
     * @param {ElementValidationDeleteArgs} args - Arguments to delete one ElementValidation.
     * @example
     * // Delete one ElementValidation
     * const ElementValidation = await prisma.elementValidation.delete({
     *   where: {
     *     // ... filter to delete one ElementValidation
     *   }
     * })
     * 
     */
    delete<T extends ElementValidationDeleteArgs>(args: SelectSubset<T, ElementValidationDeleteArgs<ExtArgs>>): Prisma__ElementValidationClient<$Result.GetResult<Prisma.$ElementValidationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ElementValidation.
     * @param {ElementValidationUpdateArgs} args - Arguments to update one ElementValidation.
     * @example
     * // Update one ElementValidation
     * const elementValidation = await prisma.elementValidation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ElementValidationUpdateArgs>(args: SelectSubset<T, ElementValidationUpdateArgs<ExtArgs>>): Prisma__ElementValidationClient<$Result.GetResult<Prisma.$ElementValidationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ElementValidations.
     * @param {ElementValidationDeleteManyArgs} args - Arguments to filter ElementValidations to delete.
     * @example
     * // Delete a few ElementValidations
     * const { count } = await prisma.elementValidation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ElementValidationDeleteManyArgs>(args?: SelectSubset<T, ElementValidationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElementValidations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementValidationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ElementValidations
     * const elementValidation = await prisma.elementValidation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ElementValidationUpdateManyArgs>(args: SelectSubset<T, ElementValidationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ElementValidations and returns the data updated in the database.
     * @param {ElementValidationUpdateManyAndReturnArgs} args - Arguments to update many ElementValidations.
     * @example
     * // Update many ElementValidations
     * const elementValidation = await prisma.elementValidation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ElementValidations and only return the `id`
     * const elementValidationWithIdOnly = await prisma.elementValidation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ElementValidationUpdateManyAndReturnArgs>(args: SelectSubset<T, ElementValidationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ElementValidationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ElementValidation.
     * @param {ElementValidationUpsertArgs} args - Arguments to update or create a ElementValidation.
     * @example
     * // Update or create a ElementValidation
     * const elementValidation = await prisma.elementValidation.upsert({
     *   create: {
     *     // ... data to create a ElementValidation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ElementValidation we want to update
     *   }
     * })
     */
    upsert<T extends ElementValidationUpsertArgs>(args: SelectSubset<T, ElementValidationUpsertArgs<ExtArgs>>): Prisma__ElementValidationClient<$Result.GetResult<Prisma.$ElementValidationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ElementValidations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementValidationCountArgs} args - Arguments to filter ElementValidations to count.
     * @example
     * // Count the number of ElementValidations
     * const count = await prisma.elementValidation.count({
     *   where: {
     *     // ... the filter for the ElementValidations we want to count
     *   }
     * })
    **/
    count<T extends ElementValidationCountArgs>(
      args?: Subset<T, ElementValidationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ElementValidationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ElementValidation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementValidationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ElementValidationAggregateArgs>(args: Subset<T, ElementValidationAggregateArgs>): Prisma.PrismaPromise<GetElementValidationAggregateType<T>>

    /**
     * Group by ElementValidation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ElementValidationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ElementValidationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ElementValidationGroupByArgs['orderBy'] }
        : { orderBy?: ElementValidationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ElementValidationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetElementValidationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ElementValidation model
   */
  readonly fields: ElementValidationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ElementValidation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ElementValidationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    element<T extends CanvasElementDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvasElementDefaultArgs<ExtArgs>>): Prisma__CanvasElementClient<$Result.GetResult<Prisma.$CanvasElementPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ElementValidation model
   */
  interface ElementValidationFieldRefs {
    readonly id: FieldRef<"ElementValidation", 'Int'>
    readonly elementId: FieldRef<"ElementValidation", 'Int'>
    readonly rule: FieldRef<"ElementValidation", 'String'>
    readonly value: FieldRef<"ElementValidation", 'Json'>
    readonly message: FieldRef<"ElementValidation", 'String'>
    readonly createdAt: FieldRef<"ElementValidation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ElementValidation findUnique
   */
  export type ElementValidationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementValidation
     */
    select?: ElementValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementValidation
     */
    omit?: ElementValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementValidationInclude<ExtArgs> | null
    /**
     * Filter, which ElementValidation to fetch.
     */
    where: ElementValidationWhereUniqueInput
  }

  /**
   * ElementValidation findUniqueOrThrow
   */
  export type ElementValidationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementValidation
     */
    select?: ElementValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementValidation
     */
    omit?: ElementValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementValidationInclude<ExtArgs> | null
    /**
     * Filter, which ElementValidation to fetch.
     */
    where: ElementValidationWhereUniqueInput
  }

  /**
   * ElementValidation findFirst
   */
  export type ElementValidationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementValidation
     */
    select?: ElementValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementValidation
     */
    omit?: ElementValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementValidationInclude<ExtArgs> | null
    /**
     * Filter, which ElementValidation to fetch.
     */
    where?: ElementValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElementValidations to fetch.
     */
    orderBy?: ElementValidationOrderByWithRelationInput | ElementValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElementValidations.
     */
    cursor?: ElementValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElementValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElementValidations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElementValidations.
     */
    distinct?: ElementValidationScalarFieldEnum | ElementValidationScalarFieldEnum[]
  }

  /**
   * ElementValidation findFirstOrThrow
   */
  export type ElementValidationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementValidation
     */
    select?: ElementValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementValidation
     */
    omit?: ElementValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementValidationInclude<ExtArgs> | null
    /**
     * Filter, which ElementValidation to fetch.
     */
    where?: ElementValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElementValidations to fetch.
     */
    orderBy?: ElementValidationOrderByWithRelationInput | ElementValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ElementValidations.
     */
    cursor?: ElementValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElementValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElementValidations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ElementValidations.
     */
    distinct?: ElementValidationScalarFieldEnum | ElementValidationScalarFieldEnum[]
  }

  /**
   * ElementValidation findMany
   */
  export type ElementValidationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementValidation
     */
    select?: ElementValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementValidation
     */
    omit?: ElementValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementValidationInclude<ExtArgs> | null
    /**
     * Filter, which ElementValidations to fetch.
     */
    where?: ElementValidationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ElementValidations to fetch.
     */
    orderBy?: ElementValidationOrderByWithRelationInput | ElementValidationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ElementValidations.
     */
    cursor?: ElementValidationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ElementValidations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ElementValidations.
     */
    skip?: number
    distinct?: ElementValidationScalarFieldEnum | ElementValidationScalarFieldEnum[]
  }

  /**
   * ElementValidation create
   */
  export type ElementValidationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementValidation
     */
    select?: ElementValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementValidation
     */
    omit?: ElementValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementValidationInclude<ExtArgs> | null
    /**
     * The data needed to create a ElementValidation.
     */
    data: XOR<ElementValidationCreateInput, ElementValidationUncheckedCreateInput>
  }

  /**
   * ElementValidation createMany
   */
  export type ElementValidationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ElementValidations.
     */
    data: ElementValidationCreateManyInput | ElementValidationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ElementValidation createManyAndReturn
   */
  export type ElementValidationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementValidation
     */
    select?: ElementValidationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElementValidation
     */
    omit?: ElementValidationOmit<ExtArgs> | null
    /**
     * The data used to create many ElementValidations.
     */
    data: ElementValidationCreateManyInput | ElementValidationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementValidationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ElementValidation update
   */
  export type ElementValidationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementValidation
     */
    select?: ElementValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementValidation
     */
    omit?: ElementValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementValidationInclude<ExtArgs> | null
    /**
     * The data needed to update a ElementValidation.
     */
    data: XOR<ElementValidationUpdateInput, ElementValidationUncheckedUpdateInput>
    /**
     * Choose, which ElementValidation to update.
     */
    where: ElementValidationWhereUniqueInput
  }

  /**
   * ElementValidation updateMany
   */
  export type ElementValidationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ElementValidations.
     */
    data: XOR<ElementValidationUpdateManyMutationInput, ElementValidationUncheckedUpdateManyInput>
    /**
     * Filter which ElementValidations to update
     */
    where?: ElementValidationWhereInput
    /**
     * Limit how many ElementValidations to update.
     */
    limit?: number
  }

  /**
   * ElementValidation updateManyAndReturn
   */
  export type ElementValidationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementValidation
     */
    select?: ElementValidationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ElementValidation
     */
    omit?: ElementValidationOmit<ExtArgs> | null
    /**
     * The data used to update ElementValidations.
     */
    data: XOR<ElementValidationUpdateManyMutationInput, ElementValidationUncheckedUpdateManyInput>
    /**
     * Filter which ElementValidations to update
     */
    where?: ElementValidationWhereInput
    /**
     * Limit how many ElementValidations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementValidationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ElementValidation upsert
   */
  export type ElementValidationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementValidation
     */
    select?: ElementValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementValidation
     */
    omit?: ElementValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementValidationInclude<ExtArgs> | null
    /**
     * The filter to search for the ElementValidation to update in case it exists.
     */
    where: ElementValidationWhereUniqueInput
    /**
     * In case the ElementValidation found by the `where` argument doesn't exist, create a new ElementValidation with this data.
     */
    create: XOR<ElementValidationCreateInput, ElementValidationUncheckedCreateInput>
    /**
     * In case the ElementValidation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ElementValidationUpdateInput, ElementValidationUncheckedUpdateInput>
  }

  /**
   * ElementValidation delete
   */
  export type ElementValidationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementValidation
     */
    select?: ElementValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementValidation
     */
    omit?: ElementValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementValidationInclude<ExtArgs> | null
    /**
     * Filter which ElementValidation to delete.
     */
    where: ElementValidationWhereUniqueInput
  }

  /**
   * ElementValidation deleteMany
   */
  export type ElementValidationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ElementValidations to delete
     */
    where?: ElementValidationWhereInput
    /**
     * Limit how many ElementValidations to delete.
     */
    limit?: number
  }

  /**
   * ElementValidation without action
   */
  export type ElementValidationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ElementValidation
     */
    select?: ElementValidationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ElementValidation
     */
    omit?: ElementValidationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ElementValidationInclude<ExtArgs> | null
  }


  /**
   * Model CanvasHistory
   */

  export type AggregateCanvasHistory = {
    _count: CanvasHistoryCountAggregateOutputType | null
    _avg: CanvasHistoryAvgAggregateOutputType | null
    _sum: CanvasHistorySumAggregateOutputType | null
    _min: CanvasHistoryMinAggregateOutputType | null
    _max: CanvasHistoryMaxAggregateOutputType | null
  }

  export type CanvasHistoryAvgAggregateOutputType = {
    id: number | null
    canvasId: number | null
    userId: number | null
  }

  export type CanvasHistorySumAggregateOutputType = {
    id: number | null
    canvasId: number | null
    userId: number | null
  }

  export type CanvasHistoryMinAggregateOutputType = {
    id: number | null
    canvasId: number | null
    action: string | null
    elementId: string | null
    userId: number | null
    createdAt: Date | null
  }

  export type CanvasHistoryMaxAggregateOutputType = {
    id: number | null
    canvasId: number | null
    action: string | null
    elementId: string | null
    userId: number | null
    createdAt: Date | null
  }

  export type CanvasHistoryCountAggregateOutputType = {
    id: number
    canvasId: number
    action: number
    elementId: number
    oldState: number
    newState: number
    userId: number
    createdAt: number
    _all: number
  }


  export type CanvasHistoryAvgAggregateInputType = {
    id?: true
    canvasId?: true
    userId?: true
  }

  export type CanvasHistorySumAggregateInputType = {
    id?: true
    canvasId?: true
    userId?: true
  }

  export type CanvasHistoryMinAggregateInputType = {
    id?: true
    canvasId?: true
    action?: true
    elementId?: true
    userId?: true
    createdAt?: true
  }

  export type CanvasHistoryMaxAggregateInputType = {
    id?: true
    canvasId?: true
    action?: true
    elementId?: true
    userId?: true
    createdAt?: true
  }

  export type CanvasHistoryCountAggregateInputType = {
    id?: true
    canvasId?: true
    action?: true
    elementId?: true
    oldState?: true
    newState?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type CanvasHistoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvasHistory to aggregate.
     */
    where?: CanvasHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasHistories to fetch.
     */
    orderBy?: CanvasHistoryOrderByWithRelationInput | CanvasHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CanvasHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CanvasHistories
    **/
    _count?: true | CanvasHistoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CanvasHistoryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CanvasHistorySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CanvasHistoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CanvasHistoryMaxAggregateInputType
  }

  export type GetCanvasHistoryAggregateType<T extends CanvasHistoryAggregateArgs> = {
        [P in keyof T & keyof AggregateCanvasHistory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCanvasHistory[P]>
      : GetScalarType<T[P], AggregateCanvasHistory[P]>
  }




  export type CanvasHistoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CanvasHistoryWhereInput
    orderBy?: CanvasHistoryOrderByWithAggregationInput | CanvasHistoryOrderByWithAggregationInput[]
    by: CanvasHistoryScalarFieldEnum[] | CanvasHistoryScalarFieldEnum
    having?: CanvasHistoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CanvasHistoryCountAggregateInputType | true
    _avg?: CanvasHistoryAvgAggregateInputType
    _sum?: CanvasHistorySumAggregateInputType
    _min?: CanvasHistoryMinAggregateInputType
    _max?: CanvasHistoryMaxAggregateInputType
  }

  export type CanvasHistoryGroupByOutputType = {
    id: number
    canvasId: number
    action: string
    elementId: string | null
    oldState: JsonValue | null
    newState: JsonValue | null
    userId: number
    createdAt: Date
    _count: CanvasHistoryCountAggregateOutputType | null
    _avg: CanvasHistoryAvgAggregateOutputType | null
    _sum: CanvasHistorySumAggregateOutputType | null
    _min: CanvasHistoryMinAggregateOutputType | null
    _max: CanvasHistoryMaxAggregateOutputType | null
  }

  type GetCanvasHistoryGroupByPayload<T extends CanvasHistoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CanvasHistoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CanvasHistoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CanvasHistoryGroupByOutputType[P]>
            : GetScalarType<T[P], CanvasHistoryGroupByOutputType[P]>
        }
      >
    >


  export type CanvasHistorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    action?: boolean
    elementId?: boolean
    oldState?: boolean
    newState?: boolean
    userId?: boolean
    createdAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasHistory"]>

  export type CanvasHistorySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    action?: boolean
    elementId?: boolean
    oldState?: boolean
    newState?: boolean
    userId?: boolean
    createdAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasHistory"]>

  export type CanvasHistorySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    canvasId?: boolean
    action?: boolean
    elementId?: boolean
    oldState?: boolean
    newState?: boolean
    userId?: boolean
    createdAt?: boolean
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["canvasHistory"]>

  export type CanvasHistorySelectScalar = {
    id?: boolean
    canvasId?: boolean
    action?: boolean
    elementId?: boolean
    oldState?: boolean
    newState?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type CanvasHistoryOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "canvasId" | "action" | "elementId" | "oldState" | "newState" | "userId" | "createdAt", ExtArgs["result"]["canvasHistory"]>
  export type CanvasHistoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CanvasHistoryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type CanvasHistoryIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    canvas?: boolean | CanvasDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $CanvasHistoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CanvasHistory"
    objects: {
      canvas: Prisma.$CanvasPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      canvasId: number
      action: string
      elementId: string | null
      oldState: Prisma.JsonValue | null
      newState: Prisma.JsonValue | null
      userId: number
      createdAt: Date
    }, ExtArgs["result"]["canvasHistory"]>
    composites: {}
  }

  type CanvasHistoryGetPayload<S extends boolean | null | undefined | CanvasHistoryDefaultArgs> = $Result.GetResult<Prisma.$CanvasHistoryPayload, S>

  type CanvasHistoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CanvasHistoryFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CanvasHistoryCountAggregateInputType | true
    }

  export interface CanvasHistoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CanvasHistory'], meta: { name: 'CanvasHistory' } }
    /**
     * Find zero or one CanvasHistory that matches the filter.
     * @param {CanvasHistoryFindUniqueArgs} args - Arguments to find a CanvasHistory
     * @example
     * // Get one CanvasHistory
     * const canvasHistory = await prisma.canvasHistory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CanvasHistoryFindUniqueArgs>(args: SelectSubset<T, CanvasHistoryFindUniqueArgs<ExtArgs>>): Prisma__CanvasHistoryClient<$Result.GetResult<Prisma.$CanvasHistoryPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CanvasHistory that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CanvasHistoryFindUniqueOrThrowArgs} args - Arguments to find a CanvasHistory
     * @example
     * // Get one CanvasHistory
     * const canvasHistory = await prisma.canvasHistory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CanvasHistoryFindUniqueOrThrowArgs>(args: SelectSubset<T, CanvasHistoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CanvasHistoryClient<$Result.GetResult<Prisma.$CanvasHistoryPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CanvasHistory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasHistoryFindFirstArgs} args - Arguments to find a CanvasHistory
     * @example
     * // Get one CanvasHistory
     * const canvasHistory = await prisma.canvasHistory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CanvasHistoryFindFirstArgs>(args?: SelectSubset<T, CanvasHistoryFindFirstArgs<ExtArgs>>): Prisma__CanvasHistoryClient<$Result.GetResult<Prisma.$CanvasHistoryPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CanvasHistory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasHistoryFindFirstOrThrowArgs} args - Arguments to find a CanvasHistory
     * @example
     * // Get one CanvasHistory
     * const canvasHistory = await prisma.canvasHistory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CanvasHistoryFindFirstOrThrowArgs>(args?: SelectSubset<T, CanvasHistoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__CanvasHistoryClient<$Result.GetResult<Prisma.$CanvasHistoryPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CanvasHistories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasHistoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CanvasHistories
     * const canvasHistories = await prisma.canvasHistory.findMany()
     * 
     * // Get first 10 CanvasHistories
     * const canvasHistories = await prisma.canvasHistory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const canvasHistoryWithIdOnly = await prisma.canvasHistory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CanvasHistoryFindManyArgs>(args?: SelectSubset<T, CanvasHistoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasHistoryPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CanvasHistory.
     * @param {CanvasHistoryCreateArgs} args - Arguments to create a CanvasHistory.
     * @example
     * // Create one CanvasHistory
     * const CanvasHistory = await prisma.canvasHistory.create({
     *   data: {
     *     // ... data to create a CanvasHistory
     *   }
     * })
     * 
     */
    create<T extends CanvasHistoryCreateArgs>(args: SelectSubset<T, CanvasHistoryCreateArgs<ExtArgs>>): Prisma__CanvasHistoryClient<$Result.GetResult<Prisma.$CanvasHistoryPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CanvasHistories.
     * @param {CanvasHistoryCreateManyArgs} args - Arguments to create many CanvasHistories.
     * @example
     * // Create many CanvasHistories
     * const canvasHistory = await prisma.canvasHistory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CanvasHistoryCreateManyArgs>(args?: SelectSubset<T, CanvasHistoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CanvasHistories and returns the data saved in the database.
     * @param {CanvasHistoryCreateManyAndReturnArgs} args - Arguments to create many CanvasHistories.
     * @example
     * // Create many CanvasHistories
     * const canvasHistory = await prisma.canvasHistory.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CanvasHistories and only return the `id`
     * const canvasHistoryWithIdOnly = await prisma.canvasHistory.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CanvasHistoryCreateManyAndReturnArgs>(args?: SelectSubset<T, CanvasHistoryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasHistoryPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CanvasHistory.
     * @param {CanvasHistoryDeleteArgs} args - Arguments to delete one CanvasHistory.
     * @example
     * // Delete one CanvasHistory
     * const CanvasHistory = await prisma.canvasHistory.delete({
     *   where: {
     *     // ... filter to delete one CanvasHistory
     *   }
     * })
     * 
     */
    delete<T extends CanvasHistoryDeleteArgs>(args: SelectSubset<T, CanvasHistoryDeleteArgs<ExtArgs>>): Prisma__CanvasHistoryClient<$Result.GetResult<Prisma.$CanvasHistoryPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CanvasHistory.
     * @param {CanvasHistoryUpdateArgs} args - Arguments to update one CanvasHistory.
     * @example
     * // Update one CanvasHistory
     * const canvasHistory = await prisma.canvasHistory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CanvasHistoryUpdateArgs>(args: SelectSubset<T, CanvasHistoryUpdateArgs<ExtArgs>>): Prisma__CanvasHistoryClient<$Result.GetResult<Prisma.$CanvasHistoryPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CanvasHistories.
     * @param {CanvasHistoryDeleteManyArgs} args - Arguments to filter CanvasHistories to delete.
     * @example
     * // Delete a few CanvasHistories
     * const { count } = await prisma.canvasHistory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CanvasHistoryDeleteManyArgs>(args?: SelectSubset<T, CanvasHistoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvasHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasHistoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CanvasHistories
     * const canvasHistory = await prisma.canvasHistory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CanvasHistoryUpdateManyArgs>(args: SelectSubset<T, CanvasHistoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CanvasHistories and returns the data updated in the database.
     * @param {CanvasHistoryUpdateManyAndReturnArgs} args - Arguments to update many CanvasHistories.
     * @example
     * // Update many CanvasHistories
     * const canvasHistory = await prisma.canvasHistory.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CanvasHistories and only return the `id`
     * const canvasHistoryWithIdOnly = await prisma.canvasHistory.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CanvasHistoryUpdateManyAndReturnArgs>(args: SelectSubset<T, CanvasHistoryUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CanvasHistoryPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CanvasHistory.
     * @param {CanvasHistoryUpsertArgs} args - Arguments to update or create a CanvasHistory.
     * @example
     * // Update or create a CanvasHistory
     * const canvasHistory = await prisma.canvasHistory.upsert({
     *   create: {
     *     // ... data to create a CanvasHistory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CanvasHistory we want to update
     *   }
     * })
     */
    upsert<T extends CanvasHistoryUpsertArgs>(args: SelectSubset<T, CanvasHistoryUpsertArgs<ExtArgs>>): Prisma__CanvasHistoryClient<$Result.GetResult<Prisma.$CanvasHistoryPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CanvasHistories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasHistoryCountArgs} args - Arguments to filter CanvasHistories to count.
     * @example
     * // Count the number of CanvasHistories
     * const count = await prisma.canvasHistory.count({
     *   where: {
     *     // ... the filter for the CanvasHistories we want to count
     *   }
     * })
    **/
    count<T extends CanvasHistoryCountArgs>(
      args?: Subset<T, CanvasHistoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CanvasHistoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CanvasHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasHistoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CanvasHistoryAggregateArgs>(args: Subset<T, CanvasHistoryAggregateArgs>): Prisma.PrismaPromise<GetCanvasHistoryAggregateType<T>>

    /**
     * Group by CanvasHistory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CanvasHistoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CanvasHistoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CanvasHistoryGroupByArgs['orderBy'] }
        : { orderBy?: CanvasHistoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CanvasHistoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCanvasHistoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CanvasHistory model
   */
  readonly fields: CanvasHistoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CanvasHistory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CanvasHistoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    canvas<T extends CanvasDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CanvasDefaultArgs<ExtArgs>>): Prisma__CanvasClient<$Result.GetResult<Prisma.$CanvasPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CanvasHistory model
   */
  interface CanvasHistoryFieldRefs {
    readonly id: FieldRef<"CanvasHistory", 'Int'>
    readonly canvasId: FieldRef<"CanvasHistory", 'Int'>
    readonly action: FieldRef<"CanvasHistory", 'String'>
    readonly elementId: FieldRef<"CanvasHistory", 'String'>
    readonly oldState: FieldRef<"CanvasHistory", 'Json'>
    readonly newState: FieldRef<"CanvasHistory", 'Json'>
    readonly userId: FieldRef<"CanvasHistory", 'Int'>
    readonly createdAt: FieldRef<"CanvasHistory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CanvasHistory findUnique
   */
  export type CanvasHistoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasHistory
     */
    select?: CanvasHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasHistory
     */
    omit?: CanvasHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CanvasHistory to fetch.
     */
    where: CanvasHistoryWhereUniqueInput
  }

  /**
   * CanvasHistory findUniqueOrThrow
   */
  export type CanvasHistoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasHistory
     */
    select?: CanvasHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasHistory
     */
    omit?: CanvasHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CanvasHistory to fetch.
     */
    where: CanvasHistoryWhereUniqueInput
  }

  /**
   * CanvasHistory findFirst
   */
  export type CanvasHistoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasHistory
     */
    select?: CanvasHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasHistory
     */
    omit?: CanvasHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CanvasHistory to fetch.
     */
    where?: CanvasHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasHistories to fetch.
     */
    orderBy?: CanvasHistoryOrderByWithRelationInput | CanvasHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvasHistories.
     */
    cursor?: CanvasHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvasHistories.
     */
    distinct?: CanvasHistoryScalarFieldEnum | CanvasHistoryScalarFieldEnum[]
  }

  /**
   * CanvasHistory findFirstOrThrow
   */
  export type CanvasHistoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasHistory
     */
    select?: CanvasHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasHistory
     */
    omit?: CanvasHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CanvasHistory to fetch.
     */
    where?: CanvasHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasHistories to fetch.
     */
    orderBy?: CanvasHistoryOrderByWithRelationInput | CanvasHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CanvasHistories.
     */
    cursor?: CanvasHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasHistories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CanvasHistories.
     */
    distinct?: CanvasHistoryScalarFieldEnum | CanvasHistoryScalarFieldEnum[]
  }

  /**
   * CanvasHistory findMany
   */
  export type CanvasHistoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasHistory
     */
    select?: CanvasHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasHistory
     */
    omit?: CanvasHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasHistoryInclude<ExtArgs> | null
    /**
     * Filter, which CanvasHistories to fetch.
     */
    where?: CanvasHistoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CanvasHistories to fetch.
     */
    orderBy?: CanvasHistoryOrderByWithRelationInput | CanvasHistoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CanvasHistories.
     */
    cursor?: CanvasHistoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CanvasHistories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CanvasHistories.
     */
    skip?: number
    distinct?: CanvasHistoryScalarFieldEnum | CanvasHistoryScalarFieldEnum[]
  }

  /**
   * CanvasHistory create
   */
  export type CanvasHistoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasHistory
     */
    select?: CanvasHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasHistory
     */
    omit?: CanvasHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasHistoryInclude<ExtArgs> | null
    /**
     * The data needed to create a CanvasHistory.
     */
    data: XOR<CanvasHistoryCreateInput, CanvasHistoryUncheckedCreateInput>
  }

  /**
   * CanvasHistory createMany
   */
  export type CanvasHistoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CanvasHistories.
     */
    data: CanvasHistoryCreateManyInput | CanvasHistoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CanvasHistory createManyAndReturn
   */
  export type CanvasHistoryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasHistory
     */
    select?: CanvasHistorySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasHistory
     */
    omit?: CanvasHistoryOmit<ExtArgs> | null
    /**
     * The data used to create many CanvasHistories.
     */
    data: CanvasHistoryCreateManyInput | CanvasHistoryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasHistoryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CanvasHistory update
   */
  export type CanvasHistoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasHistory
     */
    select?: CanvasHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasHistory
     */
    omit?: CanvasHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasHistoryInclude<ExtArgs> | null
    /**
     * The data needed to update a CanvasHistory.
     */
    data: XOR<CanvasHistoryUpdateInput, CanvasHistoryUncheckedUpdateInput>
    /**
     * Choose, which CanvasHistory to update.
     */
    where: CanvasHistoryWhereUniqueInput
  }

  /**
   * CanvasHistory updateMany
   */
  export type CanvasHistoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CanvasHistories.
     */
    data: XOR<CanvasHistoryUpdateManyMutationInput, CanvasHistoryUncheckedUpdateManyInput>
    /**
     * Filter which CanvasHistories to update
     */
    where?: CanvasHistoryWhereInput
    /**
     * Limit how many CanvasHistories to update.
     */
    limit?: number
  }

  /**
   * CanvasHistory updateManyAndReturn
   */
  export type CanvasHistoryUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasHistory
     */
    select?: CanvasHistorySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasHistory
     */
    omit?: CanvasHistoryOmit<ExtArgs> | null
    /**
     * The data used to update CanvasHistories.
     */
    data: XOR<CanvasHistoryUpdateManyMutationInput, CanvasHistoryUncheckedUpdateManyInput>
    /**
     * Filter which CanvasHistories to update
     */
    where?: CanvasHistoryWhereInput
    /**
     * Limit how many CanvasHistories to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasHistoryIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * CanvasHistory upsert
   */
  export type CanvasHistoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasHistory
     */
    select?: CanvasHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasHistory
     */
    omit?: CanvasHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasHistoryInclude<ExtArgs> | null
    /**
     * The filter to search for the CanvasHistory to update in case it exists.
     */
    where: CanvasHistoryWhereUniqueInput
    /**
     * In case the CanvasHistory found by the `where` argument doesn't exist, create a new CanvasHistory with this data.
     */
    create: XOR<CanvasHistoryCreateInput, CanvasHistoryUncheckedCreateInput>
    /**
     * In case the CanvasHistory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CanvasHistoryUpdateInput, CanvasHistoryUncheckedUpdateInput>
  }

  /**
   * CanvasHistory delete
   */
  export type CanvasHistoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasHistory
     */
    select?: CanvasHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasHistory
     */
    omit?: CanvasHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasHistoryInclude<ExtArgs> | null
    /**
     * Filter which CanvasHistory to delete.
     */
    where: CanvasHistoryWhereUniqueInput
  }

  /**
   * CanvasHistory deleteMany
   */
  export type CanvasHistoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CanvasHistories to delete
     */
    where?: CanvasHistoryWhereInput
    /**
     * Limit how many CanvasHistories to delete.
     */
    limit?: number
  }

  /**
   * CanvasHistory without action
   */
  export type CanvasHistoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CanvasHistory
     */
    select?: CanvasHistorySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CanvasHistory
     */
    omit?: CanvasHistoryOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CanvasHistoryInclude<ExtArgs> | null
  }


  /**
   * Model MediaFile
   */

  export type AggregateMediaFile = {
    _count: MediaFileCountAggregateOutputType | null
    _avg: MediaFileAvgAggregateOutputType | null
    _sum: MediaFileSumAggregateOutputType | null
    _min: MediaFileMinAggregateOutputType | null
    _max: MediaFileMaxAggregateOutputType | null
  }

  export type MediaFileAvgAggregateOutputType = {
    id: number | null
    size: number | null
    userId: number | null
    appId: number | null
  }

  export type MediaFileSumAggregateOutputType = {
    id: number | null
    size: number | null
    userId: number | null
    appId: number | null
  }

  export type MediaFileMinAggregateOutputType = {
    id: number | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    thumbnail: string | null
    userId: number | null
    appId: number | null
    createdAt: Date | null
  }

  export type MediaFileMaxAggregateOutputType = {
    id: number | null
    filename: string | null
    originalName: string | null
    mimeType: string | null
    size: number | null
    url: string | null
    thumbnail: string | null
    userId: number | null
    appId: number | null
    createdAt: Date | null
  }

  export type MediaFileCountAggregateOutputType = {
    id: number
    filename: number
    originalName: number
    mimeType: number
    size: number
    url: number
    thumbnail: number
    userId: number
    appId: number
    metadata: number
    createdAt: number
    _all: number
  }


  export type MediaFileAvgAggregateInputType = {
    id?: true
    size?: true
    userId?: true
    appId?: true
  }

  export type MediaFileSumAggregateInputType = {
    id?: true
    size?: true
    userId?: true
    appId?: true
  }

  export type MediaFileMinAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    thumbnail?: true
    userId?: true
    appId?: true
    createdAt?: true
  }

  export type MediaFileMaxAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    thumbnail?: true
    userId?: true
    appId?: true
    createdAt?: true
  }

  export type MediaFileCountAggregateInputType = {
    id?: true
    filename?: true
    originalName?: true
    mimeType?: true
    size?: true
    url?: true
    thumbnail?: true
    userId?: true
    appId?: true
    metadata?: true
    createdAt?: true
    _all?: true
  }

  export type MediaFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaFile to aggregate.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MediaFiles
    **/
    _count?: true | MediaFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MediaFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MediaFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MediaFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MediaFileMaxAggregateInputType
  }

  export type GetMediaFileAggregateType<T extends MediaFileAggregateArgs> = {
        [P in keyof T & keyof AggregateMediaFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMediaFile[P]>
      : GetScalarType<T[P], AggregateMediaFile[P]>
  }




  export type MediaFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MediaFileWhereInput
    orderBy?: MediaFileOrderByWithAggregationInput | MediaFileOrderByWithAggregationInput[]
    by: MediaFileScalarFieldEnum[] | MediaFileScalarFieldEnum
    having?: MediaFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MediaFileCountAggregateInputType | true
    _avg?: MediaFileAvgAggregateInputType
    _sum?: MediaFileSumAggregateInputType
    _min?: MediaFileMinAggregateInputType
    _max?: MediaFileMaxAggregateInputType
  }

  export type MediaFileGroupByOutputType = {
    id: number
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    thumbnail: string | null
    userId: number
    appId: number | null
    metadata: JsonValue
    createdAt: Date
    _count: MediaFileCountAggregateOutputType | null
    _avg: MediaFileAvgAggregateOutputType | null
    _sum: MediaFileSumAggregateOutputType | null
    _min: MediaFileMinAggregateOutputType | null
    _max: MediaFileMaxAggregateOutputType | null
  }

  type GetMediaFileGroupByPayload<T extends MediaFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MediaFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MediaFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MediaFileGroupByOutputType[P]>
            : GetScalarType<T[P], MediaFileGroupByOutputType[P]>
        }
      >
    >


  export type MediaFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    thumbnail?: boolean
    userId?: boolean
    appId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    app?: boolean | MediaFile$appArgs<ExtArgs>
  }, ExtArgs["result"]["mediaFile"]>

  export type MediaFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    thumbnail?: boolean
    userId?: boolean
    appId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    app?: boolean | MediaFile$appArgs<ExtArgs>
  }, ExtArgs["result"]["mediaFile"]>

  export type MediaFileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    thumbnail?: boolean
    userId?: boolean
    appId?: boolean
    metadata?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    app?: boolean | MediaFile$appArgs<ExtArgs>
  }, ExtArgs["result"]["mediaFile"]>

  export type MediaFileSelectScalar = {
    id?: boolean
    filename?: boolean
    originalName?: boolean
    mimeType?: boolean
    size?: boolean
    url?: boolean
    thumbnail?: boolean
    userId?: boolean
    appId?: boolean
    metadata?: boolean
    createdAt?: boolean
  }

  export type MediaFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "filename" | "originalName" | "mimeType" | "size" | "url" | "thumbnail" | "userId" | "appId" | "metadata" | "createdAt", ExtArgs["result"]["mediaFile"]>
  export type MediaFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    app?: boolean | MediaFile$appArgs<ExtArgs>
  }
  export type MediaFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    app?: boolean | MediaFile$appArgs<ExtArgs>
  }
  export type MediaFileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    app?: boolean | MediaFile$appArgs<ExtArgs>
  }

  export type $MediaFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MediaFile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      app: Prisma.$AppPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      filename: string
      originalName: string
      mimeType: string
      size: number
      url: string
      thumbnail: string | null
      userId: number
      appId: number | null
      metadata: Prisma.JsonValue
      createdAt: Date
    }, ExtArgs["result"]["mediaFile"]>
    composites: {}
  }

  type MediaFileGetPayload<S extends boolean | null | undefined | MediaFileDefaultArgs> = $Result.GetResult<Prisma.$MediaFilePayload, S>

  type MediaFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MediaFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MediaFileCountAggregateInputType | true
    }

  export interface MediaFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MediaFile'], meta: { name: 'MediaFile' } }
    /**
     * Find zero or one MediaFile that matches the filter.
     * @param {MediaFileFindUniqueArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MediaFileFindUniqueArgs>(args: SelectSubset<T, MediaFileFindUniqueArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MediaFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MediaFileFindUniqueOrThrowArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MediaFileFindUniqueOrThrowArgs>(args: SelectSubset<T, MediaFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileFindFirstArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MediaFileFindFirstArgs>(args?: SelectSubset<T, MediaFileFindFirstArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MediaFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileFindFirstOrThrowArgs} args - Arguments to find a MediaFile
     * @example
     * // Get one MediaFile
     * const mediaFile = await prisma.mediaFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MediaFileFindFirstOrThrowArgs>(args?: SelectSubset<T, MediaFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MediaFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MediaFiles
     * const mediaFiles = await prisma.mediaFile.findMany()
     * 
     * // Get first 10 MediaFiles
     * const mediaFiles = await prisma.mediaFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const mediaFileWithIdOnly = await prisma.mediaFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MediaFileFindManyArgs>(args?: SelectSubset<T, MediaFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MediaFile.
     * @param {MediaFileCreateArgs} args - Arguments to create a MediaFile.
     * @example
     * // Create one MediaFile
     * const MediaFile = await prisma.mediaFile.create({
     *   data: {
     *     // ... data to create a MediaFile
     *   }
     * })
     * 
     */
    create<T extends MediaFileCreateArgs>(args: SelectSubset<T, MediaFileCreateArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MediaFiles.
     * @param {MediaFileCreateManyArgs} args - Arguments to create many MediaFiles.
     * @example
     * // Create many MediaFiles
     * const mediaFile = await prisma.mediaFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MediaFileCreateManyArgs>(args?: SelectSubset<T, MediaFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MediaFiles and returns the data saved in the database.
     * @param {MediaFileCreateManyAndReturnArgs} args - Arguments to create many MediaFiles.
     * @example
     * // Create many MediaFiles
     * const mediaFile = await prisma.mediaFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MediaFiles and only return the `id`
     * const mediaFileWithIdOnly = await prisma.mediaFile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MediaFileCreateManyAndReturnArgs>(args?: SelectSubset<T, MediaFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MediaFile.
     * @param {MediaFileDeleteArgs} args - Arguments to delete one MediaFile.
     * @example
     * // Delete one MediaFile
     * const MediaFile = await prisma.mediaFile.delete({
     *   where: {
     *     // ... filter to delete one MediaFile
     *   }
     * })
     * 
     */
    delete<T extends MediaFileDeleteArgs>(args: SelectSubset<T, MediaFileDeleteArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MediaFile.
     * @param {MediaFileUpdateArgs} args - Arguments to update one MediaFile.
     * @example
     * // Update one MediaFile
     * const mediaFile = await prisma.mediaFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MediaFileUpdateArgs>(args: SelectSubset<T, MediaFileUpdateArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MediaFiles.
     * @param {MediaFileDeleteManyArgs} args - Arguments to filter MediaFiles to delete.
     * @example
     * // Delete a few MediaFiles
     * const { count } = await prisma.mediaFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MediaFileDeleteManyArgs>(args?: SelectSubset<T, MediaFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MediaFiles
     * const mediaFile = await prisma.mediaFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MediaFileUpdateManyArgs>(args: SelectSubset<T, MediaFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MediaFiles and returns the data updated in the database.
     * @param {MediaFileUpdateManyAndReturnArgs} args - Arguments to update many MediaFiles.
     * @example
     * // Update many MediaFiles
     * const mediaFile = await prisma.mediaFile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MediaFiles and only return the `id`
     * const mediaFileWithIdOnly = await prisma.mediaFile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MediaFileUpdateManyAndReturnArgs>(args: SelectSubset<T, MediaFileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MediaFile.
     * @param {MediaFileUpsertArgs} args - Arguments to update or create a MediaFile.
     * @example
     * // Update or create a MediaFile
     * const mediaFile = await prisma.mediaFile.upsert({
     *   create: {
     *     // ... data to create a MediaFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MediaFile we want to update
     *   }
     * })
     */
    upsert<T extends MediaFileUpsertArgs>(args: SelectSubset<T, MediaFileUpsertArgs<ExtArgs>>): Prisma__MediaFileClient<$Result.GetResult<Prisma.$MediaFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MediaFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileCountArgs} args - Arguments to filter MediaFiles to count.
     * @example
     * // Count the number of MediaFiles
     * const count = await prisma.mediaFile.count({
     *   where: {
     *     // ... the filter for the MediaFiles we want to count
     *   }
     * })
    **/
    count<T extends MediaFileCountArgs>(
      args?: Subset<T, MediaFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MediaFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MediaFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MediaFileAggregateArgs>(args: Subset<T, MediaFileAggregateArgs>): Prisma.PrismaPromise<GetMediaFileAggregateType<T>>

    /**
     * Group by MediaFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MediaFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MediaFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MediaFileGroupByArgs['orderBy'] }
        : { orderBy?: MediaFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MediaFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMediaFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MediaFile model
   */
  readonly fields: MediaFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MediaFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MediaFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    app<T extends MediaFile$appArgs<ExtArgs> = {}>(args?: Subset<T, MediaFile$appArgs<ExtArgs>>): Prisma__AppClient<$Result.GetResult<Prisma.$AppPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MediaFile model
   */
  interface MediaFileFieldRefs {
    readonly id: FieldRef<"MediaFile", 'Int'>
    readonly filename: FieldRef<"MediaFile", 'String'>
    readonly originalName: FieldRef<"MediaFile", 'String'>
    readonly mimeType: FieldRef<"MediaFile", 'String'>
    readonly size: FieldRef<"MediaFile", 'Int'>
    readonly url: FieldRef<"MediaFile", 'String'>
    readonly thumbnail: FieldRef<"MediaFile", 'String'>
    readonly userId: FieldRef<"MediaFile", 'Int'>
    readonly appId: FieldRef<"MediaFile", 'Int'>
    readonly metadata: FieldRef<"MediaFile", 'Json'>
    readonly createdAt: FieldRef<"MediaFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MediaFile findUnique
   */
  export type MediaFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile findUniqueOrThrow
   */
  export type MediaFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile findFirst
   */
  export type MediaFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaFiles.
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaFiles.
     */
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * MediaFile findFirstOrThrow
   */
  export type MediaFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFile to fetch.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MediaFiles.
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MediaFiles.
     */
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * MediaFile findMany
   */
  export type MediaFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter, which MediaFiles to fetch.
     */
    where?: MediaFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MediaFiles to fetch.
     */
    orderBy?: MediaFileOrderByWithRelationInput | MediaFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MediaFiles.
     */
    cursor?: MediaFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MediaFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MediaFiles.
     */
    skip?: number
    distinct?: MediaFileScalarFieldEnum | MediaFileScalarFieldEnum[]
  }

  /**
   * MediaFile create
   */
  export type MediaFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * The data needed to create a MediaFile.
     */
    data: XOR<MediaFileCreateInput, MediaFileUncheckedCreateInput>
  }

  /**
   * MediaFile createMany
   */
  export type MediaFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MediaFiles.
     */
    data: MediaFileCreateManyInput | MediaFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MediaFile createManyAndReturn
   */
  export type MediaFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * The data used to create many MediaFiles.
     */
    data: MediaFileCreateManyInput | MediaFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaFile update
   */
  export type MediaFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * The data needed to update a MediaFile.
     */
    data: XOR<MediaFileUpdateInput, MediaFileUncheckedUpdateInput>
    /**
     * Choose, which MediaFile to update.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile updateMany
   */
  export type MediaFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MediaFiles.
     */
    data: XOR<MediaFileUpdateManyMutationInput, MediaFileUncheckedUpdateManyInput>
    /**
     * Filter which MediaFiles to update
     */
    where?: MediaFileWhereInput
    /**
     * Limit how many MediaFiles to update.
     */
    limit?: number
  }

  /**
   * MediaFile updateManyAndReturn
   */
  export type MediaFileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * The data used to update MediaFiles.
     */
    data: XOR<MediaFileUpdateManyMutationInput, MediaFileUncheckedUpdateManyInput>
    /**
     * Filter which MediaFiles to update
     */
    where?: MediaFileWhereInput
    /**
     * Limit how many MediaFiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MediaFile upsert
   */
  export type MediaFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * The filter to search for the MediaFile to update in case it exists.
     */
    where: MediaFileWhereUniqueInput
    /**
     * In case the MediaFile found by the `where` argument doesn't exist, create a new MediaFile with this data.
     */
    create: XOR<MediaFileCreateInput, MediaFileUncheckedCreateInput>
    /**
     * In case the MediaFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MediaFileUpdateInput, MediaFileUncheckedUpdateInput>
  }

  /**
   * MediaFile delete
   */
  export type MediaFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
    /**
     * Filter which MediaFile to delete.
     */
    where: MediaFileWhereUniqueInput
  }

  /**
   * MediaFile deleteMany
   */
  export type MediaFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MediaFiles to delete
     */
    where?: MediaFileWhereInput
    /**
     * Limit how many MediaFiles to delete.
     */
    limit?: number
  }

  /**
   * MediaFile.app
   */
  export type MediaFile$appArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the App
     */
    select?: AppSelect<ExtArgs> | null
    /**
     * Omit specific fields from the App
     */
    omit?: AppOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AppInclude<ExtArgs> | null
    where?: AppWhereInput
  }

  /**
   * MediaFile without action
   */
  export type MediaFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MediaFile
     */
    select?: MediaFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MediaFile
     */
    omit?: MediaFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MediaFileInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    createdAt: 'createdAt',
    role: 'role',
    updatedAt: 'updatedAt',
    verified: 'verified'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AppScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    status: 'status',
    archived: 'archived',
    ownerId: 'ownerId',
    templateId: 'templateId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AppScalarFieldEnum = (typeof AppScalarFieldEnum)[keyof typeof AppScalarFieldEnum]


  export const TemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    preview_image: 'preview_image',
    app_schema: 'app_schema',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TemplateScalarFieldEnum = (typeof TemplateScalarFieldEnum)[keyof typeof TemplateScalarFieldEnum]


  export const ComponentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    type: 'type',
    appId: 'appId',
    properties: 'properties'
  };

  export type ComponentScalarFieldEnum = (typeof ComponentScalarFieldEnum)[keyof typeof ComponentScalarFieldEnum]


  export const WorkflowScalarFieldEnum: {
    id: 'id',
    name: 'name',
    appId: 'appId',
    steps: 'steps'
  };

  export type WorkflowScalarFieldEnum = (typeof WorkflowScalarFieldEnum)[keyof typeof WorkflowScalarFieldEnum]


  export const OtpScalarFieldEnum: {
    id: 'id',
    email: 'email',
    otp: 'otp',
    type: 'type',
    expiresAt: 'expiresAt',
    used: 'used',
    createdAt: 'createdAt'
  };

  export type OtpScalarFieldEnum = (typeof OtpScalarFieldEnum)[keyof typeof OtpScalarFieldEnum]


  export const AppSchemaScalarFieldEnum: {
    id: 'id',
    appId: 'appId',
    name: 'name',
    createdAt: 'createdAt'
  };

  export type AppSchemaScalarFieldEnum = (typeof AppSchemaScalarFieldEnum)[keyof typeof AppSchemaScalarFieldEnum]


  export const AppFieldScalarFieldEnum: {
    id: 'id',
    schemaId: 'schemaId',
    name: 'name',
    type: 'type',
    constraints: 'constraints',
    relatedSchemaId: 'relatedSchemaId',
    createdAt: 'createdAt'
  };

  export type AppFieldScalarFieldEnum = (typeof AppFieldScalarFieldEnum)[keyof typeof AppFieldScalarFieldEnum]


  export const AppDataScalarFieldEnum: {
    id: 'id',
    schemaId: 'schemaId',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type AppDataScalarFieldEnum = (typeof AppDataScalarFieldEnum)[keyof typeof AppDataScalarFieldEnum]


  export const VideoScalarFieldEnum: {
    id: 'id',
    title: 'title',
    url: 'url',
    category: 'category',
    createdAt: 'createdAt'
  };

  export type VideoScalarFieldEnum = (typeof VideoScalarFieldEnum)[keyof typeof VideoScalarFieldEnum]


  export const AppMetricScalarFieldEnum: {
    id: 'id',
    appId: 'appId',
    activeDays: 'activeDays',
    downtime: 'downtime',
    totalUsers: 'totalUsers',
    traffic: 'traffic',
    createdAt: 'createdAt'
  };

  export type AppMetricScalarFieldEnum = (typeof AppMetricScalarFieldEnum)[keyof typeof AppMetricScalarFieldEnum]


  export const AppIssueScalarFieldEnum: {
    id: 'id',
    appId: 'appId',
    severity: 'severity',
    description: 'description',
    status: 'status',
    createdAt: 'createdAt'
  };

  export type AppIssueScalarFieldEnum = (typeof AppIssueScalarFieldEnum)[keyof typeof AppIssueScalarFieldEnum]


  export const AppWarningScalarFieldEnum: {
    id: 'id',
    appId: 'appId',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type AppWarningScalarFieldEnum = (typeof AppWarningScalarFieldEnum)[keyof typeof AppWarningScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    message: 'message',
    read: 'read',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const BlacklistedTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    createdAt: 'createdAt',
    expiresAt: 'expiresAt'
  };

  export type BlacklistedTokenScalarFieldEnum = (typeof BlacklistedTokenScalarFieldEnum)[keyof typeof BlacklistedTokenScalarFieldEnum]


  export const CanvasScalarFieldEnum: {
    id: 'id',
    appId: 'appId',
    name: 'name',
    description: 'description',
    width: 'width',
    height: 'height',
    background: 'background',
    gridEnabled: 'gridEnabled',
    snapEnabled: 'snapEnabled',
    zoomLevel: 'zoomLevel',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CanvasScalarFieldEnum = (typeof CanvasScalarFieldEnum)[keyof typeof CanvasScalarFieldEnum]


  export const CanvasElementScalarFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    elementId: 'elementId',
    type: 'type',
    name: 'name',
    x: 'x',
    y: 'y',
    width: 'width',
    height: 'height',
    rotation: 'rotation',
    zIndex: 'zIndex',
    locked: 'locked',
    visible: 'visible',
    groupId: 'groupId',
    parentId: 'parentId',
    properties: 'properties',
    styles: 'styles',
    constraints: 'constraints',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CanvasElementScalarFieldEnum = (typeof CanvasElementScalarFieldEnum)[keyof typeof CanvasElementScalarFieldEnum]


  export const ElementInteractionScalarFieldEnum: {
    id: 'id',
    elementId: 'elementId',
    event: 'event',
    action: 'action',
    createdAt: 'createdAt'
  };

  export type ElementInteractionScalarFieldEnum = (typeof ElementInteractionScalarFieldEnum)[keyof typeof ElementInteractionScalarFieldEnum]


  export const ElementValidationScalarFieldEnum: {
    id: 'id',
    elementId: 'elementId',
    rule: 'rule',
    value: 'value',
    message: 'message',
    createdAt: 'createdAt'
  };

  export type ElementValidationScalarFieldEnum = (typeof ElementValidationScalarFieldEnum)[keyof typeof ElementValidationScalarFieldEnum]


  export const CanvasHistoryScalarFieldEnum: {
    id: 'id',
    canvasId: 'canvasId',
    action: 'action',
    elementId: 'elementId',
    oldState: 'oldState',
    newState: 'newState',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type CanvasHistoryScalarFieldEnum = (typeof CanvasHistoryScalarFieldEnum)[keyof typeof CanvasHistoryScalarFieldEnum]


  export const MediaFileScalarFieldEnum: {
    id: 'id',
    filename: 'filename',
    originalName: 'originalName',
    mimeType: 'mimeType',
    size: 'size',
    url: 'url',
    thumbnail: 'thumbnail',
    userId: 'userId',
    appId: 'appId',
    metadata: 'metadata',
    createdAt: 'createdAt'
  };

  export type MediaFileScalarFieldEnum = (typeof MediaFileScalarFieldEnum)[keyof typeof MediaFileScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'AppStatus'
   */
  export type EnumAppStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppStatus'>
    


  /**
   * Reference to a field of type 'AppStatus[]'
   */
  export type ListEnumAppStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AppStatus[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'FieldType'
   */
  export type EnumFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FieldType'>
    


  /**
   * Reference to a field of type 'FieldType[]'
   */
  export type ListEnumFieldTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FieldType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'IssueSeverity'
   */
  export type EnumIssueSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueSeverity'>
    


  /**
   * Reference to a field of type 'IssueSeverity[]'
   */
  export type ListEnumIssueSeverityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueSeverity[]'>
    


  /**
   * Reference to a field of type 'IssueStatus'
   */
  export type EnumIssueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueStatus'>
    


  /**
   * Reference to a field of type 'IssueStatus[]'
   */
  export type ListEnumIssueStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'IssueStatus[]'>
    


  /**
   * Reference to a field of type 'ElementType'
   */
  export type EnumElementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ElementType'>
    


  /**
   * Reference to a field of type 'ElementType[]'
   */
  export type ListEnumElementTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ElementType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    role?: StringFilter<"User"> | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    verified?: BoolFilter<"User"> | boolean
    apps?: AppListRelationFilter
    notifications?: NotificationListRelationFilter
    canvasHistory?: CanvasHistoryListRelationFilter
    mediaFiles?: MediaFileListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    verified?: SortOrder
    apps?: AppOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    canvasHistory?: CanvasHistoryOrderByRelationAggregateInput
    mediaFiles?: MediaFileOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    createdAt?: DateTimeFilter<"User"> | Date | string
    role?: StringFilter<"User"> | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    verified?: BoolFilter<"User"> | boolean
    apps?: AppListRelationFilter
    notifications?: NotificationListRelationFilter
    canvasHistory?: CanvasHistoryListRelationFilter
    mediaFiles?: MediaFileListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    verified?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    role?: StringWithAggregatesFilter<"User"> | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    verified?: BoolWithAggregatesFilter<"User"> | boolean
  }

  export type AppWhereInput = {
    AND?: AppWhereInput | AppWhereInput[]
    OR?: AppWhereInput[]
    NOT?: AppWhereInput | AppWhereInput[]
    id?: IntFilter<"App"> | number
    name?: StringFilter<"App"> | string
    description?: StringNullableFilter<"App"> | string | null
    status?: EnumAppStatusFilter<"App"> | $Enums.AppStatus
    archived?: BoolFilter<"App"> | boolean
    ownerId?: IntFilter<"App"> | number
    templateId?: IntNullableFilter<"App"> | number | null
    createdAt?: DateTimeFilter<"App"> | Date | string
    updatedAt?: DateTimeFilter<"App"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<TemplateNullableScalarRelationFilter, TemplateWhereInput> | null
    components?: ComponentListRelationFilter
    workflows?: WorkflowListRelationFilter
    schemas?: AppSchemaListRelationFilter
    metrics?: AppMetricListRelationFilter
    issues?: AppIssueListRelationFilter
    warnings?: AppWarningListRelationFilter
    canvas?: XOR<CanvasNullableScalarRelationFilter, CanvasWhereInput> | null
    mediaFiles?: MediaFileListRelationFilter
  }

  export type AppOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    archived?: SortOrder
    ownerId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    template?: TemplateOrderByWithRelationInput
    components?: ComponentOrderByRelationAggregateInput
    workflows?: WorkflowOrderByRelationAggregateInput
    schemas?: AppSchemaOrderByRelationAggregateInput
    metrics?: AppMetricOrderByRelationAggregateInput
    issues?: AppIssueOrderByRelationAggregateInput
    warnings?: AppWarningOrderByRelationAggregateInput
    canvas?: CanvasOrderByWithRelationInput
    mediaFiles?: MediaFileOrderByRelationAggregateInput
  }

  export type AppWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AppWhereInput | AppWhereInput[]
    OR?: AppWhereInput[]
    NOT?: AppWhereInput | AppWhereInput[]
    name?: StringFilter<"App"> | string
    description?: StringNullableFilter<"App"> | string | null
    status?: EnumAppStatusFilter<"App"> | $Enums.AppStatus
    archived?: BoolFilter<"App"> | boolean
    ownerId?: IntFilter<"App"> | number
    templateId?: IntNullableFilter<"App"> | number | null
    createdAt?: DateTimeFilter<"App"> | Date | string
    updatedAt?: DateTimeFilter<"App"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    template?: XOR<TemplateNullableScalarRelationFilter, TemplateWhereInput> | null
    components?: ComponentListRelationFilter
    workflows?: WorkflowListRelationFilter
    schemas?: AppSchemaListRelationFilter
    metrics?: AppMetricListRelationFilter
    issues?: AppIssueListRelationFilter
    warnings?: AppWarningListRelationFilter
    canvas?: XOR<CanvasNullableScalarRelationFilter, CanvasWhereInput> | null
    mediaFiles?: MediaFileListRelationFilter
  }, "id">

  export type AppOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    status?: SortOrder
    archived?: SortOrder
    ownerId?: SortOrder
    templateId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AppCountOrderByAggregateInput
    _avg?: AppAvgOrderByAggregateInput
    _max?: AppMaxOrderByAggregateInput
    _min?: AppMinOrderByAggregateInput
    _sum?: AppSumOrderByAggregateInput
  }

  export type AppScalarWhereWithAggregatesInput = {
    AND?: AppScalarWhereWithAggregatesInput | AppScalarWhereWithAggregatesInput[]
    OR?: AppScalarWhereWithAggregatesInput[]
    NOT?: AppScalarWhereWithAggregatesInput | AppScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"App"> | number
    name?: StringWithAggregatesFilter<"App"> | string
    description?: StringNullableWithAggregatesFilter<"App"> | string | null
    status?: EnumAppStatusWithAggregatesFilter<"App"> | $Enums.AppStatus
    archived?: BoolWithAggregatesFilter<"App"> | boolean
    ownerId?: IntWithAggregatesFilter<"App"> | number
    templateId?: IntNullableWithAggregatesFilter<"App"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"App"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"App"> | Date | string
  }

  export type TemplateWhereInput = {
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    id?: IntFilter<"Template"> | number
    name?: StringFilter<"Template"> | string
    description?: StringFilter<"Template"> | string
    preview_image?: StringNullableFilter<"Template"> | string | null
    app_schema?: JsonFilter<"Template">
    category?: StringFilter<"Template"> | string
    createdAt?: DateTimeFilter<"Template"> | Date | string
    updatedAt?: DateTimeFilter<"Template"> | Date | string
    apps?: AppListRelationFilter
  }

  export type TemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    preview_image?: SortOrderInput | SortOrder
    app_schema?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    apps?: AppOrderByRelationAggregateInput
  }

  export type TemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: TemplateWhereInput | TemplateWhereInput[]
    OR?: TemplateWhereInput[]
    NOT?: TemplateWhereInput | TemplateWhereInput[]
    name?: StringFilter<"Template"> | string
    description?: StringFilter<"Template"> | string
    preview_image?: StringNullableFilter<"Template"> | string | null
    app_schema?: JsonFilter<"Template">
    category?: StringFilter<"Template"> | string
    createdAt?: DateTimeFilter<"Template"> | Date | string
    updatedAt?: DateTimeFilter<"Template"> | Date | string
    apps?: AppListRelationFilter
  }, "id">

  export type TemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    preview_image?: SortOrderInput | SortOrder
    app_schema?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TemplateCountOrderByAggregateInput
    _avg?: TemplateAvgOrderByAggregateInput
    _max?: TemplateMaxOrderByAggregateInput
    _min?: TemplateMinOrderByAggregateInput
    _sum?: TemplateSumOrderByAggregateInput
  }

  export type TemplateScalarWhereWithAggregatesInput = {
    AND?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    OR?: TemplateScalarWhereWithAggregatesInput[]
    NOT?: TemplateScalarWhereWithAggregatesInput | TemplateScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Template"> | number
    name?: StringWithAggregatesFilter<"Template"> | string
    description?: StringWithAggregatesFilter<"Template"> | string
    preview_image?: StringNullableWithAggregatesFilter<"Template"> | string | null
    app_schema?: JsonWithAggregatesFilter<"Template">
    category?: StringWithAggregatesFilter<"Template"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Template"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Template"> | Date | string
  }

  export type ComponentWhereInput = {
    AND?: ComponentWhereInput | ComponentWhereInput[]
    OR?: ComponentWhereInput[]
    NOT?: ComponentWhereInput | ComponentWhereInput[]
    id?: IntFilter<"Component"> | number
    name?: StringFilter<"Component"> | string
    type?: StringFilter<"Component"> | string
    appId?: IntFilter<"Component"> | number
    properties?: JsonFilter<"Component">
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
  }

  export type ComponentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    appId?: SortOrder
    properties?: SortOrder
    app?: AppOrderByWithRelationInput
  }

  export type ComponentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ComponentWhereInput | ComponentWhereInput[]
    OR?: ComponentWhereInput[]
    NOT?: ComponentWhereInput | ComponentWhereInput[]
    name?: StringFilter<"Component"> | string
    type?: StringFilter<"Component"> | string
    appId?: IntFilter<"Component"> | number
    properties?: JsonFilter<"Component">
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
  }, "id">

  export type ComponentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    appId?: SortOrder
    properties?: SortOrder
    _count?: ComponentCountOrderByAggregateInput
    _avg?: ComponentAvgOrderByAggregateInput
    _max?: ComponentMaxOrderByAggregateInput
    _min?: ComponentMinOrderByAggregateInput
    _sum?: ComponentSumOrderByAggregateInput
  }

  export type ComponentScalarWhereWithAggregatesInput = {
    AND?: ComponentScalarWhereWithAggregatesInput | ComponentScalarWhereWithAggregatesInput[]
    OR?: ComponentScalarWhereWithAggregatesInput[]
    NOT?: ComponentScalarWhereWithAggregatesInput | ComponentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Component"> | number
    name?: StringWithAggregatesFilter<"Component"> | string
    type?: StringWithAggregatesFilter<"Component"> | string
    appId?: IntWithAggregatesFilter<"Component"> | number
    properties?: JsonWithAggregatesFilter<"Component">
  }

  export type WorkflowWhereInput = {
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    id?: IntFilter<"Workflow"> | number
    name?: StringFilter<"Workflow"> | string
    appId?: IntFilter<"Workflow"> | number
    steps?: JsonFilter<"Workflow">
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
  }

  export type WorkflowOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    appId?: SortOrder
    steps?: SortOrder
    app?: AppOrderByWithRelationInput
  }

  export type WorkflowWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: WorkflowWhereInput | WorkflowWhereInput[]
    OR?: WorkflowWhereInput[]
    NOT?: WorkflowWhereInput | WorkflowWhereInput[]
    name?: StringFilter<"Workflow"> | string
    appId?: IntFilter<"Workflow"> | number
    steps?: JsonFilter<"Workflow">
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
  }, "id">

  export type WorkflowOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    appId?: SortOrder
    steps?: SortOrder
    _count?: WorkflowCountOrderByAggregateInput
    _avg?: WorkflowAvgOrderByAggregateInput
    _max?: WorkflowMaxOrderByAggregateInput
    _min?: WorkflowMinOrderByAggregateInput
    _sum?: WorkflowSumOrderByAggregateInput
  }

  export type WorkflowScalarWhereWithAggregatesInput = {
    AND?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    OR?: WorkflowScalarWhereWithAggregatesInput[]
    NOT?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Workflow"> | number
    name?: StringWithAggregatesFilter<"Workflow"> | string
    appId?: IntWithAggregatesFilter<"Workflow"> | number
    steps?: JsonWithAggregatesFilter<"Workflow">
  }

  export type OtpWhereInput = {
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    id?: IntFilter<"Otp"> | number
    email?: StringFilter<"Otp"> | string
    otp?: StringFilter<"Otp"> | string
    type?: StringFilter<"Otp"> | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    used?: BoolFilter<"Otp"> | boolean
    createdAt?: DateTimeFilter<"Otp"> | Date | string
  }

  export type OtpOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: OtpWhereInput | OtpWhereInput[]
    OR?: OtpWhereInput[]
    NOT?: OtpWhereInput | OtpWhereInput[]
    email?: StringFilter<"Otp"> | string
    otp?: StringFilter<"Otp"> | string
    type?: StringFilter<"Otp"> | string
    expiresAt?: DateTimeFilter<"Otp"> | Date | string
    used?: BoolFilter<"Otp"> | boolean
    createdAt?: DateTimeFilter<"Otp"> | Date | string
  }, "id">

  export type OtpOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
    _count?: OtpCountOrderByAggregateInput
    _avg?: OtpAvgOrderByAggregateInput
    _max?: OtpMaxOrderByAggregateInput
    _min?: OtpMinOrderByAggregateInput
    _sum?: OtpSumOrderByAggregateInput
  }

  export type OtpScalarWhereWithAggregatesInput = {
    AND?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    OR?: OtpScalarWhereWithAggregatesInput[]
    NOT?: OtpScalarWhereWithAggregatesInput | OtpScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Otp"> | number
    email?: StringWithAggregatesFilter<"Otp"> | string
    otp?: StringWithAggregatesFilter<"Otp"> | string
    type?: StringWithAggregatesFilter<"Otp"> | string
    expiresAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
    used?: BoolWithAggregatesFilter<"Otp"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Otp"> | Date | string
  }

  export type AppSchemaWhereInput = {
    AND?: AppSchemaWhereInput | AppSchemaWhereInput[]
    OR?: AppSchemaWhereInput[]
    NOT?: AppSchemaWhereInput | AppSchemaWhereInput[]
    id?: IntFilter<"AppSchema"> | number
    appId?: IntFilter<"AppSchema"> | number
    name?: StringFilter<"AppSchema"> | string
    createdAt?: DateTimeFilter<"AppSchema"> | Date | string
    data?: AppDataListRelationFilter
    relatedFields?: AppFieldListRelationFilter
    fields?: AppFieldListRelationFilter
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
  }

  export type AppSchemaOrderByWithRelationInput = {
    id?: SortOrder
    appId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    data?: AppDataOrderByRelationAggregateInput
    relatedFields?: AppFieldOrderByRelationAggregateInput
    fields?: AppFieldOrderByRelationAggregateInput
    app?: AppOrderByWithRelationInput
  }

  export type AppSchemaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AppSchemaWhereInput | AppSchemaWhereInput[]
    OR?: AppSchemaWhereInput[]
    NOT?: AppSchemaWhereInput | AppSchemaWhereInput[]
    appId?: IntFilter<"AppSchema"> | number
    name?: StringFilter<"AppSchema"> | string
    createdAt?: DateTimeFilter<"AppSchema"> | Date | string
    data?: AppDataListRelationFilter
    relatedFields?: AppFieldListRelationFilter
    fields?: AppFieldListRelationFilter
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
  }, "id">

  export type AppSchemaOrderByWithAggregationInput = {
    id?: SortOrder
    appId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    _count?: AppSchemaCountOrderByAggregateInput
    _avg?: AppSchemaAvgOrderByAggregateInput
    _max?: AppSchemaMaxOrderByAggregateInput
    _min?: AppSchemaMinOrderByAggregateInput
    _sum?: AppSchemaSumOrderByAggregateInput
  }

  export type AppSchemaScalarWhereWithAggregatesInput = {
    AND?: AppSchemaScalarWhereWithAggregatesInput | AppSchemaScalarWhereWithAggregatesInput[]
    OR?: AppSchemaScalarWhereWithAggregatesInput[]
    NOT?: AppSchemaScalarWhereWithAggregatesInput | AppSchemaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AppSchema"> | number
    appId?: IntWithAggregatesFilter<"AppSchema"> | number
    name?: StringWithAggregatesFilter<"AppSchema"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AppSchema"> | Date | string
  }

  export type AppFieldWhereInput = {
    AND?: AppFieldWhereInput | AppFieldWhereInput[]
    OR?: AppFieldWhereInput[]
    NOT?: AppFieldWhereInput | AppFieldWhereInput[]
    id?: IntFilter<"AppField"> | number
    schemaId?: IntFilter<"AppField"> | number
    name?: StringFilter<"AppField"> | string
    type?: EnumFieldTypeFilter<"AppField"> | $Enums.FieldType
    constraints?: JsonFilter<"AppField">
    relatedSchemaId?: IntNullableFilter<"AppField"> | number | null
    createdAt?: DateTimeFilter<"AppField"> | Date | string
    relatedSchema?: XOR<AppSchemaNullableScalarRelationFilter, AppSchemaWhereInput> | null
    schema?: XOR<AppSchemaScalarRelationFilter, AppSchemaWhereInput>
  }

  export type AppFieldOrderByWithRelationInput = {
    id?: SortOrder
    schemaId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    constraints?: SortOrder
    relatedSchemaId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    relatedSchema?: AppSchemaOrderByWithRelationInput
    schema?: AppSchemaOrderByWithRelationInput
  }

  export type AppFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AppFieldWhereInput | AppFieldWhereInput[]
    OR?: AppFieldWhereInput[]
    NOT?: AppFieldWhereInput | AppFieldWhereInput[]
    schemaId?: IntFilter<"AppField"> | number
    name?: StringFilter<"AppField"> | string
    type?: EnumFieldTypeFilter<"AppField"> | $Enums.FieldType
    constraints?: JsonFilter<"AppField">
    relatedSchemaId?: IntNullableFilter<"AppField"> | number | null
    createdAt?: DateTimeFilter<"AppField"> | Date | string
    relatedSchema?: XOR<AppSchemaNullableScalarRelationFilter, AppSchemaWhereInput> | null
    schema?: XOR<AppSchemaScalarRelationFilter, AppSchemaWhereInput>
  }, "id">

  export type AppFieldOrderByWithAggregationInput = {
    id?: SortOrder
    schemaId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    constraints?: SortOrder
    relatedSchemaId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AppFieldCountOrderByAggregateInput
    _avg?: AppFieldAvgOrderByAggregateInput
    _max?: AppFieldMaxOrderByAggregateInput
    _min?: AppFieldMinOrderByAggregateInput
    _sum?: AppFieldSumOrderByAggregateInput
  }

  export type AppFieldScalarWhereWithAggregatesInput = {
    AND?: AppFieldScalarWhereWithAggregatesInput | AppFieldScalarWhereWithAggregatesInput[]
    OR?: AppFieldScalarWhereWithAggregatesInput[]
    NOT?: AppFieldScalarWhereWithAggregatesInput | AppFieldScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AppField"> | number
    schemaId?: IntWithAggregatesFilter<"AppField"> | number
    name?: StringWithAggregatesFilter<"AppField"> | string
    type?: EnumFieldTypeWithAggregatesFilter<"AppField"> | $Enums.FieldType
    constraints?: JsonWithAggregatesFilter<"AppField">
    relatedSchemaId?: IntNullableWithAggregatesFilter<"AppField"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"AppField"> | Date | string
  }

  export type AppDataWhereInput = {
    AND?: AppDataWhereInput | AppDataWhereInput[]
    OR?: AppDataWhereInput[]
    NOT?: AppDataWhereInput | AppDataWhereInput[]
    id?: IntFilter<"AppData"> | number
    schemaId?: IntFilter<"AppData"> | number
    data?: JsonFilter<"AppData">
    createdAt?: DateTimeFilter<"AppData"> | Date | string
    schema?: XOR<AppSchemaScalarRelationFilter, AppSchemaWhereInput>
  }

  export type AppDataOrderByWithRelationInput = {
    id?: SortOrder
    schemaId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    schema?: AppSchemaOrderByWithRelationInput
  }

  export type AppDataWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AppDataWhereInput | AppDataWhereInput[]
    OR?: AppDataWhereInput[]
    NOT?: AppDataWhereInput | AppDataWhereInput[]
    schemaId?: IntFilter<"AppData"> | number
    data?: JsonFilter<"AppData">
    createdAt?: DateTimeFilter<"AppData"> | Date | string
    schema?: XOR<AppSchemaScalarRelationFilter, AppSchemaWhereInput>
  }, "id">

  export type AppDataOrderByWithAggregationInput = {
    id?: SortOrder
    schemaId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
    _count?: AppDataCountOrderByAggregateInput
    _avg?: AppDataAvgOrderByAggregateInput
    _max?: AppDataMaxOrderByAggregateInput
    _min?: AppDataMinOrderByAggregateInput
    _sum?: AppDataSumOrderByAggregateInput
  }

  export type AppDataScalarWhereWithAggregatesInput = {
    AND?: AppDataScalarWhereWithAggregatesInput | AppDataScalarWhereWithAggregatesInput[]
    OR?: AppDataScalarWhereWithAggregatesInput[]
    NOT?: AppDataScalarWhereWithAggregatesInput | AppDataScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AppData"> | number
    schemaId?: IntWithAggregatesFilter<"AppData"> | number
    data?: JsonWithAggregatesFilter<"AppData">
    createdAt?: DateTimeWithAggregatesFilter<"AppData"> | Date | string
  }

  export type VideoWhereInput = {
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    id?: IntFilter<"Video"> | number
    title?: StringFilter<"Video"> | string
    url?: StringFilter<"Video"> | string
    category?: StringFilter<"Video"> | string
    createdAt?: DateTimeFilter<"Video"> | Date | string
  }

  export type VideoOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: VideoWhereInput | VideoWhereInput[]
    OR?: VideoWhereInput[]
    NOT?: VideoWhereInput | VideoWhereInput[]
    title?: StringFilter<"Video"> | string
    url?: StringFilter<"Video"> | string
    category?: StringFilter<"Video"> | string
    createdAt?: DateTimeFilter<"Video"> | Date | string
  }, "id">

  export type VideoOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    _count?: VideoCountOrderByAggregateInput
    _avg?: VideoAvgOrderByAggregateInput
    _max?: VideoMaxOrderByAggregateInput
    _min?: VideoMinOrderByAggregateInput
    _sum?: VideoSumOrderByAggregateInput
  }

  export type VideoScalarWhereWithAggregatesInput = {
    AND?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    OR?: VideoScalarWhereWithAggregatesInput[]
    NOT?: VideoScalarWhereWithAggregatesInput | VideoScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Video"> | number
    title?: StringWithAggregatesFilter<"Video"> | string
    url?: StringWithAggregatesFilter<"Video"> | string
    category?: StringWithAggregatesFilter<"Video"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Video"> | Date | string
  }

  export type AppMetricWhereInput = {
    AND?: AppMetricWhereInput | AppMetricWhereInput[]
    OR?: AppMetricWhereInput[]
    NOT?: AppMetricWhereInput | AppMetricWhereInput[]
    id?: IntFilter<"AppMetric"> | number
    appId?: IntFilter<"AppMetric"> | number
    activeDays?: IntFilter<"AppMetric"> | number
    downtime?: FloatFilter<"AppMetric"> | number
    totalUsers?: IntFilter<"AppMetric"> | number
    traffic?: IntFilter<"AppMetric"> | number
    createdAt?: DateTimeFilter<"AppMetric"> | Date | string
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
  }

  export type AppMetricOrderByWithRelationInput = {
    id?: SortOrder
    appId?: SortOrder
    activeDays?: SortOrder
    downtime?: SortOrder
    totalUsers?: SortOrder
    traffic?: SortOrder
    createdAt?: SortOrder
    app?: AppOrderByWithRelationInput
  }

  export type AppMetricWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AppMetricWhereInput | AppMetricWhereInput[]
    OR?: AppMetricWhereInput[]
    NOT?: AppMetricWhereInput | AppMetricWhereInput[]
    appId?: IntFilter<"AppMetric"> | number
    activeDays?: IntFilter<"AppMetric"> | number
    downtime?: FloatFilter<"AppMetric"> | number
    totalUsers?: IntFilter<"AppMetric"> | number
    traffic?: IntFilter<"AppMetric"> | number
    createdAt?: DateTimeFilter<"AppMetric"> | Date | string
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
  }, "id">

  export type AppMetricOrderByWithAggregationInput = {
    id?: SortOrder
    appId?: SortOrder
    activeDays?: SortOrder
    downtime?: SortOrder
    totalUsers?: SortOrder
    traffic?: SortOrder
    createdAt?: SortOrder
    _count?: AppMetricCountOrderByAggregateInput
    _avg?: AppMetricAvgOrderByAggregateInput
    _max?: AppMetricMaxOrderByAggregateInput
    _min?: AppMetricMinOrderByAggregateInput
    _sum?: AppMetricSumOrderByAggregateInput
  }

  export type AppMetricScalarWhereWithAggregatesInput = {
    AND?: AppMetricScalarWhereWithAggregatesInput | AppMetricScalarWhereWithAggregatesInput[]
    OR?: AppMetricScalarWhereWithAggregatesInput[]
    NOT?: AppMetricScalarWhereWithAggregatesInput | AppMetricScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AppMetric"> | number
    appId?: IntWithAggregatesFilter<"AppMetric"> | number
    activeDays?: IntWithAggregatesFilter<"AppMetric"> | number
    downtime?: FloatWithAggregatesFilter<"AppMetric"> | number
    totalUsers?: IntWithAggregatesFilter<"AppMetric"> | number
    traffic?: IntWithAggregatesFilter<"AppMetric"> | number
    createdAt?: DateTimeWithAggregatesFilter<"AppMetric"> | Date | string
  }

  export type AppIssueWhereInput = {
    AND?: AppIssueWhereInput | AppIssueWhereInput[]
    OR?: AppIssueWhereInput[]
    NOT?: AppIssueWhereInput | AppIssueWhereInput[]
    id?: IntFilter<"AppIssue"> | number
    appId?: IntFilter<"AppIssue"> | number
    severity?: EnumIssueSeverityFilter<"AppIssue"> | $Enums.IssueSeverity
    description?: StringFilter<"AppIssue"> | string
    status?: EnumIssueStatusFilter<"AppIssue"> | $Enums.IssueStatus
    createdAt?: DateTimeFilter<"AppIssue"> | Date | string
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
  }

  export type AppIssueOrderByWithRelationInput = {
    id?: SortOrder
    appId?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    app?: AppOrderByWithRelationInput
  }

  export type AppIssueWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AppIssueWhereInput | AppIssueWhereInput[]
    OR?: AppIssueWhereInput[]
    NOT?: AppIssueWhereInput | AppIssueWhereInput[]
    appId?: IntFilter<"AppIssue"> | number
    severity?: EnumIssueSeverityFilter<"AppIssue"> | $Enums.IssueSeverity
    description?: StringFilter<"AppIssue"> | string
    status?: EnumIssueStatusFilter<"AppIssue"> | $Enums.IssueStatus
    createdAt?: DateTimeFilter<"AppIssue"> | Date | string
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
  }, "id">

  export type AppIssueOrderByWithAggregationInput = {
    id?: SortOrder
    appId?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
    _count?: AppIssueCountOrderByAggregateInput
    _avg?: AppIssueAvgOrderByAggregateInput
    _max?: AppIssueMaxOrderByAggregateInput
    _min?: AppIssueMinOrderByAggregateInput
    _sum?: AppIssueSumOrderByAggregateInput
  }

  export type AppIssueScalarWhereWithAggregatesInput = {
    AND?: AppIssueScalarWhereWithAggregatesInput | AppIssueScalarWhereWithAggregatesInput[]
    OR?: AppIssueScalarWhereWithAggregatesInput[]
    NOT?: AppIssueScalarWhereWithAggregatesInput | AppIssueScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AppIssue"> | number
    appId?: IntWithAggregatesFilter<"AppIssue"> | number
    severity?: EnumIssueSeverityWithAggregatesFilter<"AppIssue"> | $Enums.IssueSeverity
    description?: StringWithAggregatesFilter<"AppIssue"> | string
    status?: EnumIssueStatusWithAggregatesFilter<"AppIssue"> | $Enums.IssueStatus
    createdAt?: DateTimeWithAggregatesFilter<"AppIssue"> | Date | string
  }

  export type AppWarningWhereInput = {
    AND?: AppWarningWhereInput | AppWarningWhereInput[]
    OR?: AppWarningWhereInput[]
    NOT?: AppWarningWhereInput | AppWarningWhereInput[]
    id?: IntFilter<"AppWarning"> | number
    appId?: IntFilter<"AppWarning"> | number
    message?: StringFilter<"AppWarning"> | string
    createdAt?: DateTimeFilter<"AppWarning"> | Date | string
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
  }

  export type AppWarningOrderByWithRelationInput = {
    id?: SortOrder
    appId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    app?: AppOrderByWithRelationInput
  }

  export type AppWarningWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AppWarningWhereInput | AppWarningWhereInput[]
    OR?: AppWarningWhereInput[]
    NOT?: AppWarningWhereInput | AppWarningWhereInput[]
    appId?: IntFilter<"AppWarning"> | number
    message?: StringFilter<"AppWarning"> | string
    createdAt?: DateTimeFilter<"AppWarning"> | Date | string
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
  }, "id">

  export type AppWarningOrderByWithAggregationInput = {
    id?: SortOrder
    appId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: AppWarningCountOrderByAggregateInput
    _avg?: AppWarningAvgOrderByAggregateInput
    _max?: AppWarningMaxOrderByAggregateInput
    _min?: AppWarningMinOrderByAggregateInput
    _sum?: AppWarningSumOrderByAggregateInput
  }

  export type AppWarningScalarWhereWithAggregatesInput = {
    AND?: AppWarningScalarWhereWithAggregatesInput | AppWarningScalarWhereWithAggregatesInput[]
    OR?: AppWarningScalarWhereWithAggregatesInput[]
    NOT?: AppWarningScalarWhereWithAggregatesInput | AppWarningScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"AppWarning"> | number
    appId?: IntWithAggregatesFilter<"AppWarning"> | number
    message?: StringWithAggregatesFilter<"AppWarning"> | string
    createdAt?: DateTimeWithAggregatesFilter<"AppWarning"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _avg?: NotificationAvgOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
    _sum?: NotificationSumOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Notification"> | number
    userId?: IntWithAggregatesFilter<"Notification"> | number
    type?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type BlacklistedTokenWhereInput = {
    AND?: BlacklistedTokenWhereInput | BlacklistedTokenWhereInput[]
    OR?: BlacklistedTokenWhereInput[]
    NOT?: BlacklistedTokenWhereInput | BlacklistedTokenWhereInput[]
    id?: IntFilter<"BlacklistedToken"> | number
    token?: StringFilter<"BlacklistedToken"> | string
    createdAt?: DateTimeFilter<"BlacklistedToken"> | Date | string
    expiresAt?: DateTimeFilter<"BlacklistedToken"> | Date | string
  }

  export type BlacklistedTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type BlacklistedTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    token?: string
    AND?: BlacklistedTokenWhereInput | BlacklistedTokenWhereInput[]
    OR?: BlacklistedTokenWhereInput[]
    NOT?: BlacklistedTokenWhereInput | BlacklistedTokenWhereInput[]
    createdAt?: DateTimeFilter<"BlacklistedToken"> | Date | string
    expiresAt?: DateTimeFilter<"BlacklistedToken"> | Date | string
  }, "id" | "token">

  export type BlacklistedTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
    _count?: BlacklistedTokenCountOrderByAggregateInput
    _avg?: BlacklistedTokenAvgOrderByAggregateInput
    _max?: BlacklistedTokenMaxOrderByAggregateInput
    _min?: BlacklistedTokenMinOrderByAggregateInput
    _sum?: BlacklistedTokenSumOrderByAggregateInput
  }

  export type BlacklistedTokenScalarWhereWithAggregatesInput = {
    AND?: BlacklistedTokenScalarWhereWithAggregatesInput | BlacklistedTokenScalarWhereWithAggregatesInput[]
    OR?: BlacklistedTokenScalarWhereWithAggregatesInput[]
    NOT?: BlacklistedTokenScalarWhereWithAggregatesInput | BlacklistedTokenScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"BlacklistedToken"> | number
    token?: StringWithAggregatesFilter<"BlacklistedToken"> | string
    createdAt?: DateTimeWithAggregatesFilter<"BlacklistedToken"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"BlacklistedToken"> | Date | string
  }

  export type CanvasWhereInput = {
    AND?: CanvasWhereInput | CanvasWhereInput[]
    OR?: CanvasWhereInput[]
    NOT?: CanvasWhereInput | CanvasWhereInput[]
    id?: IntFilter<"Canvas"> | number
    appId?: IntFilter<"Canvas"> | number
    name?: StringFilter<"Canvas"> | string
    description?: StringNullableFilter<"Canvas"> | string | null
    width?: IntFilter<"Canvas"> | number
    height?: IntFilter<"Canvas"> | number
    background?: JsonFilter<"Canvas">
    gridEnabled?: BoolFilter<"Canvas"> | boolean
    snapEnabled?: BoolFilter<"Canvas"> | boolean
    zoomLevel?: FloatFilter<"Canvas"> | number
    createdAt?: DateTimeFilter<"Canvas"> | Date | string
    updatedAt?: DateTimeFilter<"Canvas"> | Date | string
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
    elements?: CanvasElementListRelationFilter
    history?: CanvasHistoryListRelationFilter
  }

  export type CanvasOrderByWithRelationInput = {
    id?: SortOrder
    appId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    width?: SortOrder
    height?: SortOrder
    background?: SortOrder
    gridEnabled?: SortOrder
    snapEnabled?: SortOrder
    zoomLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    app?: AppOrderByWithRelationInput
    elements?: CanvasElementOrderByRelationAggregateInput
    history?: CanvasHistoryOrderByRelationAggregateInput
  }

  export type CanvasWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    appId?: number
    AND?: CanvasWhereInput | CanvasWhereInput[]
    OR?: CanvasWhereInput[]
    NOT?: CanvasWhereInput | CanvasWhereInput[]
    name?: StringFilter<"Canvas"> | string
    description?: StringNullableFilter<"Canvas"> | string | null
    width?: IntFilter<"Canvas"> | number
    height?: IntFilter<"Canvas"> | number
    background?: JsonFilter<"Canvas">
    gridEnabled?: BoolFilter<"Canvas"> | boolean
    snapEnabled?: BoolFilter<"Canvas"> | boolean
    zoomLevel?: FloatFilter<"Canvas"> | number
    createdAt?: DateTimeFilter<"Canvas"> | Date | string
    updatedAt?: DateTimeFilter<"Canvas"> | Date | string
    app?: XOR<AppScalarRelationFilter, AppWhereInput>
    elements?: CanvasElementListRelationFilter
    history?: CanvasHistoryListRelationFilter
  }, "id" | "appId">

  export type CanvasOrderByWithAggregationInput = {
    id?: SortOrder
    appId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    width?: SortOrder
    height?: SortOrder
    background?: SortOrder
    gridEnabled?: SortOrder
    snapEnabled?: SortOrder
    zoomLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CanvasCountOrderByAggregateInput
    _avg?: CanvasAvgOrderByAggregateInput
    _max?: CanvasMaxOrderByAggregateInput
    _min?: CanvasMinOrderByAggregateInput
    _sum?: CanvasSumOrderByAggregateInput
  }

  export type CanvasScalarWhereWithAggregatesInput = {
    AND?: CanvasScalarWhereWithAggregatesInput | CanvasScalarWhereWithAggregatesInput[]
    OR?: CanvasScalarWhereWithAggregatesInput[]
    NOT?: CanvasScalarWhereWithAggregatesInput | CanvasScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Canvas"> | number
    appId?: IntWithAggregatesFilter<"Canvas"> | number
    name?: StringWithAggregatesFilter<"Canvas"> | string
    description?: StringNullableWithAggregatesFilter<"Canvas"> | string | null
    width?: IntWithAggregatesFilter<"Canvas"> | number
    height?: IntWithAggregatesFilter<"Canvas"> | number
    background?: JsonWithAggregatesFilter<"Canvas">
    gridEnabled?: BoolWithAggregatesFilter<"Canvas"> | boolean
    snapEnabled?: BoolWithAggregatesFilter<"Canvas"> | boolean
    zoomLevel?: FloatWithAggregatesFilter<"Canvas"> | number
    createdAt?: DateTimeWithAggregatesFilter<"Canvas"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Canvas"> | Date | string
  }

  export type CanvasElementWhereInput = {
    AND?: CanvasElementWhereInput | CanvasElementWhereInput[]
    OR?: CanvasElementWhereInput[]
    NOT?: CanvasElementWhereInput | CanvasElementWhereInput[]
    id?: IntFilter<"CanvasElement"> | number
    canvasId?: IntFilter<"CanvasElement"> | number
    elementId?: StringFilter<"CanvasElement"> | string
    type?: EnumElementTypeFilter<"CanvasElement"> | $Enums.ElementType
    name?: StringFilter<"CanvasElement"> | string
    x?: FloatFilter<"CanvasElement"> | number
    y?: FloatFilter<"CanvasElement"> | number
    width?: FloatFilter<"CanvasElement"> | number
    height?: FloatFilter<"CanvasElement"> | number
    rotation?: FloatFilter<"CanvasElement"> | number
    zIndex?: IntFilter<"CanvasElement"> | number
    locked?: BoolFilter<"CanvasElement"> | boolean
    visible?: BoolFilter<"CanvasElement"> | boolean
    groupId?: StringNullableFilter<"CanvasElement"> | string | null
    parentId?: IntNullableFilter<"CanvasElement"> | number | null
    properties?: JsonFilter<"CanvasElement">
    styles?: JsonFilter<"CanvasElement">
    constraints?: JsonFilter<"CanvasElement">
    createdAt?: DateTimeFilter<"CanvasElement"> | Date | string
    updatedAt?: DateTimeFilter<"CanvasElement"> | Date | string
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
    parent?: XOR<CanvasElementNullableScalarRelationFilter, CanvasElementWhereInput> | null
    children?: CanvasElementListRelationFilter
    interactions?: ElementInteractionListRelationFilter
    validations?: ElementValidationListRelationFilter
  }

  export type CanvasElementOrderByWithRelationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    elementId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    zIndex?: SortOrder
    locked?: SortOrder
    visible?: SortOrder
    groupId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    properties?: SortOrder
    styles?: SortOrder
    constraints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    canvas?: CanvasOrderByWithRelationInput
    parent?: CanvasElementOrderByWithRelationInput
    children?: CanvasElementOrderByRelationAggregateInput
    interactions?: ElementInteractionOrderByRelationAggregateInput
    validations?: ElementValidationOrderByRelationAggregateInput
  }

  export type CanvasElementWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    elementId?: string
    AND?: CanvasElementWhereInput | CanvasElementWhereInput[]
    OR?: CanvasElementWhereInput[]
    NOT?: CanvasElementWhereInput | CanvasElementWhereInput[]
    canvasId?: IntFilter<"CanvasElement"> | number
    type?: EnumElementTypeFilter<"CanvasElement"> | $Enums.ElementType
    name?: StringFilter<"CanvasElement"> | string
    x?: FloatFilter<"CanvasElement"> | number
    y?: FloatFilter<"CanvasElement"> | number
    width?: FloatFilter<"CanvasElement"> | number
    height?: FloatFilter<"CanvasElement"> | number
    rotation?: FloatFilter<"CanvasElement"> | number
    zIndex?: IntFilter<"CanvasElement"> | number
    locked?: BoolFilter<"CanvasElement"> | boolean
    visible?: BoolFilter<"CanvasElement"> | boolean
    groupId?: StringNullableFilter<"CanvasElement"> | string | null
    parentId?: IntNullableFilter<"CanvasElement"> | number | null
    properties?: JsonFilter<"CanvasElement">
    styles?: JsonFilter<"CanvasElement">
    constraints?: JsonFilter<"CanvasElement">
    createdAt?: DateTimeFilter<"CanvasElement"> | Date | string
    updatedAt?: DateTimeFilter<"CanvasElement"> | Date | string
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
    parent?: XOR<CanvasElementNullableScalarRelationFilter, CanvasElementWhereInput> | null
    children?: CanvasElementListRelationFilter
    interactions?: ElementInteractionListRelationFilter
    validations?: ElementValidationListRelationFilter
  }, "id" | "elementId">

  export type CanvasElementOrderByWithAggregationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    elementId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    zIndex?: SortOrder
    locked?: SortOrder
    visible?: SortOrder
    groupId?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    properties?: SortOrder
    styles?: SortOrder
    constraints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: CanvasElementCountOrderByAggregateInput
    _avg?: CanvasElementAvgOrderByAggregateInput
    _max?: CanvasElementMaxOrderByAggregateInput
    _min?: CanvasElementMinOrderByAggregateInput
    _sum?: CanvasElementSumOrderByAggregateInput
  }

  export type CanvasElementScalarWhereWithAggregatesInput = {
    AND?: CanvasElementScalarWhereWithAggregatesInput | CanvasElementScalarWhereWithAggregatesInput[]
    OR?: CanvasElementScalarWhereWithAggregatesInput[]
    NOT?: CanvasElementScalarWhereWithAggregatesInput | CanvasElementScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CanvasElement"> | number
    canvasId?: IntWithAggregatesFilter<"CanvasElement"> | number
    elementId?: StringWithAggregatesFilter<"CanvasElement"> | string
    type?: EnumElementTypeWithAggregatesFilter<"CanvasElement"> | $Enums.ElementType
    name?: StringWithAggregatesFilter<"CanvasElement"> | string
    x?: FloatWithAggregatesFilter<"CanvasElement"> | number
    y?: FloatWithAggregatesFilter<"CanvasElement"> | number
    width?: FloatWithAggregatesFilter<"CanvasElement"> | number
    height?: FloatWithAggregatesFilter<"CanvasElement"> | number
    rotation?: FloatWithAggregatesFilter<"CanvasElement"> | number
    zIndex?: IntWithAggregatesFilter<"CanvasElement"> | number
    locked?: BoolWithAggregatesFilter<"CanvasElement"> | boolean
    visible?: BoolWithAggregatesFilter<"CanvasElement"> | boolean
    groupId?: StringNullableWithAggregatesFilter<"CanvasElement"> | string | null
    parentId?: IntNullableWithAggregatesFilter<"CanvasElement"> | number | null
    properties?: JsonWithAggregatesFilter<"CanvasElement">
    styles?: JsonWithAggregatesFilter<"CanvasElement">
    constraints?: JsonWithAggregatesFilter<"CanvasElement">
    createdAt?: DateTimeWithAggregatesFilter<"CanvasElement"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CanvasElement"> | Date | string
  }

  export type ElementInteractionWhereInput = {
    AND?: ElementInteractionWhereInput | ElementInteractionWhereInput[]
    OR?: ElementInteractionWhereInput[]
    NOT?: ElementInteractionWhereInput | ElementInteractionWhereInput[]
    id?: IntFilter<"ElementInteraction"> | number
    elementId?: IntFilter<"ElementInteraction"> | number
    event?: StringFilter<"ElementInteraction"> | string
    action?: JsonFilter<"ElementInteraction">
    createdAt?: DateTimeFilter<"ElementInteraction"> | Date | string
    element?: XOR<CanvasElementScalarRelationFilter, CanvasElementWhereInput>
  }

  export type ElementInteractionOrderByWithRelationInput = {
    id?: SortOrder
    elementId?: SortOrder
    event?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    element?: CanvasElementOrderByWithRelationInput
  }

  export type ElementInteractionWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ElementInteractionWhereInput | ElementInteractionWhereInput[]
    OR?: ElementInteractionWhereInput[]
    NOT?: ElementInteractionWhereInput | ElementInteractionWhereInput[]
    elementId?: IntFilter<"ElementInteraction"> | number
    event?: StringFilter<"ElementInteraction"> | string
    action?: JsonFilter<"ElementInteraction">
    createdAt?: DateTimeFilter<"ElementInteraction"> | Date | string
    element?: XOR<CanvasElementScalarRelationFilter, CanvasElementWhereInput>
  }, "id">

  export type ElementInteractionOrderByWithAggregationInput = {
    id?: SortOrder
    elementId?: SortOrder
    event?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
    _count?: ElementInteractionCountOrderByAggregateInput
    _avg?: ElementInteractionAvgOrderByAggregateInput
    _max?: ElementInteractionMaxOrderByAggregateInput
    _min?: ElementInteractionMinOrderByAggregateInput
    _sum?: ElementInteractionSumOrderByAggregateInput
  }

  export type ElementInteractionScalarWhereWithAggregatesInput = {
    AND?: ElementInteractionScalarWhereWithAggregatesInput | ElementInteractionScalarWhereWithAggregatesInput[]
    OR?: ElementInteractionScalarWhereWithAggregatesInput[]
    NOT?: ElementInteractionScalarWhereWithAggregatesInput | ElementInteractionScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ElementInteraction"> | number
    elementId?: IntWithAggregatesFilter<"ElementInteraction"> | number
    event?: StringWithAggregatesFilter<"ElementInteraction"> | string
    action?: JsonWithAggregatesFilter<"ElementInteraction">
    createdAt?: DateTimeWithAggregatesFilter<"ElementInteraction"> | Date | string
  }

  export type ElementValidationWhereInput = {
    AND?: ElementValidationWhereInput | ElementValidationWhereInput[]
    OR?: ElementValidationWhereInput[]
    NOT?: ElementValidationWhereInput | ElementValidationWhereInput[]
    id?: IntFilter<"ElementValidation"> | number
    elementId?: IntFilter<"ElementValidation"> | number
    rule?: StringFilter<"ElementValidation"> | string
    value?: JsonFilter<"ElementValidation">
    message?: StringFilter<"ElementValidation"> | string
    createdAt?: DateTimeFilter<"ElementValidation"> | Date | string
    element?: XOR<CanvasElementScalarRelationFilter, CanvasElementWhereInput>
  }

  export type ElementValidationOrderByWithRelationInput = {
    id?: SortOrder
    elementId?: SortOrder
    rule?: SortOrder
    value?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    element?: CanvasElementOrderByWithRelationInput
  }

  export type ElementValidationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ElementValidationWhereInput | ElementValidationWhereInput[]
    OR?: ElementValidationWhereInput[]
    NOT?: ElementValidationWhereInput | ElementValidationWhereInput[]
    elementId?: IntFilter<"ElementValidation"> | number
    rule?: StringFilter<"ElementValidation"> | string
    value?: JsonFilter<"ElementValidation">
    message?: StringFilter<"ElementValidation"> | string
    createdAt?: DateTimeFilter<"ElementValidation"> | Date | string
    element?: XOR<CanvasElementScalarRelationFilter, CanvasElementWhereInput>
  }, "id">

  export type ElementValidationOrderByWithAggregationInput = {
    id?: SortOrder
    elementId?: SortOrder
    rule?: SortOrder
    value?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
    _count?: ElementValidationCountOrderByAggregateInput
    _avg?: ElementValidationAvgOrderByAggregateInput
    _max?: ElementValidationMaxOrderByAggregateInput
    _min?: ElementValidationMinOrderByAggregateInput
    _sum?: ElementValidationSumOrderByAggregateInput
  }

  export type ElementValidationScalarWhereWithAggregatesInput = {
    AND?: ElementValidationScalarWhereWithAggregatesInput | ElementValidationScalarWhereWithAggregatesInput[]
    OR?: ElementValidationScalarWhereWithAggregatesInput[]
    NOT?: ElementValidationScalarWhereWithAggregatesInput | ElementValidationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ElementValidation"> | number
    elementId?: IntWithAggregatesFilter<"ElementValidation"> | number
    rule?: StringWithAggregatesFilter<"ElementValidation"> | string
    value?: JsonWithAggregatesFilter<"ElementValidation">
    message?: StringWithAggregatesFilter<"ElementValidation"> | string
    createdAt?: DateTimeWithAggregatesFilter<"ElementValidation"> | Date | string
  }

  export type CanvasHistoryWhereInput = {
    AND?: CanvasHistoryWhereInput | CanvasHistoryWhereInput[]
    OR?: CanvasHistoryWhereInput[]
    NOT?: CanvasHistoryWhereInput | CanvasHistoryWhereInput[]
    id?: IntFilter<"CanvasHistory"> | number
    canvasId?: IntFilter<"CanvasHistory"> | number
    action?: StringFilter<"CanvasHistory"> | string
    elementId?: StringNullableFilter<"CanvasHistory"> | string | null
    oldState?: JsonNullableFilter<"CanvasHistory">
    newState?: JsonNullableFilter<"CanvasHistory">
    userId?: IntFilter<"CanvasHistory"> | number
    createdAt?: DateTimeFilter<"CanvasHistory"> | Date | string
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type CanvasHistoryOrderByWithRelationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    action?: SortOrder
    elementId?: SortOrderInput | SortOrder
    oldState?: SortOrderInput | SortOrder
    newState?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    canvas?: CanvasOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type CanvasHistoryWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: CanvasHistoryWhereInput | CanvasHistoryWhereInput[]
    OR?: CanvasHistoryWhereInput[]
    NOT?: CanvasHistoryWhereInput | CanvasHistoryWhereInput[]
    canvasId?: IntFilter<"CanvasHistory"> | number
    action?: StringFilter<"CanvasHistory"> | string
    elementId?: StringNullableFilter<"CanvasHistory"> | string | null
    oldState?: JsonNullableFilter<"CanvasHistory">
    newState?: JsonNullableFilter<"CanvasHistory">
    userId?: IntFilter<"CanvasHistory"> | number
    createdAt?: DateTimeFilter<"CanvasHistory"> | Date | string
    canvas?: XOR<CanvasScalarRelationFilter, CanvasWhereInput>
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type CanvasHistoryOrderByWithAggregationInput = {
    id?: SortOrder
    canvasId?: SortOrder
    action?: SortOrder
    elementId?: SortOrderInput | SortOrder
    oldState?: SortOrderInput | SortOrder
    newState?: SortOrderInput | SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: CanvasHistoryCountOrderByAggregateInput
    _avg?: CanvasHistoryAvgOrderByAggregateInput
    _max?: CanvasHistoryMaxOrderByAggregateInput
    _min?: CanvasHistoryMinOrderByAggregateInput
    _sum?: CanvasHistorySumOrderByAggregateInput
  }

  export type CanvasHistoryScalarWhereWithAggregatesInput = {
    AND?: CanvasHistoryScalarWhereWithAggregatesInput | CanvasHistoryScalarWhereWithAggregatesInput[]
    OR?: CanvasHistoryScalarWhereWithAggregatesInput[]
    NOT?: CanvasHistoryScalarWhereWithAggregatesInput | CanvasHistoryScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"CanvasHistory"> | number
    canvasId?: IntWithAggregatesFilter<"CanvasHistory"> | number
    action?: StringWithAggregatesFilter<"CanvasHistory"> | string
    elementId?: StringNullableWithAggregatesFilter<"CanvasHistory"> | string | null
    oldState?: JsonNullableWithAggregatesFilter<"CanvasHistory">
    newState?: JsonNullableWithAggregatesFilter<"CanvasHistory">
    userId?: IntWithAggregatesFilter<"CanvasHistory"> | number
    createdAt?: DateTimeWithAggregatesFilter<"CanvasHistory"> | Date | string
  }

  export type MediaFileWhereInput = {
    AND?: MediaFileWhereInput | MediaFileWhereInput[]
    OR?: MediaFileWhereInput[]
    NOT?: MediaFileWhereInput | MediaFileWhereInput[]
    id?: IntFilter<"MediaFile"> | number
    filename?: StringFilter<"MediaFile"> | string
    originalName?: StringFilter<"MediaFile"> | string
    mimeType?: StringFilter<"MediaFile"> | string
    size?: IntFilter<"MediaFile"> | number
    url?: StringFilter<"MediaFile"> | string
    thumbnail?: StringNullableFilter<"MediaFile"> | string | null
    userId?: IntFilter<"MediaFile"> | number
    appId?: IntNullableFilter<"MediaFile"> | number | null
    metadata?: JsonFilter<"MediaFile">
    createdAt?: DateTimeFilter<"MediaFile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    app?: XOR<AppNullableScalarRelationFilter, AppWhereInput> | null
  }

  export type MediaFileOrderByWithRelationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    userId?: SortOrder
    appId?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
    app?: AppOrderByWithRelationInput
  }

  export type MediaFileWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: MediaFileWhereInput | MediaFileWhereInput[]
    OR?: MediaFileWhereInput[]
    NOT?: MediaFileWhereInput | MediaFileWhereInput[]
    filename?: StringFilter<"MediaFile"> | string
    originalName?: StringFilter<"MediaFile"> | string
    mimeType?: StringFilter<"MediaFile"> | string
    size?: IntFilter<"MediaFile"> | number
    url?: StringFilter<"MediaFile"> | string
    thumbnail?: StringNullableFilter<"MediaFile"> | string | null
    userId?: IntFilter<"MediaFile"> | number
    appId?: IntNullableFilter<"MediaFile"> | number | null
    metadata?: JsonFilter<"MediaFile">
    createdAt?: DateTimeFilter<"MediaFile"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    app?: XOR<AppNullableScalarRelationFilter, AppWhereInput> | null
  }, "id">

  export type MediaFileOrderByWithAggregationInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    userId?: SortOrder
    appId?: SortOrderInput | SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    _count?: MediaFileCountOrderByAggregateInput
    _avg?: MediaFileAvgOrderByAggregateInput
    _max?: MediaFileMaxOrderByAggregateInput
    _min?: MediaFileMinOrderByAggregateInput
    _sum?: MediaFileSumOrderByAggregateInput
  }

  export type MediaFileScalarWhereWithAggregatesInput = {
    AND?: MediaFileScalarWhereWithAggregatesInput | MediaFileScalarWhereWithAggregatesInput[]
    OR?: MediaFileScalarWhereWithAggregatesInput[]
    NOT?: MediaFileScalarWhereWithAggregatesInput | MediaFileScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"MediaFile"> | number
    filename?: StringWithAggregatesFilter<"MediaFile"> | string
    originalName?: StringWithAggregatesFilter<"MediaFile"> | string
    mimeType?: StringWithAggregatesFilter<"MediaFile"> | string
    size?: IntWithAggregatesFilter<"MediaFile"> | number
    url?: StringWithAggregatesFilter<"MediaFile"> | string
    thumbnail?: StringNullableWithAggregatesFilter<"MediaFile"> | string | null
    userId?: IntWithAggregatesFilter<"MediaFile"> | number
    appId?: IntNullableWithAggregatesFilter<"MediaFile"> | number | null
    metadata?: JsonWithAggregatesFilter<"MediaFile">
    createdAt?: DateTimeWithAggregatesFilter<"MediaFile"> | Date | string
  }

  export type UserCreateInput = {
    email: string
    password: string
    createdAt?: Date | string
    role?: string
    updatedAt?: Date | string
    verified?: boolean
    apps?: AppCreateNestedManyWithoutOwnerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    canvasHistory?: CanvasHistoryCreateNestedManyWithoutUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    createdAt?: Date | string
    role?: string
    updatedAt?: Date | string
    verified?: boolean
    apps?: AppUncheckedCreateNestedManyWithoutOwnerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    canvasHistory?: CanvasHistoryUncheckedCreateNestedManyWithoutUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    apps?: AppUpdateManyWithoutOwnerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    canvasHistory?: CanvasHistoryUpdateManyWithoutUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    apps?: AppUncheckedUpdateManyWithoutOwnerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    canvasHistory?: CanvasHistoryUncheckedUpdateManyWithoutUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    createdAt?: Date | string
    role?: string
    updatedAt?: Date | string
    verified?: boolean
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
  }

  export type AppCreateInput = {
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutAppsInput
    template?: TemplateCreateNestedOneWithoutAppsInput
    components?: ComponentCreateNestedManyWithoutAppInput
    workflows?: WorkflowCreateNestedManyWithoutAppInput
    schemas?: AppSchemaCreateNestedManyWithoutAppInput
    metrics?: AppMetricCreateNestedManyWithoutAppInput
    issues?: AppIssueCreateNestedManyWithoutAppInput
    warnings?: AppWarningCreateNestedManyWithoutAppInput
    canvas?: CanvasCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileCreateNestedManyWithoutAppInput
  }

  export type AppUncheckedCreateInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    ownerId: number
    templateId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ComponentUncheckedCreateNestedManyWithoutAppInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAppInput
    schemas?: AppSchemaUncheckedCreateNestedManyWithoutAppInput
    metrics?: AppMetricUncheckedCreateNestedManyWithoutAppInput
    issues?: AppIssueUncheckedCreateNestedManyWithoutAppInput
    warnings?: AppWarningUncheckedCreateNestedManyWithoutAppInput
    canvas?: CanvasUncheckedCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutAppInput
  }

  export type AppUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutAppsNestedInput
    template?: TemplateUpdateOneWithoutAppsNestedInput
    components?: ComponentUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUpdateManyWithoutAppNestedInput
    issues?: AppIssueUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUpdateManyWithoutAppNestedInput
    canvas?: CanvasUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutAppNestedInput
  }

  export type AppUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ComponentUncheckedUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUncheckedUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUncheckedUpdateManyWithoutAppNestedInput
    issues?: AppIssueUncheckedUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUncheckedUpdateManyWithoutAppNestedInput
    canvas?: CanvasUncheckedUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutAppNestedInput
  }

  export type AppCreateManyInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    ownerId: number
    templateId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateCreateInput = {
    name: string
    description: string
    preview_image?: string | null
    app_schema: JsonNullValueInput | InputJsonValue
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apps?: AppCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUncheckedCreateInput = {
    id?: number
    name: string
    description: string
    preview_image?: string | null
    app_schema: JsonNullValueInput | InputJsonValue
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    apps?: AppUncheckedCreateNestedManyWithoutTemplateInput
  }

  export type TemplateUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    preview_image?: NullableStringFieldUpdateOperationsInput | string | null
    app_schema?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apps?: AppUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    preview_image?: NullableStringFieldUpdateOperationsInput | string | null
    app_schema?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    apps?: AppUncheckedUpdateManyWithoutTemplateNestedInput
  }

  export type TemplateCreateManyInput = {
    id?: number
    name: string
    description: string
    preview_image?: string | null
    app_schema: JsonNullValueInput | InputJsonValue
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    preview_image?: NullableStringFieldUpdateOperationsInput | string | null
    app_schema?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    preview_image?: NullableStringFieldUpdateOperationsInput | string | null
    app_schema?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentCreateInput = {
    name: string
    type: string
    properties: JsonNullValueInput | InputJsonValue
    app: AppCreateNestedOneWithoutComponentsInput
  }

  export type ComponentUncheckedCreateInput = {
    id?: number
    name: string
    type: string
    appId: number
    properties: JsonNullValueInput | InputJsonValue
  }

  export type ComponentUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    properties?: JsonNullValueInput | InputJsonValue
    app?: AppUpdateOneRequiredWithoutComponentsNestedInput
  }

  export type ComponentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    appId?: IntFieldUpdateOperationsInput | number
    properties?: JsonNullValueInput | InputJsonValue
  }

  export type ComponentCreateManyInput = {
    id?: number
    name: string
    type: string
    appId: number
    properties: JsonNullValueInput | InputJsonValue
  }

  export type ComponentUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    properties?: JsonNullValueInput | InputJsonValue
  }

  export type ComponentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    appId?: IntFieldUpdateOperationsInput | number
    properties?: JsonNullValueInput | InputJsonValue
  }

  export type WorkflowCreateInput = {
    name: string
    steps: JsonNullValueInput | InputJsonValue
    app: AppCreateNestedOneWithoutWorkflowsInput
  }

  export type WorkflowUncheckedCreateInput = {
    id?: number
    name: string
    appId: number
    steps: JsonNullValueInput | InputJsonValue
  }

  export type WorkflowUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    steps?: JsonNullValueInput | InputJsonValue
    app?: AppUpdateOneRequiredWithoutWorkflowsNestedInput
  }

  export type WorkflowUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    appId?: IntFieldUpdateOperationsInput | number
    steps?: JsonNullValueInput | InputJsonValue
  }

  export type WorkflowCreateManyInput = {
    id?: number
    name: string
    appId: number
    steps: JsonNullValueInput | InputJsonValue
  }

  export type WorkflowUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    steps?: JsonNullValueInput | InputJsonValue
  }

  export type WorkflowUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    appId?: IntFieldUpdateOperationsInput | number
    steps?: JsonNullValueInput | InputJsonValue
  }

  export type OtpCreateInput = {
    email: string
    otp: string
    type: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type OtpUncheckedCreateInput = {
    id?: number
    email: string
    otp: string
    type: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type OtpUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpCreateManyInput = {
    id?: number
    email: string
    otp: string
    type: string
    expiresAt: Date | string
    used?: boolean
    createdAt?: Date | string
  }

  export type OtpUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OtpUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    otp?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    used?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppSchemaCreateInput = {
    name: string
    createdAt?: Date | string
    data?: AppDataCreateNestedManyWithoutSchemaInput
    relatedFields?: AppFieldCreateNestedManyWithoutRelatedSchemaInput
    fields?: AppFieldCreateNestedManyWithoutSchemaInput
    app: AppCreateNestedOneWithoutSchemasInput
  }

  export type AppSchemaUncheckedCreateInput = {
    id?: number
    appId: number
    name: string
    createdAt?: Date | string
    data?: AppDataUncheckedCreateNestedManyWithoutSchemaInput
    relatedFields?: AppFieldUncheckedCreateNestedManyWithoutRelatedSchemaInput
    fields?: AppFieldUncheckedCreateNestedManyWithoutSchemaInput
  }

  export type AppSchemaUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: AppDataUpdateManyWithoutSchemaNestedInput
    relatedFields?: AppFieldUpdateManyWithoutRelatedSchemaNestedInput
    fields?: AppFieldUpdateManyWithoutSchemaNestedInput
    app?: AppUpdateOneRequiredWithoutSchemasNestedInput
  }

  export type AppSchemaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    appId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: AppDataUncheckedUpdateManyWithoutSchemaNestedInput
    relatedFields?: AppFieldUncheckedUpdateManyWithoutRelatedSchemaNestedInput
    fields?: AppFieldUncheckedUpdateManyWithoutSchemaNestedInput
  }

  export type AppSchemaCreateManyInput = {
    id?: number
    appId: number
    name: string
    createdAt?: Date | string
  }

  export type AppSchemaUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppSchemaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    appId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppFieldCreateInput = {
    name: string
    type: $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    relatedSchema?: AppSchemaCreateNestedOneWithoutRelatedFieldsInput
    schema: AppSchemaCreateNestedOneWithoutFieldsInput
  }

  export type AppFieldUncheckedCreateInput = {
    id?: number
    schemaId: number
    name: string
    type: $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    relatedSchemaId?: number | null
    createdAt?: Date | string
  }

  export type AppFieldUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedSchema?: AppSchemaUpdateOneWithoutRelatedFieldsNestedInput
    schema?: AppSchemaUpdateOneRequiredWithoutFieldsNestedInput
  }

  export type AppFieldUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    schemaId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    relatedSchemaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppFieldCreateManyInput = {
    id?: number
    schemaId: number
    name: string
    type: $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    relatedSchemaId?: number | null
    createdAt?: Date | string
  }

  export type AppFieldUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppFieldUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    schemaId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    relatedSchemaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppDataCreateInput = {
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    schema: AppSchemaCreateNestedOneWithoutDataInput
  }

  export type AppDataUncheckedCreateInput = {
    id?: number
    schemaId: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AppDataUpdateInput = {
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schema?: AppSchemaUpdateOneRequiredWithoutDataNestedInput
  }

  export type AppDataUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    schemaId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppDataCreateManyInput = {
    id?: number
    schemaId: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AppDataUpdateManyMutationInput = {
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppDataUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    schemaId?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateInput = {
    title: string
    url: string
    category: string
    createdAt?: Date | string
  }

  export type VideoUncheckedCreateInput = {
    id?: number
    title: string
    url: string
    category: string
    createdAt?: Date | string
  }

  export type VideoUpdateInput = {
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoCreateManyInput = {
    id?: number
    title: string
    url: string
    category: string
    createdAt?: Date | string
  }

  export type VideoUpdateManyMutationInput = {
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VideoUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    url?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppMetricCreateInput = {
    activeDays: number
    downtime: number
    totalUsers: number
    traffic: number
    createdAt?: Date | string
    app: AppCreateNestedOneWithoutMetricsInput
  }

  export type AppMetricUncheckedCreateInput = {
    id?: number
    appId: number
    activeDays: number
    downtime: number
    totalUsers: number
    traffic: number
    createdAt?: Date | string
  }

  export type AppMetricUpdateInput = {
    activeDays?: IntFieldUpdateOperationsInput | number
    downtime?: FloatFieldUpdateOperationsInput | number
    totalUsers?: IntFieldUpdateOperationsInput | number
    traffic?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    app?: AppUpdateOneRequiredWithoutMetricsNestedInput
  }

  export type AppMetricUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    appId?: IntFieldUpdateOperationsInput | number
    activeDays?: IntFieldUpdateOperationsInput | number
    downtime?: FloatFieldUpdateOperationsInput | number
    totalUsers?: IntFieldUpdateOperationsInput | number
    traffic?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppMetricCreateManyInput = {
    id?: number
    appId: number
    activeDays: number
    downtime: number
    totalUsers: number
    traffic: number
    createdAt?: Date | string
  }

  export type AppMetricUpdateManyMutationInput = {
    activeDays?: IntFieldUpdateOperationsInput | number
    downtime?: FloatFieldUpdateOperationsInput | number
    totalUsers?: IntFieldUpdateOperationsInput | number
    traffic?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppMetricUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    appId?: IntFieldUpdateOperationsInput | number
    activeDays?: IntFieldUpdateOperationsInput | number
    downtime?: FloatFieldUpdateOperationsInput | number
    totalUsers?: IntFieldUpdateOperationsInput | number
    traffic?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppIssueCreateInput = {
    severity: $Enums.IssueSeverity
    description: string
    status?: $Enums.IssueStatus
    createdAt?: Date | string
    app: AppCreateNestedOneWithoutIssuesInput
  }

  export type AppIssueUncheckedCreateInput = {
    id?: number
    appId: number
    severity: $Enums.IssueSeverity
    description: string
    status?: $Enums.IssueStatus
    createdAt?: Date | string
  }

  export type AppIssueUpdateInput = {
    severity?: EnumIssueSeverityFieldUpdateOperationsInput | $Enums.IssueSeverity
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    app?: AppUpdateOneRequiredWithoutIssuesNestedInput
  }

  export type AppIssueUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    appId?: IntFieldUpdateOperationsInput | number
    severity?: EnumIssueSeverityFieldUpdateOperationsInput | $Enums.IssueSeverity
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppIssueCreateManyInput = {
    id?: number
    appId: number
    severity: $Enums.IssueSeverity
    description: string
    status?: $Enums.IssueStatus
    createdAt?: Date | string
  }

  export type AppIssueUpdateManyMutationInput = {
    severity?: EnumIssueSeverityFieldUpdateOperationsInput | $Enums.IssueSeverity
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppIssueUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    appId?: IntFieldUpdateOperationsInput | number
    severity?: EnumIssueSeverityFieldUpdateOperationsInput | $Enums.IssueSeverity
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppWarningCreateInput = {
    message: string
    createdAt?: Date | string
    app: AppCreateNestedOneWithoutWarningsInput
  }

  export type AppWarningUncheckedCreateInput = {
    id?: number
    appId: number
    message: string
    createdAt?: Date | string
  }

  export type AppWarningUpdateInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    app?: AppUpdateOneRequiredWithoutWarningsNestedInput
  }

  export type AppWarningUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    appId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppWarningCreateManyInput = {
    id?: number
    appId: number
    message: string
    createdAt?: Date | string
  }

  export type AppWarningUpdateManyMutationInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppWarningUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    appId?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: number
    userId: number
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: number
    userId: number
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    userId?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistedTokenCreateInput = {
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type BlacklistedTokenUncheckedCreateInput = {
    id?: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type BlacklistedTokenUpdateInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistedTokenUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistedTokenCreateManyInput = {
    id?: number
    token: string
    createdAt?: Date | string
    expiresAt: Date | string
  }

  export type BlacklistedTokenUpdateManyMutationInput = {
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BlacklistedTokenUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasCreateInput = {
    name?: string
    description?: string | null
    width?: number
    height?: number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: boolean
    snapEnabled?: boolean
    zoomLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    app: AppCreateNestedOneWithoutCanvasInput
    elements?: CanvasElementCreateNestedManyWithoutCanvasInput
    history?: CanvasHistoryCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUncheckedCreateInput = {
    id?: number
    appId: number
    name?: string
    description?: string | null
    width?: number
    height?: number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: boolean
    snapEnabled?: boolean
    zoomLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    elements?: CanvasElementUncheckedCreateNestedManyWithoutCanvasInput
    history?: CanvasHistoryUncheckedCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    snapEnabled?: BoolFieldUpdateOperationsInput | boolean
    zoomLevel?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    app?: AppUpdateOneRequiredWithoutCanvasNestedInput
    elements?: CanvasElementUpdateManyWithoutCanvasNestedInput
    history?: CanvasHistoryUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    appId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    snapEnabled?: BoolFieldUpdateOperationsInput | boolean
    zoomLevel?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: CanvasElementUncheckedUpdateManyWithoutCanvasNestedInput
    history?: CanvasHistoryUncheckedUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasCreateManyInput = {
    id?: number
    appId: number
    name?: string
    description?: string | null
    width?: number
    height?: number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: boolean
    snapEnabled?: boolean
    zoomLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CanvasUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    snapEnabled?: BoolFieldUpdateOperationsInput | boolean
    zoomLevel?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    appId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    snapEnabled?: BoolFieldUpdateOperationsInput | boolean
    zoomLevel?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasElementCreateInput = {
    elementId: string
    type: $Enums.ElementType
    name?: string
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    zIndex?: number
    locked?: boolean
    visible?: boolean
    groupId?: string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutElementsInput
    parent?: CanvasElementCreateNestedOneWithoutChildrenInput
    children?: CanvasElementCreateNestedManyWithoutParentInput
    interactions?: ElementInteractionCreateNestedManyWithoutElementInput
    validations?: ElementValidationCreateNestedManyWithoutElementInput
  }

  export type CanvasElementUncheckedCreateInput = {
    id?: number
    canvasId: number
    elementId: string
    type: $Enums.ElementType
    name?: string
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    zIndex?: number
    locked?: boolean
    visible?: boolean
    groupId?: string | null
    parentId?: number | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CanvasElementUncheckedCreateNestedManyWithoutParentInput
    interactions?: ElementInteractionUncheckedCreateNestedManyWithoutElementInput
    validations?: ElementValidationUncheckedCreateNestedManyWithoutElementInput
  }

  export type CanvasElementUpdateInput = {
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutElementsNestedInput
    parent?: CanvasElementUpdateOneWithoutChildrenNestedInput
    children?: CanvasElementUpdateManyWithoutParentNestedInput
    interactions?: ElementInteractionUpdateManyWithoutElementNestedInput
    validations?: ElementValidationUpdateManyWithoutElementNestedInput
  }

  export type CanvasElementUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    canvasId?: IntFieldUpdateOperationsInput | number
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CanvasElementUncheckedUpdateManyWithoutParentNestedInput
    interactions?: ElementInteractionUncheckedUpdateManyWithoutElementNestedInput
    validations?: ElementValidationUncheckedUpdateManyWithoutElementNestedInput
  }

  export type CanvasElementCreateManyInput = {
    id?: number
    canvasId: number
    elementId: string
    type: $Enums.ElementType
    name?: string
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    zIndex?: number
    locked?: boolean
    visible?: boolean
    groupId?: string | null
    parentId?: number | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CanvasElementUpdateManyMutationInput = {
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasElementUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    canvasId?: IntFieldUpdateOperationsInput | number
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementInteractionCreateInput = {
    event: string
    action: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    element: CanvasElementCreateNestedOneWithoutInteractionsInput
  }

  export type ElementInteractionUncheckedCreateInput = {
    id?: number
    elementId: number
    event: string
    action: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ElementInteractionUpdateInput = {
    event?: StringFieldUpdateOperationsInput | string
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    element?: CanvasElementUpdateOneRequiredWithoutInteractionsNestedInput
  }

  export type ElementInteractionUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    elementId?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementInteractionCreateManyInput = {
    id?: number
    elementId: number
    event: string
    action: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ElementInteractionUpdateManyMutationInput = {
    event?: StringFieldUpdateOperationsInput | string
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementInteractionUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    elementId?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementValidationCreateInput = {
    rule: string
    value: JsonNullValueInput | InputJsonValue
    message: string
    createdAt?: Date | string
    element: CanvasElementCreateNestedOneWithoutValidationsInput
  }

  export type ElementValidationUncheckedCreateInput = {
    id?: number
    elementId: number
    rule: string
    value: JsonNullValueInput | InputJsonValue
    message: string
    createdAt?: Date | string
  }

  export type ElementValidationUpdateInput = {
    rule?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    element?: CanvasElementUpdateOneRequiredWithoutValidationsNestedInput
  }

  export type ElementValidationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    elementId?: IntFieldUpdateOperationsInput | number
    rule?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementValidationCreateManyInput = {
    id?: number
    elementId: number
    rule: string
    value: JsonNullValueInput | InputJsonValue
    message: string
    createdAt?: Date | string
  }

  export type ElementValidationUpdateManyMutationInput = {
    rule?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementValidationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    elementId?: IntFieldUpdateOperationsInput | number
    rule?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasHistoryCreateInput = {
    action: string
    elementId?: string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutHistoryInput
    user: UserCreateNestedOneWithoutCanvasHistoryInput
  }

  export type CanvasHistoryUncheckedCreateInput = {
    id?: number
    canvasId: number
    action: string
    elementId?: string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    userId: number
    createdAt?: Date | string
  }

  export type CanvasHistoryUpdateInput = {
    action?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutHistoryNestedInput
    user?: UserUpdateOneRequiredWithoutCanvasHistoryNestedInput
  }

  export type CanvasHistoryUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    canvasId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasHistoryCreateManyInput = {
    id?: number
    canvasId: number
    action: string
    elementId?: string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    userId: number
    createdAt?: Date | string
  }

  export type CanvasHistoryUpdateManyMutationInput = {
    action?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasHistoryUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    canvasId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileCreateInput = {
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    thumbnail?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMediaFilesInput
    app?: AppCreateNestedOneWithoutMediaFilesInput
  }

  export type MediaFileUncheckedCreateInput = {
    id?: number
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    thumbnail?: string | null
    userId: number
    appId?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MediaFileUpdateInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMediaFilesNestedInput
    app?: AppUpdateOneWithoutMediaFilesNestedInput
  }

  export type MediaFileUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    appId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileCreateManyInput = {
    id?: number
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    thumbnail?: string | null
    userId: number
    appId?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MediaFileUpdateManyMutationInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    appId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type AppListRelationFilter = {
    every?: AppWhereInput
    some?: AppWhereInput
    none?: AppWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type CanvasHistoryListRelationFilter = {
    every?: CanvasHistoryWhereInput
    some?: CanvasHistoryWhereInput
    none?: CanvasHistoryWhereInput
  }

  export type MediaFileListRelationFilter = {
    every?: MediaFileWhereInput
    some?: MediaFileWhereInput
    none?: MediaFileWhereInput
  }

  export type AppOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CanvasHistoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MediaFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    verified?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    verified?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    role?: SortOrder
    updatedAt?: SortOrder
    verified?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumAppStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppStatus | EnumAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppStatusFilter<$PrismaModel> | $Enums.AppStatus
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TemplateNullableScalarRelationFilter = {
    is?: TemplateWhereInput | null
    isNot?: TemplateWhereInput | null
  }

  export type ComponentListRelationFilter = {
    every?: ComponentWhereInput
    some?: ComponentWhereInput
    none?: ComponentWhereInput
  }

  export type WorkflowListRelationFilter = {
    every?: WorkflowWhereInput
    some?: WorkflowWhereInput
    none?: WorkflowWhereInput
  }

  export type AppSchemaListRelationFilter = {
    every?: AppSchemaWhereInput
    some?: AppSchemaWhereInput
    none?: AppSchemaWhereInput
  }

  export type AppMetricListRelationFilter = {
    every?: AppMetricWhereInput
    some?: AppMetricWhereInput
    none?: AppMetricWhereInput
  }

  export type AppIssueListRelationFilter = {
    every?: AppIssueWhereInput
    some?: AppIssueWhereInput
    none?: AppIssueWhereInput
  }

  export type AppWarningListRelationFilter = {
    every?: AppWarningWhereInput
    some?: AppWarningWhereInput
    none?: AppWarningWhereInput
  }

  export type CanvasNullableScalarRelationFilter = {
    is?: CanvasWhereInput | null
    isNot?: CanvasWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ComponentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type WorkflowOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppSchemaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppMetricOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppIssueOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppWarningOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    ownerId?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppAvgOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    templateId?: SortOrder
  }

  export type AppMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    ownerId?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    status?: SortOrder
    archived?: SortOrder
    ownerId?: SortOrder
    templateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AppSumOrderByAggregateInput = {
    id?: SortOrder
    ownerId?: SortOrder
    templateId?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumAppStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppStatus | EnumAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppStatusFilter<$PrismaModel>
    _max?: NestedEnumAppStatusFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type TemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    preview_image?: SortOrder
    app_schema?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type TemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    preview_image?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    preview_image?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TemplateSumOrderByAggregateInput = {
    id?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type AppScalarRelationFilter = {
    is?: AppWhereInput
    isNot?: AppWhereInput
  }

  export type ComponentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    appId?: SortOrder
    properties?: SortOrder
  }

  export type ComponentAvgOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
  }

  export type ComponentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    appId?: SortOrder
  }

  export type ComponentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    type?: SortOrder
    appId?: SortOrder
  }

  export type ComponentSumOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
  }

  export type WorkflowCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    appId?: SortOrder
    steps?: SortOrder
  }

  export type WorkflowAvgOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
  }

  export type WorkflowMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    appId?: SortOrder
  }

  export type WorkflowMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    appId?: SortOrder
  }

  export type WorkflowSumOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
  }

  export type OtpCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OtpMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    otp?: SortOrder
    type?: SortOrder
    expiresAt?: SortOrder
    used?: SortOrder
    createdAt?: SortOrder
  }

  export type OtpSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AppDataListRelationFilter = {
    every?: AppDataWhereInput
    some?: AppDataWhereInput
    none?: AppDataWhereInput
  }

  export type AppFieldListRelationFilter = {
    every?: AppFieldWhereInput
    some?: AppFieldWhereInput
    none?: AppFieldWhereInput
  }

  export type AppDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AppSchemaCountOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type AppSchemaAvgOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
  }

  export type AppSchemaMaxOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type AppSchemaMinOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
  }

  export type AppSchemaSumOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
  }

  export type EnumFieldTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeFilter<$PrismaModel> | $Enums.FieldType
  }

  export type AppSchemaNullableScalarRelationFilter = {
    is?: AppSchemaWhereInput | null
    isNot?: AppSchemaWhereInput | null
  }

  export type AppSchemaScalarRelationFilter = {
    is?: AppSchemaWhereInput
    isNot?: AppSchemaWhereInput
  }

  export type AppFieldCountOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    constraints?: SortOrder
    relatedSchemaId?: SortOrder
    createdAt?: SortOrder
  }

  export type AppFieldAvgOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    relatedSchemaId?: SortOrder
  }

  export type AppFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    relatedSchemaId?: SortOrder
    createdAt?: SortOrder
  }

  export type AppFieldMinOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    name?: SortOrder
    type?: SortOrder
    relatedSchemaId?: SortOrder
    createdAt?: SortOrder
  }

  export type AppFieldSumOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    relatedSchemaId?: SortOrder
  }

  export type EnumFieldTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel> | $Enums.FieldType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldTypeFilter<$PrismaModel>
    _max?: NestedEnumFieldTypeFilter<$PrismaModel>
  }

  export type AppDataCountOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type AppDataAvgOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
  }

  export type AppDataMaxOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    createdAt?: SortOrder
  }

  export type AppDataMinOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
    createdAt?: SortOrder
  }

  export type AppDataSumOrderByAggregateInput = {
    id?: SortOrder
    schemaId?: SortOrder
  }

  export type VideoCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type VideoMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    url?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
  }

  export type VideoSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type AppMetricCountOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    activeDays?: SortOrder
    downtime?: SortOrder
    totalUsers?: SortOrder
    traffic?: SortOrder
    createdAt?: SortOrder
  }

  export type AppMetricAvgOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    activeDays?: SortOrder
    downtime?: SortOrder
    totalUsers?: SortOrder
    traffic?: SortOrder
  }

  export type AppMetricMaxOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    activeDays?: SortOrder
    downtime?: SortOrder
    totalUsers?: SortOrder
    traffic?: SortOrder
    createdAt?: SortOrder
  }

  export type AppMetricMinOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    activeDays?: SortOrder
    downtime?: SortOrder
    totalUsers?: SortOrder
    traffic?: SortOrder
    createdAt?: SortOrder
  }

  export type AppMetricSumOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    activeDays?: SortOrder
    downtime?: SortOrder
    totalUsers?: SortOrder
    traffic?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumIssueSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueSeverity | EnumIssueSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IssueSeverity[] | ListEnumIssueSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueSeverity[] | ListEnumIssueSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueSeverityFilter<$PrismaModel> | $Enums.IssueSeverity
  }

  export type EnumIssueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueStatus | EnumIssueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueStatusFilter<$PrismaModel> | $Enums.IssueStatus
  }

  export type AppIssueCountOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AppIssueAvgOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
  }

  export type AppIssueMaxOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AppIssueMinOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    severity?: SortOrder
    description?: SortOrder
    status?: SortOrder
    createdAt?: SortOrder
  }

  export type AppIssueSumOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
  }

  export type EnumIssueSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueSeverity | EnumIssueSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IssueSeverity[] | ListEnumIssueSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueSeverity[] | ListEnumIssueSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueSeverityWithAggregatesFilter<$PrismaModel> | $Enums.IssueSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIssueSeverityFilter<$PrismaModel>
    _max?: NestedEnumIssueSeverityFilter<$PrismaModel>
  }

  export type EnumIssueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueStatus | EnumIssueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueStatusWithAggregatesFilter<$PrismaModel> | $Enums.IssueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIssueStatusFilter<$PrismaModel>
    _max?: NestedEnumIssueStatusFilter<$PrismaModel>
  }

  export type AppWarningCountOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type AppWarningAvgOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
  }

  export type AppWarningMaxOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type AppWarningMinOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type AppWarningSumOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationAvgOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    message?: SortOrder
    read?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationSumOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
  }

  export type BlacklistedTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type BlacklistedTokenAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type BlacklistedTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type BlacklistedTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    createdAt?: SortOrder
    expiresAt?: SortOrder
  }

  export type BlacklistedTokenSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type CanvasElementListRelationFilter = {
    every?: CanvasElementWhereInput
    some?: CanvasElementWhereInput
    none?: CanvasElementWhereInput
  }

  export type CanvasElementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CanvasCountOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    width?: SortOrder
    height?: SortOrder
    background?: SortOrder
    gridEnabled?: SortOrder
    snapEnabled?: SortOrder
    zoomLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CanvasAvgOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    width?: SortOrder
    height?: SortOrder
    zoomLevel?: SortOrder
  }

  export type CanvasMaxOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    width?: SortOrder
    height?: SortOrder
    gridEnabled?: SortOrder
    snapEnabled?: SortOrder
    zoomLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CanvasMinOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    width?: SortOrder
    height?: SortOrder
    gridEnabled?: SortOrder
    snapEnabled?: SortOrder
    zoomLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CanvasSumOrderByAggregateInput = {
    id?: SortOrder
    appId?: SortOrder
    width?: SortOrder
    height?: SortOrder
    zoomLevel?: SortOrder
  }

  export type EnumElementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeFilter<$PrismaModel> | $Enums.ElementType
  }

  export type CanvasScalarRelationFilter = {
    is?: CanvasWhereInput
    isNot?: CanvasWhereInput
  }

  export type CanvasElementNullableScalarRelationFilter = {
    is?: CanvasElementWhereInput | null
    isNot?: CanvasElementWhereInput | null
  }

  export type ElementInteractionListRelationFilter = {
    every?: ElementInteractionWhereInput
    some?: ElementInteractionWhereInput
    none?: ElementInteractionWhereInput
  }

  export type ElementValidationListRelationFilter = {
    every?: ElementValidationWhereInput
    some?: ElementValidationWhereInput
    none?: ElementValidationWhereInput
  }

  export type ElementInteractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ElementValidationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CanvasElementCountOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    elementId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    zIndex?: SortOrder
    locked?: SortOrder
    visible?: SortOrder
    groupId?: SortOrder
    parentId?: SortOrder
    properties?: SortOrder
    styles?: SortOrder
    constraints?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CanvasElementAvgOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    zIndex?: SortOrder
    parentId?: SortOrder
  }

  export type CanvasElementMaxOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    elementId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    zIndex?: SortOrder
    locked?: SortOrder
    visible?: SortOrder
    groupId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CanvasElementMinOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    elementId?: SortOrder
    type?: SortOrder
    name?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    zIndex?: SortOrder
    locked?: SortOrder
    visible?: SortOrder
    groupId?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CanvasElementSumOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    x?: SortOrder
    y?: SortOrder
    width?: SortOrder
    height?: SortOrder
    rotation?: SortOrder
    zIndex?: SortOrder
    parentId?: SortOrder
  }

  export type EnumElementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeWithAggregatesFilter<$PrismaModel> | $Enums.ElementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumElementTypeFilter<$PrismaModel>
    _max?: NestedEnumElementTypeFilter<$PrismaModel>
  }

  export type CanvasElementScalarRelationFilter = {
    is?: CanvasElementWhereInput
    isNot?: CanvasElementWhereInput
  }

  export type ElementInteractionCountOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
    event?: SortOrder
    action?: SortOrder
    createdAt?: SortOrder
  }

  export type ElementInteractionAvgOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
  }

  export type ElementInteractionMaxOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
    event?: SortOrder
    createdAt?: SortOrder
  }

  export type ElementInteractionMinOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
    event?: SortOrder
    createdAt?: SortOrder
  }

  export type ElementInteractionSumOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
  }

  export type ElementValidationCountOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
    rule?: SortOrder
    value?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ElementValidationAvgOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
  }

  export type ElementValidationMaxOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
    rule?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ElementValidationMinOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
    rule?: SortOrder
    message?: SortOrder
    createdAt?: SortOrder
  }

  export type ElementValidationSumOrderByAggregateInput = {
    id?: SortOrder
    elementId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type CanvasHistoryCountOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    action?: SortOrder
    elementId?: SortOrder
    oldState?: SortOrder
    newState?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CanvasHistoryAvgOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
  }

  export type CanvasHistoryMaxOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    action?: SortOrder
    elementId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CanvasHistoryMinOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    action?: SortOrder
    elementId?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type CanvasHistorySumOrderByAggregateInput = {
    id?: SortOrder
    canvasId?: SortOrder
    userId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type AppNullableScalarRelationFilter = {
    is?: AppWhereInput | null
    isNot?: AppWhereInput | null
  }

  export type MediaFileCountOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    userId?: SortOrder
    appId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaFileAvgOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    userId?: SortOrder
    appId?: SortOrder
  }

  export type MediaFileMaxOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    userId?: SortOrder
    appId?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaFileMinOrderByAggregateInput = {
    id?: SortOrder
    filename?: SortOrder
    originalName?: SortOrder
    mimeType?: SortOrder
    size?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
    userId?: SortOrder
    appId?: SortOrder
    createdAt?: SortOrder
  }

  export type MediaFileSumOrderByAggregateInput = {
    id?: SortOrder
    size?: SortOrder
    userId?: SortOrder
    appId?: SortOrder
  }

  export type AppCreateNestedManyWithoutOwnerInput = {
    create?: XOR<AppCreateWithoutOwnerInput, AppUncheckedCreateWithoutOwnerInput> | AppCreateWithoutOwnerInput[] | AppUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AppCreateOrConnectWithoutOwnerInput | AppCreateOrConnectWithoutOwnerInput[]
    createMany?: AppCreateManyOwnerInputEnvelope
    connect?: AppWhereUniqueInput | AppWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CanvasHistoryCreateNestedManyWithoutUserInput = {
    create?: XOR<CanvasHistoryCreateWithoutUserInput, CanvasHistoryUncheckedCreateWithoutUserInput> | CanvasHistoryCreateWithoutUserInput[] | CanvasHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CanvasHistoryCreateOrConnectWithoutUserInput | CanvasHistoryCreateOrConnectWithoutUserInput[]
    createMany?: CanvasHistoryCreateManyUserInputEnvelope
    connect?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
  }

  export type MediaFileCreateNestedManyWithoutUserInput = {
    create?: XOR<MediaFileCreateWithoutUserInput, MediaFileUncheckedCreateWithoutUserInput> | MediaFileCreateWithoutUserInput[] | MediaFileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutUserInput | MediaFileCreateOrConnectWithoutUserInput[]
    createMany?: MediaFileCreateManyUserInputEnvelope
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
  }

  export type AppUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<AppCreateWithoutOwnerInput, AppUncheckedCreateWithoutOwnerInput> | AppCreateWithoutOwnerInput[] | AppUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AppCreateOrConnectWithoutOwnerInput | AppCreateOrConnectWithoutOwnerInput[]
    createMany?: AppCreateManyOwnerInputEnvelope
    connect?: AppWhereUniqueInput | AppWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type CanvasHistoryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CanvasHistoryCreateWithoutUserInput, CanvasHistoryUncheckedCreateWithoutUserInput> | CanvasHistoryCreateWithoutUserInput[] | CanvasHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CanvasHistoryCreateOrConnectWithoutUserInput | CanvasHistoryCreateOrConnectWithoutUserInput[]
    createMany?: CanvasHistoryCreateManyUserInputEnvelope
    connect?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
  }

  export type MediaFileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MediaFileCreateWithoutUserInput, MediaFileUncheckedCreateWithoutUserInput> | MediaFileCreateWithoutUserInput[] | MediaFileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutUserInput | MediaFileCreateOrConnectWithoutUserInput[]
    createMany?: MediaFileCreateManyUserInputEnvelope
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type AppUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<AppCreateWithoutOwnerInput, AppUncheckedCreateWithoutOwnerInput> | AppCreateWithoutOwnerInput[] | AppUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AppCreateOrConnectWithoutOwnerInput | AppCreateOrConnectWithoutOwnerInput[]
    upsert?: AppUpsertWithWhereUniqueWithoutOwnerInput | AppUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: AppCreateManyOwnerInputEnvelope
    set?: AppWhereUniqueInput | AppWhereUniqueInput[]
    disconnect?: AppWhereUniqueInput | AppWhereUniqueInput[]
    delete?: AppWhereUniqueInput | AppWhereUniqueInput[]
    connect?: AppWhereUniqueInput | AppWhereUniqueInput[]
    update?: AppUpdateWithWhereUniqueWithoutOwnerInput | AppUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: AppUpdateManyWithWhereWithoutOwnerInput | AppUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: AppScalarWhereInput | AppScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CanvasHistoryUpdateManyWithoutUserNestedInput = {
    create?: XOR<CanvasHistoryCreateWithoutUserInput, CanvasHistoryUncheckedCreateWithoutUserInput> | CanvasHistoryCreateWithoutUserInput[] | CanvasHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CanvasHistoryCreateOrConnectWithoutUserInput | CanvasHistoryCreateOrConnectWithoutUserInput[]
    upsert?: CanvasHistoryUpsertWithWhereUniqueWithoutUserInput | CanvasHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CanvasHistoryCreateManyUserInputEnvelope
    set?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    disconnect?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    delete?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    connect?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    update?: CanvasHistoryUpdateWithWhereUniqueWithoutUserInput | CanvasHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CanvasHistoryUpdateManyWithWhereWithoutUserInput | CanvasHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CanvasHistoryScalarWhereInput | CanvasHistoryScalarWhereInput[]
  }

  export type MediaFileUpdateManyWithoutUserNestedInput = {
    create?: XOR<MediaFileCreateWithoutUserInput, MediaFileUncheckedCreateWithoutUserInput> | MediaFileCreateWithoutUserInput[] | MediaFileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutUserInput | MediaFileCreateOrConnectWithoutUserInput[]
    upsert?: MediaFileUpsertWithWhereUniqueWithoutUserInput | MediaFileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MediaFileCreateManyUserInputEnvelope
    set?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    disconnect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    delete?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    update?: MediaFileUpdateWithWhereUniqueWithoutUserInput | MediaFileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MediaFileUpdateManyWithWhereWithoutUserInput | MediaFileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AppUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<AppCreateWithoutOwnerInput, AppUncheckedCreateWithoutOwnerInput> | AppCreateWithoutOwnerInput[] | AppUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: AppCreateOrConnectWithoutOwnerInput | AppCreateOrConnectWithoutOwnerInput[]
    upsert?: AppUpsertWithWhereUniqueWithoutOwnerInput | AppUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: AppCreateManyOwnerInputEnvelope
    set?: AppWhereUniqueInput | AppWhereUniqueInput[]
    disconnect?: AppWhereUniqueInput | AppWhereUniqueInput[]
    delete?: AppWhereUniqueInput | AppWhereUniqueInput[]
    connect?: AppWhereUniqueInput | AppWhereUniqueInput[]
    update?: AppUpdateWithWhereUniqueWithoutOwnerInput | AppUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: AppUpdateManyWithWhereWithoutOwnerInput | AppUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: AppScalarWhereInput | AppScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type CanvasHistoryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CanvasHistoryCreateWithoutUserInput, CanvasHistoryUncheckedCreateWithoutUserInput> | CanvasHistoryCreateWithoutUserInput[] | CanvasHistoryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CanvasHistoryCreateOrConnectWithoutUserInput | CanvasHistoryCreateOrConnectWithoutUserInput[]
    upsert?: CanvasHistoryUpsertWithWhereUniqueWithoutUserInput | CanvasHistoryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CanvasHistoryCreateManyUserInputEnvelope
    set?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    disconnect?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    delete?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    connect?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    update?: CanvasHistoryUpdateWithWhereUniqueWithoutUserInput | CanvasHistoryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CanvasHistoryUpdateManyWithWhereWithoutUserInput | CanvasHistoryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CanvasHistoryScalarWhereInput | CanvasHistoryScalarWhereInput[]
  }

  export type MediaFileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MediaFileCreateWithoutUserInput, MediaFileUncheckedCreateWithoutUserInput> | MediaFileCreateWithoutUserInput[] | MediaFileUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutUserInput | MediaFileCreateOrConnectWithoutUserInput[]
    upsert?: MediaFileUpsertWithWhereUniqueWithoutUserInput | MediaFileUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MediaFileCreateManyUserInputEnvelope
    set?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    disconnect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    delete?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    update?: MediaFileUpdateWithWhereUniqueWithoutUserInput | MediaFileUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MediaFileUpdateManyWithWhereWithoutUserInput | MediaFileUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAppsInput = {
    create?: XOR<UserCreateWithoutAppsInput, UserUncheckedCreateWithoutAppsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppsInput
    connect?: UserWhereUniqueInput
  }

  export type TemplateCreateNestedOneWithoutAppsInput = {
    create?: XOR<TemplateCreateWithoutAppsInput, TemplateUncheckedCreateWithoutAppsInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutAppsInput
    connect?: TemplateWhereUniqueInput
  }

  export type ComponentCreateNestedManyWithoutAppInput = {
    create?: XOR<ComponentCreateWithoutAppInput, ComponentUncheckedCreateWithoutAppInput> | ComponentCreateWithoutAppInput[] | ComponentUncheckedCreateWithoutAppInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutAppInput | ComponentCreateOrConnectWithoutAppInput[]
    createMany?: ComponentCreateManyAppInputEnvelope
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
  }

  export type WorkflowCreateNestedManyWithoutAppInput = {
    create?: XOR<WorkflowCreateWithoutAppInput, WorkflowUncheckedCreateWithoutAppInput> | WorkflowCreateWithoutAppInput[] | WorkflowUncheckedCreateWithoutAppInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAppInput | WorkflowCreateOrConnectWithoutAppInput[]
    createMany?: WorkflowCreateManyAppInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type AppSchemaCreateNestedManyWithoutAppInput = {
    create?: XOR<AppSchemaCreateWithoutAppInput, AppSchemaUncheckedCreateWithoutAppInput> | AppSchemaCreateWithoutAppInput[] | AppSchemaUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppSchemaCreateOrConnectWithoutAppInput | AppSchemaCreateOrConnectWithoutAppInput[]
    createMany?: AppSchemaCreateManyAppInputEnvelope
    connect?: AppSchemaWhereUniqueInput | AppSchemaWhereUniqueInput[]
  }

  export type AppMetricCreateNestedManyWithoutAppInput = {
    create?: XOR<AppMetricCreateWithoutAppInput, AppMetricUncheckedCreateWithoutAppInput> | AppMetricCreateWithoutAppInput[] | AppMetricUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppMetricCreateOrConnectWithoutAppInput | AppMetricCreateOrConnectWithoutAppInput[]
    createMany?: AppMetricCreateManyAppInputEnvelope
    connect?: AppMetricWhereUniqueInput | AppMetricWhereUniqueInput[]
  }

  export type AppIssueCreateNestedManyWithoutAppInput = {
    create?: XOR<AppIssueCreateWithoutAppInput, AppIssueUncheckedCreateWithoutAppInput> | AppIssueCreateWithoutAppInput[] | AppIssueUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppIssueCreateOrConnectWithoutAppInput | AppIssueCreateOrConnectWithoutAppInput[]
    createMany?: AppIssueCreateManyAppInputEnvelope
    connect?: AppIssueWhereUniqueInput | AppIssueWhereUniqueInput[]
  }

  export type AppWarningCreateNestedManyWithoutAppInput = {
    create?: XOR<AppWarningCreateWithoutAppInput, AppWarningUncheckedCreateWithoutAppInput> | AppWarningCreateWithoutAppInput[] | AppWarningUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppWarningCreateOrConnectWithoutAppInput | AppWarningCreateOrConnectWithoutAppInput[]
    createMany?: AppWarningCreateManyAppInputEnvelope
    connect?: AppWarningWhereUniqueInput | AppWarningWhereUniqueInput[]
  }

  export type CanvasCreateNestedOneWithoutAppInput = {
    create?: XOR<CanvasCreateWithoutAppInput, CanvasUncheckedCreateWithoutAppInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutAppInput
    connect?: CanvasWhereUniqueInput
  }

  export type MediaFileCreateNestedManyWithoutAppInput = {
    create?: XOR<MediaFileCreateWithoutAppInput, MediaFileUncheckedCreateWithoutAppInput> | MediaFileCreateWithoutAppInput[] | MediaFileUncheckedCreateWithoutAppInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutAppInput | MediaFileCreateOrConnectWithoutAppInput[]
    createMany?: MediaFileCreateManyAppInputEnvelope
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
  }

  export type ComponentUncheckedCreateNestedManyWithoutAppInput = {
    create?: XOR<ComponentCreateWithoutAppInput, ComponentUncheckedCreateWithoutAppInput> | ComponentCreateWithoutAppInput[] | ComponentUncheckedCreateWithoutAppInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutAppInput | ComponentCreateOrConnectWithoutAppInput[]
    createMany?: ComponentCreateManyAppInputEnvelope
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
  }

  export type WorkflowUncheckedCreateNestedManyWithoutAppInput = {
    create?: XOR<WorkflowCreateWithoutAppInput, WorkflowUncheckedCreateWithoutAppInput> | WorkflowCreateWithoutAppInput[] | WorkflowUncheckedCreateWithoutAppInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAppInput | WorkflowCreateOrConnectWithoutAppInput[]
    createMany?: WorkflowCreateManyAppInputEnvelope
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
  }

  export type AppSchemaUncheckedCreateNestedManyWithoutAppInput = {
    create?: XOR<AppSchemaCreateWithoutAppInput, AppSchemaUncheckedCreateWithoutAppInput> | AppSchemaCreateWithoutAppInput[] | AppSchemaUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppSchemaCreateOrConnectWithoutAppInput | AppSchemaCreateOrConnectWithoutAppInput[]
    createMany?: AppSchemaCreateManyAppInputEnvelope
    connect?: AppSchemaWhereUniqueInput | AppSchemaWhereUniqueInput[]
  }

  export type AppMetricUncheckedCreateNestedManyWithoutAppInput = {
    create?: XOR<AppMetricCreateWithoutAppInput, AppMetricUncheckedCreateWithoutAppInput> | AppMetricCreateWithoutAppInput[] | AppMetricUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppMetricCreateOrConnectWithoutAppInput | AppMetricCreateOrConnectWithoutAppInput[]
    createMany?: AppMetricCreateManyAppInputEnvelope
    connect?: AppMetricWhereUniqueInput | AppMetricWhereUniqueInput[]
  }

  export type AppIssueUncheckedCreateNestedManyWithoutAppInput = {
    create?: XOR<AppIssueCreateWithoutAppInput, AppIssueUncheckedCreateWithoutAppInput> | AppIssueCreateWithoutAppInput[] | AppIssueUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppIssueCreateOrConnectWithoutAppInput | AppIssueCreateOrConnectWithoutAppInput[]
    createMany?: AppIssueCreateManyAppInputEnvelope
    connect?: AppIssueWhereUniqueInput | AppIssueWhereUniqueInput[]
  }

  export type AppWarningUncheckedCreateNestedManyWithoutAppInput = {
    create?: XOR<AppWarningCreateWithoutAppInput, AppWarningUncheckedCreateWithoutAppInput> | AppWarningCreateWithoutAppInput[] | AppWarningUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppWarningCreateOrConnectWithoutAppInput | AppWarningCreateOrConnectWithoutAppInput[]
    createMany?: AppWarningCreateManyAppInputEnvelope
    connect?: AppWarningWhereUniqueInput | AppWarningWhereUniqueInput[]
  }

  export type CanvasUncheckedCreateNestedOneWithoutAppInput = {
    create?: XOR<CanvasCreateWithoutAppInput, CanvasUncheckedCreateWithoutAppInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutAppInput
    connect?: CanvasWhereUniqueInput
  }

  export type MediaFileUncheckedCreateNestedManyWithoutAppInput = {
    create?: XOR<MediaFileCreateWithoutAppInput, MediaFileUncheckedCreateWithoutAppInput> | MediaFileCreateWithoutAppInput[] | MediaFileUncheckedCreateWithoutAppInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutAppInput | MediaFileCreateOrConnectWithoutAppInput[]
    createMany?: MediaFileCreateManyAppInputEnvelope
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumAppStatusFieldUpdateOperationsInput = {
    set?: $Enums.AppStatus
  }

  export type UserUpdateOneRequiredWithoutAppsNestedInput = {
    create?: XOR<UserCreateWithoutAppsInput, UserUncheckedCreateWithoutAppsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAppsInput
    upsert?: UserUpsertWithoutAppsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAppsInput, UserUpdateWithoutAppsInput>, UserUncheckedUpdateWithoutAppsInput>
  }

  export type TemplateUpdateOneWithoutAppsNestedInput = {
    create?: XOR<TemplateCreateWithoutAppsInput, TemplateUncheckedCreateWithoutAppsInput>
    connectOrCreate?: TemplateCreateOrConnectWithoutAppsInput
    upsert?: TemplateUpsertWithoutAppsInput
    disconnect?: TemplateWhereInput | boolean
    delete?: TemplateWhereInput | boolean
    connect?: TemplateWhereUniqueInput
    update?: XOR<XOR<TemplateUpdateToOneWithWhereWithoutAppsInput, TemplateUpdateWithoutAppsInput>, TemplateUncheckedUpdateWithoutAppsInput>
  }

  export type ComponentUpdateManyWithoutAppNestedInput = {
    create?: XOR<ComponentCreateWithoutAppInput, ComponentUncheckedCreateWithoutAppInput> | ComponentCreateWithoutAppInput[] | ComponentUncheckedCreateWithoutAppInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutAppInput | ComponentCreateOrConnectWithoutAppInput[]
    upsert?: ComponentUpsertWithWhereUniqueWithoutAppInput | ComponentUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: ComponentCreateManyAppInputEnvelope
    set?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    disconnect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    delete?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    update?: ComponentUpdateWithWhereUniqueWithoutAppInput | ComponentUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: ComponentUpdateManyWithWhereWithoutAppInput | ComponentUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
  }

  export type WorkflowUpdateManyWithoutAppNestedInput = {
    create?: XOR<WorkflowCreateWithoutAppInput, WorkflowUncheckedCreateWithoutAppInput> | WorkflowCreateWithoutAppInput[] | WorkflowUncheckedCreateWithoutAppInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAppInput | WorkflowCreateOrConnectWithoutAppInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutAppInput | WorkflowUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: WorkflowCreateManyAppInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutAppInput | WorkflowUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutAppInput | WorkflowUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type AppSchemaUpdateManyWithoutAppNestedInput = {
    create?: XOR<AppSchemaCreateWithoutAppInput, AppSchemaUncheckedCreateWithoutAppInput> | AppSchemaCreateWithoutAppInput[] | AppSchemaUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppSchemaCreateOrConnectWithoutAppInput | AppSchemaCreateOrConnectWithoutAppInput[]
    upsert?: AppSchemaUpsertWithWhereUniqueWithoutAppInput | AppSchemaUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: AppSchemaCreateManyAppInputEnvelope
    set?: AppSchemaWhereUniqueInput | AppSchemaWhereUniqueInput[]
    disconnect?: AppSchemaWhereUniqueInput | AppSchemaWhereUniqueInput[]
    delete?: AppSchemaWhereUniqueInput | AppSchemaWhereUniqueInput[]
    connect?: AppSchemaWhereUniqueInput | AppSchemaWhereUniqueInput[]
    update?: AppSchemaUpdateWithWhereUniqueWithoutAppInput | AppSchemaUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: AppSchemaUpdateManyWithWhereWithoutAppInput | AppSchemaUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: AppSchemaScalarWhereInput | AppSchemaScalarWhereInput[]
  }

  export type AppMetricUpdateManyWithoutAppNestedInput = {
    create?: XOR<AppMetricCreateWithoutAppInput, AppMetricUncheckedCreateWithoutAppInput> | AppMetricCreateWithoutAppInput[] | AppMetricUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppMetricCreateOrConnectWithoutAppInput | AppMetricCreateOrConnectWithoutAppInput[]
    upsert?: AppMetricUpsertWithWhereUniqueWithoutAppInput | AppMetricUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: AppMetricCreateManyAppInputEnvelope
    set?: AppMetricWhereUniqueInput | AppMetricWhereUniqueInput[]
    disconnect?: AppMetricWhereUniqueInput | AppMetricWhereUniqueInput[]
    delete?: AppMetricWhereUniqueInput | AppMetricWhereUniqueInput[]
    connect?: AppMetricWhereUniqueInput | AppMetricWhereUniqueInput[]
    update?: AppMetricUpdateWithWhereUniqueWithoutAppInput | AppMetricUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: AppMetricUpdateManyWithWhereWithoutAppInput | AppMetricUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: AppMetricScalarWhereInput | AppMetricScalarWhereInput[]
  }

  export type AppIssueUpdateManyWithoutAppNestedInput = {
    create?: XOR<AppIssueCreateWithoutAppInput, AppIssueUncheckedCreateWithoutAppInput> | AppIssueCreateWithoutAppInput[] | AppIssueUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppIssueCreateOrConnectWithoutAppInput | AppIssueCreateOrConnectWithoutAppInput[]
    upsert?: AppIssueUpsertWithWhereUniqueWithoutAppInput | AppIssueUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: AppIssueCreateManyAppInputEnvelope
    set?: AppIssueWhereUniqueInput | AppIssueWhereUniqueInput[]
    disconnect?: AppIssueWhereUniqueInput | AppIssueWhereUniqueInput[]
    delete?: AppIssueWhereUniqueInput | AppIssueWhereUniqueInput[]
    connect?: AppIssueWhereUniqueInput | AppIssueWhereUniqueInput[]
    update?: AppIssueUpdateWithWhereUniqueWithoutAppInput | AppIssueUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: AppIssueUpdateManyWithWhereWithoutAppInput | AppIssueUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: AppIssueScalarWhereInput | AppIssueScalarWhereInput[]
  }

  export type AppWarningUpdateManyWithoutAppNestedInput = {
    create?: XOR<AppWarningCreateWithoutAppInput, AppWarningUncheckedCreateWithoutAppInput> | AppWarningCreateWithoutAppInput[] | AppWarningUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppWarningCreateOrConnectWithoutAppInput | AppWarningCreateOrConnectWithoutAppInput[]
    upsert?: AppWarningUpsertWithWhereUniqueWithoutAppInput | AppWarningUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: AppWarningCreateManyAppInputEnvelope
    set?: AppWarningWhereUniqueInput | AppWarningWhereUniqueInput[]
    disconnect?: AppWarningWhereUniqueInput | AppWarningWhereUniqueInput[]
    delete?: AppWarningWhereUniqueInput | AppWarningWhereUniqueInput[]
    connect?: AppWarningWhereUniqueInput | AppWarningWhereUniqueInput[]
    update?: AppWarningUpdateWithWhereUniqueWithoutAppInput | AppWarningUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: AppWarningUpdateManyWithWhereWithoutAppInput | AppWarningUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: AppWarningScalarWhereInput | AppWarningScalarWhereInput[]
  }

  export type CanvasUpdateOneWithoutAppNestedInput = {
    create?: XOR<CanvasCreateWithoutAppInput, CanvasUncheckedCreateWithoutAppInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutAppInput
    upsert?: CanvasUpsertWithoutAppInput
    disconnect?: CanvasWhereInput | boolean
    delete?: CanvasWhereInput | boolean
    connect?: CanvasWhereUniqueInput
    update?: XOR<XOR<CanvasUpdateToOneWithWhereWithoutAppInput, CanvasUpdateWithoutAppInput>, CanvasUncheckedUpdateWithoutAppInput>
  }

  export type MediaFileUpdateManyWithoutAppNestedInput = {
    create?: XOR<MediaFileCreateWithoutAppInput, MediaFileUncheckedCreateWithoutAppInput> | MediaFileCreateWithoutAppInput[] | MediaFileUncheckedCreateWithoutAppInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutAppInput | MediaFileCreateOrConnectWithoutAppInput[]
    upsert?: MediaFileUpsertWithWhereUniqueWithoutAppInput | MediaFileUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: MediaFileCreateManyAppInputEnvelope
    set?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    disconnect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    delete?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    update?: MediaFileUpdateWithWhereUniqueWithoutAppInput | MediaFileUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: MediaFileUpdateManyWithWhereWithoutAppInput | MediaFileUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ComponentUncheckedUpdateManyWithoutAppNestedInput = {
    create?: XOR<ComponentCreateWithoutAppInput, ComponentUncheckedCreateWithoutAppInput> | ComponentCreateWithoutAppInput[] | ComponentUncheckedCreateWithoutAppInput[]
    connectOrCreate?: ComponentCreateOrConnectWithoutAppInput | ComponentCreateOrConnectWithoutAppInput[]
    upsert?: ComponentUpsertWithWhereUniqueWithoutAppInput | ComponentUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: ComponentCreateManyAppInputEnvelope
    set?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    disconnect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    delete?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    connect?: ComponentWhereUniqueInput | ComponentWhereUniqueInput[]
    update?: ComponentUpdateWithWhereUniqueWithoutAppInput | ComponentUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: ComponentUpdateManyWithWhereWithoutAppInput | ComponentUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
  }

  export type WorkflowUncheckedUpdateManyWithoutAppNestedInput = {
    create?: XOR<WorkflowCreateWithoutAppInput, WorkflowUncheckedCreateWithoutAppInput> | WorkflowCreateWithoutAppInput[] | WorkflowUncheckedCreateWithoutAppInput[]
    connectOrCreate?: WorkflowCreateOrConnectWithoutAppInput | WorkflowCreateOrConnectWithoutAppInput[]
    upsert?: WorkflowUpsertWithWhereUniqueWithoutAppInput | WorkflowUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: WorkflowCreateManyAppInputEnvelope
    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]
    update?: WorkflowUpdateWithWhereUniqueWithoutAppInput | WorkflowUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: WorkflowUpdateManyWithWhereWithoutAppInput | WorkflowUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
  }

  export type AppSchemaUncheckedUpdateManyWithoutAppNestedInput = {
    create?: XOR<AppSchemaCreateWithoutAppInput, AppSchemaUncheckedCreateWithoutAppInput> | AppSchemaCreateWithoutAppInput[] | AppSchemaUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppSchemaCreateOrConnectWithoutAppInput | AppSchemaCreateOrConnectWithoutAppInput[]
    upsert?: AppSchemaUpsertWithWhereUniqueWithoutAppInput | AppSchemaUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: AppSchemaCreateManyAppInputEnvelope
    set?: AppSchemaWhereUniqueInput | AppSchemaWhereUniqueInput[]
    disconnect?: AppSchemaWhereUniqueInput | AppSchemaWhereUniqueInput[]
    delete?: AppSchemaWhereUniqueInput | AppSchemaWhereUniqueInput[]
    connect?: AppSchemaWhereUniqueInput | AppSchemaWhereUniqueInput[]
    update?: AppSchemaUpdateWithWhereUniqueWithoutAppInput | AppSchemaUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: AppSchemaUpdateManyWithWhereWithoutAppInput | AppSchemaUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: AppSchemaScalarWhereInput | AppSchemaScalarWhereInput[]
  }

  export type AppMetricUncheckedUpdateManyWithoutAppNestedInput = {
    create?: XOR<AppMetricCreateWithoutAppInput, AppMetricUncheckedCreateWithoutAppInput> | AppMetricCreateWithoutAppInput[] | AppMetricUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppMetricCreateOrConnectWithoutAppInput | AppMetricCreateOrConnectWithoutAppInput[]
    upsert?: AppMetricUpsertWithWhereUniqueWithoutAppInput | AppMetricUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: AppMetricCreateManyAppInputEnvelope
    set?: AppMetricWhereUniqueInput | AppMetricWhereUniqueInput[]
    disconnect?: AppMetricWhereUniqueInput | AppMetricWhereUniqueInput[]
    delete?: AppMetricWhereUniqueInput | AppMetricWhereUniqueInput[]
    connect?: AppMetricWhereUniqueInput | AppMetricWhereUniqueInput[]
    update?: AppMetricUpdateWithWhereUniqueWithoutAppInput | AppMetricUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: AppMetricUpdateManyWithWhereWithoutAppInput | AppMetricUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: AppMetricScalarWhereInput | AppMetricScalarWhereInput[]
  }

  export type AppIssueUncheckedUpdateManyWithoutAppNestedInput = {
    create?: XOR<AppIssueCreateWithoutAppInput, AppIssueUncheckedCreateWithoutAppInput> | AppIssueCreateWithoutAppInput[] | AppIssueUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppIssueCreateOrConnectWithoutAppInput | AppIssueCreateOrConnectWithoutAppInput[]
    upsert?: AppIssueUpsertWithWhereUniqueWithoutAppInput | AppIssueUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: AppIssueCreateManyAppInputEnvelope
    set?: AppIssueWhereUniqueInput | AppIssueWhereUniqueInput[]
    disconnect?: AppIssueWhereUniqueInput | AppIssueWhereUniqueInput[]
    delete?: AppIssueWhereUniqueInput | AppIssueWhereUniqueInput[]
    connect?: AppIssueWhereUniqueInput | AppIssueWhereUniqueInput[]
    update?: AppIssueUpdateWithWhereUniqueWithoutAppInput | AppIssueUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: AppIssueUpdateManyWithWhereWithoutAppInput | AppIssueUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: AppIssueScalarWhereInput | AppIssueScalarWhereInput[]
  }

  export type AppWarningUncheckedUpdateManyWithoutAppNestedInput = {
    create?: XOR<AppWarningCreateWithoutAppInput, AppWarningUncheckedCreateWithoutAppInput> | AppWarningCreateWithoutAppInput[] | AppWarningUncheckedCreateWithoutAppInput[]
    connectOrCreate?: AppWarningCreateOrConnectWithoutAppInput | AppWarningCreateOrConnectWithoutAppInput[]
    upsert?: AppWarningUpsertWithWhereUniqueWithoutAppInput | AppWarningUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: AppWarningCreateManyAppInputEnvelope
    set?: AppWarningWhereUniqueInput | AppWarningWhereUniqueInput[]
    disconnect?: AppWarningWhereUniqueInput | AppWarningWhereUniqueInput[]
    delete?: AppWarningWhereUniqueInput | AppWarningWhereUniqueInput[]
    connect?: AppWarningWhereUniqueInput | AppWarningWhereUniqueInput[]
    update?: AppWarningUpdateWithWhereUniqueWithoutAppInput | AppWarningUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: AppWarningUpdateManyWithWhereWithoutAppInput | AppWarningUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: AppWarningScalarWhereInput | AppWarningScalarWhereInput[]
  }

  export type CanvasUncheckedUpdateOneWithoutAppNestedInput = {
    create?: XOR<CanvasCreateWithoutAppInput, CanvasUncheckedCreateWithoutAppInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutAppInput
    upsert?: CanvasUpsertWithoutAppInput
    disconnect?: CanvasWhereInput | boolean
    delete?: CanvasWhereInput | boolean
    connect?: CanvasWhereUniqueInput
    update?: XOR<XOR<CanvasUpdateToOneWithWhereWithoutAppInput, CanvasUpdateWithoutAppInput>, CanvasUncheckedUpdateWithoutAppInput>
  }

  export type MediaFileUncheckedUpdateManyWithoutAppNestedInput = {
    create?: XOR<MediaFileCreateWithoutAppInput, MediaFileUncheckedCreateWithoutAppInput> | MediaFileCreateWithoutAppInput[] | MediaFileUncheckedCreateWithoutAppInput[]
    connectOrCreate?: MediaFileCreateOrConnectWithoutAppInput | MediaFileCreateOrConnectWithoutAppInput[]
    upsert?: MediaFileUpsertWithWhereUniqueWithoutAppInput | MediaFileUpsertWithWhereUniqueWithoutAppInput[]
    createMany?: MediaFileCreateManyAppInputEnvelope
    set?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    disconnect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    delete?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    connect?: MediaFileWhereUniqueInput | MediaFileWhereUniqueInput[]
    update?: MediaFileUpdateWithWhereUniqueWithoutAppInput | MediaFileUpdateWithWhereUniqueWithoutAppInput[]
    updateMany?: MediaFileUpdateManyWithWhereWithoutAppInput | MediaFileUpdateManyWithWhereWithoutAppInput[]
    deleteMany?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
  }

  export type AppCreateNestedManyWithoutTemplateInput = {
    create?: XOR<AppCreateWithoutTemplateInput, AppUncheckedCreateWithoutTemplateInput> | AppCreateWithoutTemplateInput[] | AppUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AppCreateOrConnectWithoutTemplateInput | AppCreateOrConnectWithoutTemplateInput[]
    createMany?: AppCreateManyTemplateInputEnvelope
    connect?: AppWhereUniqueInput | AppWhereUniqueInput[]
  }

  export type AppUncheckedCreateNestedManyWithoutTemplateInput = {
    create?: XOR<AppCreateWithoutTemplateInput, AppUncheckedCreateWithoutTemplateInput> | AppCreateWithoutTemplateInput[] | AppUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AppCreateOrConnectWithoutTemplateInput | AppCreateOrConnectWithoutTemplateInput[]
    createMany?: AppCreateManyTemplateInputEnvelope
    connect?: AppWhereUniqueInput | AppWhereUniqueInput[]
  }

  export type AppUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<AppCreateWithoutTemplateInput, AppUncheckedCreateWithoutTemplateInput> | AppCreateWithoutTemplateInput[] | AppUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AppCreateOrConnectWithoutTemplateInput | AppCreateOrConnectWithoutTemplateInput[]
    upsert?: AppUpsertWithWhereUniqueWithoutTemplateInput | AppUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: AppCreateManyTemplateInputEnvelope
    set?: AppWhereUniqueInput | AppWhereUniqueInput[]
    disconnect?: AppWhereUniqueInput | AppWhereUniqueInput[]
    delete?: AppWhereUniqueInput | AppWhereUniqueInput[]
    connect?: AppWhereUniqueInput | AppWhereUniqueInput[]
    update?: AppUpdateWithWhereUniqueWithoutTemplateInput | AppUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: AppUpdateManyWithWhereWithoutTemplateInput | AppUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: AppScalarWhereInput | AppScalarWhereInput[]
  }

  export type AppUncheckedUpdateManyWithoutTemplateNestedInput = {
    create?: XOR<AppCreateWithoutTemplateInput, AppUncheckedCreateWithoutTemplateInput> | AppCreateWithoutTemplateInput[] | AppUncheckedCreateWithoutTemplateInput[]
    connectOrCreate?: AppCreateOrConnectWithoutTemplateInput | AppCreateOrConnectWithoutTemplateInput[]
    upsert?: AppUpsertWithWhereUniqueWithoutTemplateInput | AppUpsertWithWhereUniqueWithoutTemplateInput[]
    createMany?: AppCreateManyTemplateInputEnvelope
    set?: AppWhereUniqueInput | AppWhereUniqueInput[]
    disconnect?: AppWhereUniqueInput | AppWhereUniqueInput[]
    delete?: AppWhereUniqueInput | AppWhereUniqueInput[]
    connect?: AppWhereUniqueInput | AppWhereUniqueInput[]
    update?: AppUpdateWithWhereUniqueWithoutTemplateInput | AppUpdateWithWhereUniqueWithoutTemplateInput[]
    updateMany?: AppUpdateManyWithWhereWithoutTemplateInput | AppUpdateManyWithWhereWithoutTemplateInput[]
    deleteMany?: AppScalarWhereInput | AppScalarWhereInput[]
  }

  export type AppCreateNestedOneWithoutComponentsInput = {
    create?: XOR<AppCreateWithoutComponentsInput, AppUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: AppCreateOrConnectWithoutComponentsInput
    connect?: AppWhereUniqueInput
  }

  export type AppUpdateOneRequiredWithoutComponentsNestedInput = {
    create?: XOR<AppCreateWithoutComponentsInput, AppUncheckedCreateWithoutComponentsInput>
    connectOrCreate?: AppCreateOrConnectWithoutComponentsInput
    upsert?: AppUpsertWithoutComponentsInput
    connect?: AppWhereUniqueInput
    update?: XOR<XOR<AppUpdateToOneWithWhereWithoutComponentsInput, AppUpdateWithoutComponentsInput>, AppUncheckedUpdateWithoutComponentsInput>
  }

  export type AppCreateNestedOneWithoutWorkflowsInput = {
    create?: XOR<AppCreateWithoutWorkflowsInput, AppUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: AppCreateOrConnectWithoutWorkflowsInput
    connect?: AppWhereUniqueInput
  }

  export type AppUpdateOneRequiredWithoutWorkflowsNestedInput = {
    create?: XOR<AppCreateWithoutWorkflowsInput, AppUncheckedCreateWithoutWorkflowsInput>
    connectOrCreate?: AppCreateOrConnectWithoutWorkflowsInput
    upsert?: AppUpsertWithoutWorkflowsInput
    connect?: AppWhereUniqueInput
    update?: XOR<XOR<AppUpdateToOneWithWhereWithoutWorkflowsInput, AppUpdateWithoutWorkflowsInput>, AppUncheckedUpdateWithoutWorkflowsInput>
  }

  export type AppDataCreateNestedManyWithoutSchemaInput = {
    create?: XOR<AppDataCreateWithoutSchemaInput, AppDataUncheckedCreateWithoutSchemaInput> | AppDataCreateWithoutSchemaInput[] | AppDataUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: AppDataCreateOrConnectWithoutSchemaInput | AppDataCreateOrConnectWithoutSchemaInput[]
    createMany?: AppDataCreateManySchemaInputEnvelope
    connect?: AppDataWhereUniqueInput | AppDataWhereUniqueInput[]
  }

  export type AppFieldCreateNestedManyWithoutRelatedSchemaInput = {
    create?: XOR<AppFieldCreateWithoutRelatedSchemaInput, AppFieldUncheckedCreateWithoutRelatedSchemaInput> | AppFieldCreateWithoutRelatedSchemaInput[] | AppFieldUncheckedCreateWithoutRelatedSchemaInput[]
    connectOrCreate?: AppFieldCreateOrConnectWithoutRelatedSchemaInput | AppFieldCreateOrConnectWithoutRelatedSchemaInput[]
    createMany?: AppFieldCreateManyRelatedSchemaInputEnvelope
    connect?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
  }

  export type AppFieldCreateNestedManyWithoutSchemaInput = {
    create?: XOR<AppFieldCreateWithoutSchemaInput, AppFieldUncheckedCreateWithoutSchemaInput> | AppFieldCreateWithoutSchemaInput[] | AppFieldUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: AppFieldCreateOrConnectWithoutSchemaInput | AppFieldCreateOrConnectWithoutSchemaInput[]
    createMany?: AppFieldCreateManySchemaInputEnvelope
    connect?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
  }

  export type AppCreateNestedOneWithoutSchemasInput = {
    create?: XOR<AppCreateWithoutSchemasInput, AppUncheckedCreateWithoutSchemasInput>
    connectOrCreate?: AppCreateOrConnectWithoutSchemasInput
    connect?: AppWhereUniqueInput
  }

  export type AppDataUncheckedCreateNestedManyWithoutSchemaInput = {
    create?: XOR<AppDataCreateWithoutSchemaInput, AppDataUncheckedCreateWithoutSchemaInput> | AppDataCreateWithoutSchemaInput[] | AppDataUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: AppDataCreateOrConnectWithoutSchemaInput | AppDataCreateOrConnectWithoutSchemaInput[]
    createMany?: AppDataCreateManySchemaInputEnvelope
    connect?: AppDataWhereUniqueInput | AppDataWhereUniqueInput[]
  }

  export type AppFieldUncheckedCreateNestedManyWithoutRelatedSchemaInput = {
    create?: XOR<AppFieldCreateWithoutRelatedSchemaInput, AppFieldUncheckedCreateWithoutRelatedSchemaInput> | AppFieldCreateWithoutRelatedSchemaInput[] | AppFieldUncheckedCreateWithoutRelatedSchemaInput[]
    connectOrCreate?: AppFieldCreateOrConnectWithoutRelatedSchemaInput | AppFieldCreateOrConnectWithoutRelatedSchemaInput[]
    createMany?: AppFieldCreateManyRelatedSchemaInputEnvelope
    connect?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
  }

  export type AppFieldUncheckedCreateNestedManyWithoutSchemaInput = {
    create?: XOR<AppFieldCreateWithoutSchemaInput, AppFieldUncheckedCreateWithoutSchemaInput> | AppFieldCreateWithoutSchemaInput[] | AppFieldUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: AppFieldCreateOrConnectWithoutSchemaInput | AppFieldCreateOrConnectWithoutSchemaInput[]
    createMany?: AppFieldCreateManySchemaInputEnvelope
    connect?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
  }

  export type AppDataUpdateManyWithoutSchemaNestedInput = {
    create?: XOR<AppDataCreateWithoutSchemaInput, AppDataUncheckedCreateWithoutSchemaInput> | AppDataCreateWithoutSchemaInput[] | AppDataUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: AppDataCreateOrConnectWithoutSchemaInput | AppDataCreateOrConnectWithoutSchemaInput[]
    upsert?: AppDataUpsertWithWhereUniqueWithoutSchemaInput | AppDataUpsertWithWhereUniqueWithoutSchemaInput[]
    createMany?: AppDataCreateManySchemaInputEnvelope
    set?: AppDataWhereUniqueInput | AppDataWhereUniqueInput[]
    disconnect?: AppDataWhereUniqueInput | AppDataWhereUniqueInput[]
    delete?: AppDataWhereUniqueInput | AppDataWhereUniqueInput[]
    connect?: AppDataWhereUniqueInput | AppDataWhereUniqueInput[]
    update?: AppDataUpdateWithWhereUniqueWithoutSchemaInput | AppDataUpdateWithWhereUniqueWithoutSchemaInput[]
    updateMany?: AppDataUpdateManyWithWhereWithoutSchemaInput | AppDataUpdateManyWithWhereWithoutSchemaInput[]
    deleteMany?: AppDataScalarWhereInput | AppDataScalarWhereInput[]
  }

  export type AppFieldUpdateManyWithoutRelatedSchemaNestedInput = {
    create?: XOR<AppFieldCreateWithoutRelatedSchemaInput, AppFieldUncheckedCreateWithoutRelatedSchemaInput> | AppFieldCreateWithoutRelatedSchemaInput[] | AppFieldUncheckedCreateWithoutRelatedSchemaInput[]
    connectOrCreate?: AppFieldCreateOrConnectWithoutRelatedSchemaInput | AppFieldCreateOrConnectWithoutRelatedSchemaInput[]
    upsert?: AppFieldUpsertWithWhereUniqueWithoutRelatedSchemaInput | AppFieldUpsertWithWhereUniqueWithoutRelatedSchemaInput[]
    createMany?: AppFieldCreateManyRelatedSchemaInputEnvelope
    set?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    disconnect?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    delete?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    connect?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    update?: AppFieldUpdateWithWhereUniqueWithoutRelatedSchemaInput | AppFieldUpdateWithWhereUniqueWithoutRelatedSchemaInput[]
    updateMany?: AppFieldUpdateManyWithWhereWithoutRelatedSchemaInput | AppFieldUpdateManyWithWhereWithoutRelatedSchemaInput[]
    deleteMany?: AppFieldScalarWhereInput | AppFieldScalarWhereInput[]
  }

  export type AppFieldUpdateManyWithoutSchemaNestedInput = {
    create?: XOR<AppFieldCreateWithoutSchemaInput, AppFieldUncheckedCreateWithoutSchemaInput> | AppFieldCreateWithoutSchemaInput[] | AppFieldUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: AppFieldCreateOrConnectWithoutSchemaInput | AppFieldCreateOrConnectWithoutSchemaInput[]
    upsert?: AppFieldUpsertWithWhereUniqueWithoutSchemaInput | AppFieldUpsertWithWhereUniqueWithoutSchemaInput[]
    createMany?: AppFieldCreateManySchemaInputEnvelope
    set?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    disconnect?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    delete?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    connect?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    update?: AppFieldUpdateWithWhereUniqueWithoutSchemaInput | AppFieldUpdateWithWhereUniqueWithoutSchemaInput[]
    updateMany?: AppFieldUpdateManyWithWhereWithoutSchemaInput | AppFieldUpdateManyWithWhereWithoutSchemaInput[]
    deleteMany?: AppFieldScalarWhereInput | AppFieldScalarWhereInput[]
  }

  export type AppUpdateOneRequiredWithoutSchemasNestedInput = {
    create?: XOR<AppCreateWithoutSchemasInput, AppUncheckedCreateWithoutSchemasInput>
    connectOrCreate?: AppCreateOrConnectWithoutSchemasInput
    upsert?: AppUpsertWithoutSchemasInput
    connect?: AppWhereUniqueInput
    update?: XOR<XOR<AppUpdateToOneWithWhereWithoutSchemasInput, AppUpdateWithoutSchemasInput>, AppUncheckedUpdateWithoutSchemasInput>
  }

  export type AppDataUncheckedUpdateManyWithoutSchemaNestedInput = {
    create?: XOR<AppDataCreateWithoutSchemaInput, AppDataUncheckedCreateWithoutSchemaInput> | AppDataCreateWithoutSchemaInput[] | AppDataUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: AppDataCreateOrConnectWithoutSchemaInput | AppDataCreateOrConnectWithoutSchemaInput[]
    upsert?: AppDataUpsertWithWhereUniqueWithoutSchemaInput | AppDataUpsertWithWhereUniqueWithoutSchemaInput[]
    createMany?: AppDataCreateManySchemaInputEnvelope
    set?: AppDataWhereUniqueInput | AppDataWhereUniqueInput[]
    disconnect?: AppDataWhereUniqueInput | AppDataWhereUniqueInput[]
    delete?: AppDataWhereUniqueInput | AppDataWhereUniqueInput[]
    connect?: AppDataWhereUniqueInput | AppDataWhereUniqueInput[]
    update?: AppDataUpdateWithWhereUniqueWithoutSchemaInput | AppDataUpdateWithWhereUniqueWithoutSchemaInput[]
    updateMany?: AppDataUpdateManyWithWhereWithoutSchemaInput | AppDataUpdateManyWithWhereWithoutSchemaInput[]
    deleteMany?: AppDataScalarWhereInput | AppDataScalarWhereInput[]
  }

  export type AppFieldUncheckedUpdateManyWithoutRelatedSchemaNestedInput = {
    create?: XOR<AppFieldCreateWithoutRelatedSchemaInput, AppFieldUncheckedCreateWithoutRelatedSchemaInput> | AppFieldCreateWithoutRelatedSchemaInput[] | AppFieldUncheckedCreateWithoutRelatedSchemaInput[]
    connectOrCreate?: AppFieldCreateOrConnectWithoutRelatedSchemaInput | AppFieldCreateOrConnectWithoutRelatedSchemaInput[]
    upsert?: AppFieldUpsertWithWhereUniqueWithoutRelatedSchemaInput | AppFieldUpsertWithWhereUniqueWithoutRelatedSchemaInput[]
    createMany?: AppFieldCreateManyRelatedSchemaInputEnvelope
    set?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    disconnect?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    delete?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    connect?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    update?: AppFieldUpdateWithWhereUniqueWithoutRelatedSchemaInput | AppFieldUpdateWithWhereUniqueWithoutRelatedSchemaInput[]
    updateMany?: AppFieldUpdateManyWithWhereWithoutRelatedSchemaInput | AppFieldUpdateManyWithWhereWithoutRelatedSchemaInput[]
    deleteMany?: AppFieldScalarWhereInput | AppFieldScalarWhereInput[]
  }

  export type AppFieldUncheckedUpdateManyWithoutSchemaNestedInput = {
    create?: XOR<AppFieldCreateWithoutSchemaInput, AppFieldUncheckedCreateWithoutSchemaInput> | AppFieldCreateWithoutSchemaInput[] | AppFieldUncheckedCreateWithoutSchemaInput[]
    connectOrCreate?: AppFieldCreateOrConnectWithoutSchemaInput | AppFieldCreateOrConnectWithoutSchemaInput[]
    upsert?: AppFieldUpsertWithWhereUniqueWithoutSchemaInput | AppFieldUpsertWithWhereUniqueWithoutSchemaInput[]
    createMany?: AppFieldCreateManySchemaInputEnvelope
    set?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    disconnect?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    delete?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    connect?: AppFieldWhereUniqueInput | AppFieldWhereUniqueInput[]
    update?: AppFieldUpdateWithWhereUniqueWithoutSchemaInput | AppFieldUpdateWithWhereUniqueWithoutSchemaInput[]
    updateMany?: AppFieldUpdateManyWithWhereWithoutSchemaInput | AppFieldUpdateManyWithWhereWithoutSchemaInput[]
    deleteMany?: AppFieldScalarWhereInput | AppFieldScalarWhereInput[]
  }

  export type AppSchemaCreateNestedOneWithoutRelatedFieldsInput = {
    create?: XOR<AppSchemaCreateWithoutRelatedFieldsInput, AppSchemaUncheckedCreateWithoutRelatedFieldsInput>
    connectOrCreate?: AppSchemaCreateOrConnectWithoutRelatedFieldsInput
    connect?: AppSchemaWhereUniqueInput
  }

  export type AppSchemaCreateNestedOneWithoutFieldsInput = {
    create?: XOR<AppSchemaCreateWithoutFieldsInput, AppSchemaUncheckedCreateWithoutFieldsInput>
    connectOrCreate?: AppSchemaCreateOrConnectWithoutFieldsInput
    connect?: AppSchemaWhereUniqueInput
  }

  export type EnumFieldTypeFieldUpdateOperationsInput = {
    set?: $Enums.FieldType
  }

  export type AppSchemaUpdateOneWithoutRelatedFieldsNestedInput = {
    create?: XOR<AppSchemaCreateWithoutRelatedFieldsInput, AppSchemaUncheckedCreateWithoutRelatedFieldsInput>
    connectOrCreate?: AppSchemaCreateOrConnectWithoutRelatedFieldsInput
    upsert?: AppSchemaUpsertWithoutRelatedFieldsInput
    disconnect?: AppSchemaWhereInput | boolean
    delete?: AppSchemaWhereInput | boolean
    connect?: AppSchemaWhereUniqueInput
    update?: XOR<XOR<AppSchemaUpdateToOneWithWhereWithoutRelatedFieldsInput, AppSchemaUpdateWithoutRelatedFieldsInput>, AppSchemaUncheckedUpdateWithoutRelatedFieldsInput>
  }

  export type AppSchemaUpdateOneRequiredWithoutFieldsNestedInput = {
    create?: XOR<AppSchemaCreateWithoutFieldsInput, AppSchemaUncheckedCreateWithoutFieldsInput>
    connectOrCreate?: AppSchemaCreateOrConnectWithoutFieldsInput
    upsert?: AppSchemaUpsertWithoutFieldsInput
    connect?: AppSchemaWhereUniqueInput
    update?: XOR<XOR<AppSchemaUpdateToOneWithWhereWithoutFieldsInput, AppSchemaUpdateWithoutFieldsInput>, AppSchemaUncheckedUpdateWithoutFieldsInput>
  }

  export type AppSchemaCreateNestedOneWithoutDataInput = {
    create?: XOR<AppSchemaCreateWithoutDataInput, AppSchemaUncheckedCreateWithoutDataInput>
    connectOrCreate?: AppSchemaCreateOrConnectWithoutDataInput
    connect?: AppSchemaWhereUniqueInput
  }

  export type AppSchemaUpdateOneRequiredWithoutDataNestedInput = {
    create?: XOR<AppSchemaCreateWithoutDataInput, AppSchemaUncheckedCreateWithoutDataInput>
    connectOrCreate?: AppSchemaCreateOrConnectWithoutDataInput
    upsert?: AppSchemaUpsertWithoutDataInput
    connect?: AppSchemaWhereUniqueInput
    update?: XOR<XOR<AppSchemaUpdateToOneWithWhereWithoutDataInput, AppSchemaUpdateWithoutDataInput>, AppSchemaUncheckedUpdateWithoutDataInput>
  }

  export type AppCreateNestedOneWithoutMetricsInput = {
    create?: XOR<AppCreateWithoutMetricsInput, AppUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: AppCreateOrConnectWithoutMetricsInput
    connect?: AppWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type AppUpdateOneRequiredWithoutMetricsNestedInput = {
    create?: XOR<AppCreateWithoutMetricsInput, AppUncheckedCreateWithoutMetricsInput>
    connectOrCreate?: AppCreateOrConnectWithoutMetricsInput
    upsert?: AppUpsertWithoutMetricsInput
    connect?: AppWhereUniqueInput
    update?: XOR<XOR<AppUpdateToOneWithWhereWithoutMetricsInput, AppUpdateWithoutMetricsInput>, AppUncheckedUpdateWithoutMetricsInput>
  }

  export type AppCreateNestedOneWithoutIssuesInput = {
    create?: XOR<AppCreateWithoutIssuesInput, AppUncheckedCreateWithoutIssuesInput>
    connectOrCreate?: AppCreateOrConnectWithoutIssuesInput
    connect?: AppWhereUniqueInput
  }

  export type EnumIssueSeverityFieldUpdateOperationsInput = {
    set?: $Enums.IssueSeverity
  }

  export type EnumIssueStatusFieldUpdateOperationsInput = {
    set?: $Enums.IssueStatus
  }

  export type AppUpdateOneRequiredWithoutIssuesNestedInput = {
    create?: XOR<AppCreateWithoutIssuesInput, AppUncheckedCreateWithoutIssuesInput>
    connectOrCreate?: AppCreateOrConnectWithoutIssuesInput
    upsert?: AppUpsertWithoutIssuesInput
    connect?: AppWhereUniqueInput
    update?: XOR<XOR<AppUpdateToOneWithWhereWithoutIssuesInput, AppUpdateWithoutIssuesInput>, AppUncheckedUpdateWithoutIssuesInput>
  }

  export type AppCreateNestedOneWithoutWarningsInput = {
    create?: XOR<AppCreateWithoutWarningsInput, AppUncheckedCreateWithoutWarningsInput>
    connectOrCreate?: AppCreateOrConnectWithoutWarningsInput
    connect?: AppWhereUniqueInput
  }

  export type AppUpdateOneRequiredWithoutWarningsNestedInput = {
    create?: XOR<AppCreateWithoutWarningsInput, AppUncheckedCreateWithoutWarningsInput>
    connectOrCreate?: AppCreateOrConnectWithoutWarningsInput
    upsert?: AppUpsertWithoutWarningsInput
    connect?: AppWhereUniqueInput
    update?: XOR<XOR<AppUpdateToOneWithWhereWithoutWarningsInput, AppUpdateWithoutWarningsInput>, AppUncheckedUpdateWithoutWarningsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type AppCreateNestedOneWithoutCanvasInput = {
    create?: XOR<AppCreateWithoutCanvasInput, AppUncheckedCreateWithoutCanvasInput>
    connectOrCreate?: AppCreateOrConnectWithoutCanvasInput
    connect?: AppWhereUniqueInput
  }

  export type CanvasElementCreateNestedManyWithoutCanvasInput = {
    create?: XOR<CanvasElementCreateWithoutCanvasInput, CanvasElementUncheckedCreateWithoutCanvasInput> | CanvasElementCreateWithoutCanvasInput[] | CanvasElementUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasElementCreateOrConnectWithoutCanvasInput | CanvasElementCreateOrConnectWithoutCanvasInput[]
    createMany?: CanvasElementCreateManyCanvasInputEnvelope
    connect?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
  }

  export type CanvasHistoryCreateNestedManyWithoutCanvasInput = {
    create?: XOR<CanvasHistoryCreateWithoutCanvasInput, CanvasHistoryUncheckedCreateWithoutCanvasInput> | CanvasHistoryCreateWithoutCanvasInput[] | CanvasHistoryUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasHistoryCreateOrConnectWithoutCanvasInput | CanvasHistoryCreateOrConnectWithoutCanvasInput[]
    createMany?: CanvasHistoryCreateManyCanvasInputEnvelope
    connect?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
  }

  export type CanvasElementUncheckedCreateNestedManyWithoutCanvasInput = {
    create?: XOR<CanvasElementCreateWithoutCanvasInput, CanvasElementUncheckedCreateWithoutCanvasInput> | CanvasElementCreateWithoutCanvasInput[] | CanvasElementUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasElementCreateOrConnectWithoutCanvasInput | CanvasElementCreateOrConnectWithoutCanvasInput[]
    createMany?: CanvasElementCreateManyCanvasInputEnvelope
    connect?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
  }

  export type CanvasHistoryUncheckedCreateNestedManyWithoutCanvasInput = {
    create?: XOR<CanvasHistoryCreateWithoutCanvasInput, CanvasHistoryUncheckedCreateWithoutCanvasInput> | CanvasHistoryCreateWithoutCanvasInput[] | CanvasHistoryUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasHistoryCreateOrConnectWithoutCanvasInput | CanvasHistoryCreateOrConnectWithoutCanvasInput[]
    createMany?: CanvasHistoryCreateManyCanvasInputEnvelope
    connect?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
  }

  export type AppUpdateOneRequiredWithoutCanvasNestedInput = {
    create?: XOR<AppCreateWithoutCanvasInput, AppUncheckedCreateWithoutCanvasInput>
    connectOrCreate?: AppCreateOrConnectWithoutCanvasInput
    upsert?: AppUpsertWithoutCanvasInput
    connect?: AppWhereUniqueInput
    update?: XOR<XOR<AppUpdateToOneWithWhereWithoutCanvasInput, AppUpdateWithoutCanvasInput>, AppUncheckedUpdateWithoutCanvasInput>
  }

  export type CanvasElementUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<CanvasElementCreateWithoutCanvasInput, CanvasElementUncheckedCreateWithoutCanvasInput> | CanvasElementCreateWithoutCanvasInput[] | CanvasElementUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasElementCreateOrConnectWithoutCanvasInput | CanvasElementCreateOrConnectWithoutCanvasInput[]
    upsert?: CanvasElementUpsertWithWhereUniqueWithoutCanvasInput | CanvasElementUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: CanvasElementCreateManyCanvasInputEnvelope
    set?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    disconnect?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    delete?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    connect?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    update?: CanvasElementUpdateWithWhereUniqueWithoutCanvasInput | CanvasElementUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: CanvasElementUpdateManyWithWhereWithoutCanvasInput | CanvasElementUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: CanvasElementScalarWhereInput | CanvasElementScalarWhereInput[]
  }

  export type CanvasHistoryUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<CanvasHistoryCreateWithoutCanvasInput, CanvasHistoryUncheckedCreateWithoutCanvasInput> | CanvasHistoryCreateWithoutCanvasInput[] | CanvasHistoryUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasHistoryCreateOrConnectWithoutCanvasInput | CanvasHistoryCreateOrConnectWithoutCanvasInput[]
    upsert?: CanvasHistoryUpsertWithWhereUniqueWithoutCanvasInput | CanvasHistoryUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: CanvasHistoryCreateManyCanvasInputEnvelope
    set?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    disconnect?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    delete?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    connect?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    update?: CanvasHistoryUpdateWithWhereUniqueWithoutCanvasInput | CanvasHistoryUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: CanvasHistoryUpdateManyWithWhereWithoutCanvasInput | CanvasHistoryUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: CanvasHistoryScalarWhereInput | CanvasHistoryScalarWhereInput[]
  }

  export type CanvasElementUncheckedUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<CanvasElementCreateWithoutCanvasInput, CanvasElementUncheckedCreateWithoutCanvasInput> | CanvasElementCreateWithoutCanvasInput[] | CanvasElementUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasElementCreateOrConnectWithoutCanvasInput | CanvasElementCreateOrConnectWithoutCanvasInput[]
    upsert?: CanvasElementUpsertWithWhereUniqueWithoutCanvasInput | CanvasElementUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: CanvasElementCreateManyCanvasInputEnvelope
    set?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    disconnect?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    delete?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    connect?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    update?: CanvasElementUpdateWithWhereUniqueWithoutCanvasInput | CanvasElementUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: CanvasElementUpdateManyWithWhereWithoutCanvasInput | CanvasElementUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: CanvasElementScalarWhereInput | CanvasElementScalarWhereInput[]
  }

  export type CanvasHistoryUncheckedUpdateManyWithoutCanvasNestedInput = {
    create?: XOR<CanvasHistoryCreateWithoutCanvasInput, CanvasHistoryUncheckedCreateWithoutCanvasInput> | CanvasHistoryCreateWithoutCanvasInput[] | CanvasHistoryUncheckedCreateWithoutCanvasInput[]
    connectOrCreate?: CanvasHistoryCreateOrConnectWithoutCanvasInput | CanvasHistoryCreateOrConnectWithoutCanvasInput[]
    upsert?: CanvasHistoryUpsertWithWhereUniqueWithoutCanvasInput | CanvasHistoryUpsertWithWhereUniqueWithoutCanvasInput[]
    createMany?: CanvasHistoryCreateManyCanvasInputEnvelope
    set?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    disconnect?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    delete?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    connect?: CanvasHistoryWhereUniqueInput | CanvasHistoryWhereUniqueInput[]
    update?: CanvasHistoryUpdateWithWhereUniqueWithoutCanvasInput | CanvasHistoryUpdateWithWhereUniqueWithoutCanvasInput[]
    updateMany?: CanvasHistoryUpdateManyWithWhereWithoutCanvasInput | CanvasHistoryUpdateManyWithWhereWithoutCanvasInput[]
    deleteMany?: CanvasHistoryScalarWhereInput | CanvasHistoryScalarWhereInput[]
  }

  export type CanvasCreateNestedOneWithoutElementsInput = {
    create?: XOR<CanvasCreateWithoutElementsInput, CanvasUncheckedCreateWithoutElementsInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutElementsInput
    connect?: CanvasWhereUniqueInput
  }

  export type CanvasElementCreateNestedOneWithoutChildrenInput = {
    create?: XOR<CanvasElementCreateWithoutChildrenInput, CanvasElementUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CanvasElementCreateOrConnectWithoutChildrenInput
    connect?: CanvasElementWhereUniqueInput
  }

  export type CanvasElementCreateNestedManyWithoutParentInput = {
    create?: XOR<CanvasElementCreateWithoutParentInput, CanvasElementUncheckedCreateWithoutParentInput> | CanvasElementCreateWithoutParentInput[] | CanvasElementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CanvasElementCreateOrConnectWithoutParentInput | CanvasElementCreateOrConnectWithoutParentInput[]
    createMany?: CanvasElementCreateManyParentInputEnvelope
    connect?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
  }

  export type ElementInteractionCreateNestedManyWithoutElementInput = {
    create?: XOR<ElementInteractionCreateWithoutElementInput, ElementInteractionUncheckedCreateWithoutElementInput> | ElementInteractionCreateWithoutElementInput[] | ElementInteractionUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ElementInteractionCreateOrConnectWithoutElementInput | ElementInteractionCreateOrConnectWithoutElementInput[]
    createMany?: ElementInteractionCreateManyElementInputEnvelope
    connect?: ElementInteractionWhereUniqueInput | ElementInteractionWhereUniqueInput[]
  }

  export type ElementValidationCreateNestedManyWithoutElementInput = {
    create?: XOR<ElementValidationCreateWithoutElementInput, ElementValidationUncheckedCreateWithoutElementInput> | ElementValidationCreateWithoutElementInput[] | ElementValidationUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ElementValidationCreateOrConnectWithoutElementInput | ElementValidationCreateOrConnectWithoutElementInput[]
    createMany?: ElementValidationCreateManyElementInputEnvelope
    connect?: ElementValidationWhereUniqueInput | ElementValidationWhereUniqueInput[]
  }

  export type CanvasElementUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<CanvasElementCreateWithoutParentInput, CanvasElementUncheckedCreateWithoutParentInput> | CanvasElementCreateWithoutParentInput[] | CanvasElementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CanvasElementCreateOrConnectWithoutParentInput | CanvasElementCreateOrConnectWithoutParentInput[]
    createMany?: CanvasElementCreateManyParentInputEnvelope
    connect?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
  }

  export type ElementInteractionUncheckedCreateNestedManyWithoutElementInput = {
    create?: XOR<ElementInteractionCreateWithoutElementInput, ElementInteractionUncheckedCreateWithoutElementInput> | ElementInteractionCreateWithoutElementInput[] | ElementInteractionUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ElementInteractionCreateOrConnectWithoutElementInput | ElementInteractionCreateOrConnectWithoutElementInput[]
    createMany?: ElementInteractionCreateManyElementInputEnvelope
    connect?: ElementInteractionWhereUniqueInput | ElementInteractionWhereUniqueInput[]
  }

  export type ElementValidationUncheckedCreateNestedManyWithoutElementInput = {
    create?: XOR<ElementValidationCreateWithoutElementInput, ElementValidationUncheckedCreateWithoutElementInput> | ElementValidationCreateWithoutElementInput[] | ElementValidationUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ElementValidationCreateOrConnectWithoutElementInput | ElementValidationCreateOrConnectWithoutElementInput[]
    createMany?: ElementValidationCreateManyElementInputEnvelope
    connect?: ElementValidationWhereUniqueInput | ElementValidationWhereUniqueInput[]
  }

  export type EnumElementTypeFieldUpdateOperationsInput = {
    set?: $Enums.ElementType
  }

  export type CanvasUpdateOneRequiredWithoutElementsNestedInput = {
    create?: XOR<CanvasCreateWithoutElementsInput, CanvasUncheckedCreateWithoutElementsInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutElementsInput
    upsert?: CanvasUpsertWithoutElementsInput
    connect?: CanvasWhereUniqueInput
    update?: XOR<XOR<CanvasUpdateToOneWithWhereWithoutElementsInput, CanvasUpdateWithoutElementsInput>, CanvasUncheckedUpdateWithoutElementsInput>
  }

  export type CanvasElementUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<CanvasElementCreateWithoutChildrenInput, CanvasElementUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: CanvasElementCreateOrConnectWithoutChildrenInput
    upsert?: CanvasElementUpsertWithoutChildrenInput
    disconnect?: CanvasElementWhereInput | boolean
    delete?: CanvasElementWhereInput | boolean
    connect?: CanvasElementWhereUniqueInput
    update?: XOR<XOR<CanvasElementUpdateToOneWithWhereWithoutChildrenInput, CanvasElementUpdateWithoutChildrenInput>, CanvasElementUncheckedUpdateWithoutChildrenInput>
  }

  export type CanvasElementUpdateManyWithoutParentNestedInput = {
    create?: XOR<CanvasElementCreateWithoutParentInput, CanvasElementUncheckedCreateWithoutParentInput> | CanvasElementCreateWithoutParentInput[] | CanvasElementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CanvasElementCreateOrConnectWithoutParentInput | CanvasElementCreateOrConnectWithoutParentInput[]
    upsert?: CanvasElementUpsertWithWhereUniqueWithoutParentInput | CanvasElementUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CanvasElementCreateManyParentInputEnvelope
    set?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    disconnect?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    delete?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    connect?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    update?: CanvasElementUpdateWithWhereUniqueWithoutParentInput | CanvasElementUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CanvasElementUpdateManyWithWhereWithoutParentInput | CanvasElementUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CanvasElementScalarWhereInput | CanvasElementScalarWhereInput[]
  }

  export type ElementInteractionUpdateManyWithoutElementNestedInput = {
    create?: XOR<ElementInteractionCreateWithoutElementInput, ElementInteractionUncheckedCreateWithoutElementInput> | ElementInteractionCreateWithoutElementInput[] | ElementInteractionUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ElementInteractionCreateOrConnectWithoutElementInput | ElementInteractionCreateOrConnectWithoutElementInput[]
    upsert?: ElementInteractionUpsertWithWhereUniqueWithoutElementInput | ElementInteractionUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: ElementInteractionCreateManyElementInputEnvelope
    set?: ElementInteractionWhereUniqueInput | ElementInteractionWhereUniqueInput[]
    disconnect?: ElementInteractionWhereUniqueInput | ElementInteractionWhereUniqueInput[]
    delete?: ElementInteractionWhereUniqueInput | ElementInteractionWhereUniqueInput[]
    connect?: ElementInteractionWhereUniqueInput | ElementInteractionWhereUniqueInput[]
    update?: ElementInteractionUpdateWithWhereUniqueWithoutElementInput | ElementInteractionUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: ElementInteractionUpdateManyWithWhereWithoutElementInput | ElementInteractionUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: ElementInteractionScalarWhereInput | ElementInteractionScalarWhereInput[]
  }

  export type ElementValidationUpdateManyWithoutElementNestedInput = {
    create?: XOR<ElementValidationCreateWithoutElementInput, ElementValidationUncheckedCreateWithoutElementInput> | ElementValidationCreateWithoutElementInput[] | ElementValidationUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ElementValidationCreateOrConnectWithoutElementInput | ElementValidationCreateOrConnectWithoutElementInput[]
    upsert?: ElementValidationUpsertWithWhereUniqueWithoutElementInput | ElementValidationUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: ElementValidationCreateManyElementInputEnvelope
    set?: ElementValidationWhereUniqueInput | ElementValidationWhereUniqueInput[]
    disconnect?: ElementValidationWhereUniqueInput | ElementValidationWhereUniqueInput[]
    delete?: ElementValidationWhereUniqueInput | ElementValidationWhereUniqueInput[]
    connect?: ElementValidationWhereUniqueInput | ElementValidationWhereUniqueInput[]
    update?: ElementValidationUpdateWithWhereUniqueWithoutElementInput | ElementValidationUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: ElementValidationUpdateManyWithWhereWithoutElementInput | ElementValidationUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: ElementValidationScalarWhereInput | ElementValidationScalarWhereInput[]
  }

  export type CanvasElementUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<CanvasElementCreateWithoutParentInput, CanvasElementUncheckedCreateWithoutParentInput> | CanvasElementCreateWithoutParentInput[] | CanvasElementUncheckedCreateWithoutParentInput[]
    connectOrCreate?: CanvasElementCreateOrConnectWithoutParentInput | CanvasElementCreateOrConnectWithoutParentInput[]
    upsert?: CanvasElementUpsertWithWhereUniqueWithoutParentInput | CanvasElementUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: CanvasElementCreateManyParentInputEnvelope
    set?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    disconnect?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    delete?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    connect?: CanvasElementWhereUniqueInput | CanvasElementWhereUniqueInput[]
    update?: CanvasElementUpdateWithWhereUniqueWithoutParentInput | CanvasElementUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: CanvasElementUpdateManyWithWhereWithoutParentInput | CanvasElementUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: CanvasElementScalarWhereInput | CanvasElementScalarWhereInput[]
  }

  export type ElementInteractionUncheckedUpdateManyWithoutElementNestedInput = {
    create?: XOR<ElementInteractionCreateWithoutElementInput, ElementInteractionUncheckedCreateWithoutElementInput> | ElementInteractionCreateWithoutElementInput[] | ElementInteractionUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ElementInteractionCreateOrConnectWithoutElementInput | ElementInteractionCreateOrConnectWithoutElementInput[]
    upsert?: ElementInteractionUpsertWithWhereUniqueWithoutElementInput | ElementInteractionUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: ElementInteractionCreateManyElementInputEnvelope
    set?: ElementInteractionWhereUniqueInput | ElementInteractionWhereUniqueInput[]
    disconnect?: ElementInteractionWhereUniqueInput | ElementInteractionWhereUniqueInput[]
    delete?: ElementInteractionWhereUniqueInput | ElementInteractionWhereUniqueInput[]
    connect?: ElementInteractionWhereUniqueInput | ElementInteractionWhereUniqueInput[]
    update?: ElementInteractionUpdateWithWhereUniqueWithoutElementInput | ElementInteractionUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: ElementInteractionUpdateManyWithWhereWithoutElementInput | ElementInteractionUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: ElementInteractionScalarWhereInput | ElementInteractionScalarWhereInput[]
  }

  export type ElementValidationUncheckedUpdateManyWithoutElementNestedInput = {
    create?: XOR<ElementValidationCreateWithoutElementInput, ElementValidationUncheckedCreateWithoutElementInput> | ElementValidationCreateWithoutElementInput[] | ElementValidationUncheckedCreateWithoutElementInput[]
    connectOrCreate?: ElementValidationCreateOrConnectWithoutElementInput | ElementValidationCreateOrConnectWithoutElementInput[]
    upsert?: ElementValidationUpsertWithWhereUniqueWithoutElementInput | ElementValidationUpsertWithWhereUniqueWithoutElementInput[]
    createMany?: ElementValidationCreateManyElementInputEnvelope
    set?: ElementValidationWhereUniqueInput | ElementValidationWhereUniqueInput[]
    disconnect?: ElementValidationWhereUniqueInput | ElementValidationWhereUniqueInput[]
    delete?: ElementValidationWhereUniqueInput | ElementValidationWhereUniqueInput[]
    connect?: ElementValidationWhereUniqueInput | ElementValidationWhereUniqueInput[]
    update?: ElementValidationUpdateWithWhereUniqueWithoutElementInput | ElementValidationUpdateWithWhereUniqueWithoutElementInput[]
    updateMany?: ElementValidationUpdateManyWithWhereWithoutElementInput | ElementValidationUpdateManyWithWhereWithoutElementInput[]
    deleteMany?: ElementValidationScalarWhereInput | ElementValidationScalarWhereInput[]
  }

  export type CanvasElementCreateNestedOneWithoutInteractionsInput = {
    create?: XOR<CanvasElementCreateWithoutInteractionsInput, CanvasElementUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: CanvasElementCreateOrConnectWithoutInteractionsInput
    connect?: CanvasElementWhereUniqueInput
  }

  export type CanvasElementUpdateOneRequiredWithoutInteractionsNestedInput = {
    create?: XOR<CanvasElementCreateWithoutInteractionsInput, CanvasElementUncheckedCreateWithoutInteractionsInput>
    connectOrCreate?: CanvasElementCreateOrConnectWithoutInteractionsInput
    upsert?: CanvasElementUpsertWithoutInteractionsInput
    connect?: CanvasElementWhereUniqueInput
    update?: XOR<XOR<CanvasElementUpdateToOneWithWhereWithoutInteractionsInput, CanvasElementUpdateWithoutInteractionsInput>, CanvasElementUncheckedUpdateWithoutInteractionsInput>
  }

  export type CanvasElementCreateNestedOneWithoutValidationsInput = {
    create?: XOR<CanvasElementCreateWithoutValidationsInput, CanvasElementUncheckedCreateWithoutValidationsInput>
    connectOrCreate?: CanvasElementCreateOrConnectWithoutValidationsInput
    connect?: CanvasElementWhereUniqueInput
  }

  export type CanvasElementUpdateOneRequiredWithoutValidationsNestedInput = {
    create?: XOR<CanvasElementCreateWithoutValidationsInput, CanvasElementUncheckedCreateWithoutValidationsInput>
    connectOrCreate?: CanvasElementCreateOrConnectWithoutValidationsInput
    upsert?: CanvasElementUpsertWithoutValidationsInput
    connect?: CanvasElementWhereUniqueInput
    update?: XOR<XOR<CanvasElementUpdateToOneWithWhereWithoutValidationsInput, CanvasElementUpdateWithoutValidationsInput>, CanvasElementUncheckedUpdateWithoutValidationsInput>
  }

  export type CanvasCreateNestedOneWithoutHistoryInput = {
    create?: XOR<CanvasCreateWithoutHistoryInput, CanvasUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutHistoryInput
    connect?: CanvasWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCanvasHistoryInput = {
    create?: XOR<UserCreateWithoutCanvasHistoryInput, UserUncheckedCreateWithoutCanvasHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutCanvasHistoryInput
    connect?: UserWhereUniqueInput
  }

  export type CanvasUpdateOneRequiredWithoutHistoryNestedInput = {
    create?: XOR<CanvasCreateWithoutHistoryInput, CanvasUncheckedCreateWithoutHistoryInput>
    connectOrCreate?: CanvasCreateOrConnectWithoutHistoryInput
    upsert?: CanvasUpsertWithoutHistoryInput
    connect?: CanvasWhereUniqueInput
    update?: XOR<XOR<CanvasUpdateToOneWithWhereWithoutHistoryInput, CanvasUpdateWithoutHistoryInput>, CanvasUncheckedUpdateWithoutHistoryInput>
  }

  export type UserUpdateOneRequiredWithoutCanvasHistoryNestedInput = {
    create?: XOR<UserCreateWithoutCanvasHistoryInput, UserUncheckedCreateWithoutCanvasHistoryInput>
    connectOrCreate?: UserCreateOrConnectWithoutCanvasHistoryInput
    upsert?: UserUpsertWithoutCanvasHistoryInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCanvasHistoryInput, UserUpdateWithoutCanvasHistoryInput>, UserUncheckedUpdateWithoutCanvasHistoryInput>
  }

  export type UserCreateNestedOneWithoutMediaFilesInput = {
    create?: XOR<UserCreateWithoutMediaFilesInput, UserUncheckedCreateWithoutMediaFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaFilesInput
    connect?: UserWhereUniqueInput
  }

  export type AppCreateNestedOneWithoutMediaFilesInput = {
    create?: XOR<AppCreateWithoutMediaFilesInput, AppUncheckedCreateWithoutMediaFilesInput>
    connectOrCreate?: AppCreateOrConnectWithoutMediaFilesInput
    connect?: AppWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutMediaFilesNestedInput = {
    create?: XOR<UserCreateWithoutMediaFilesInput, UserUncheckedCreateWithoutMediaFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutMediaFilesInput
    upsert?: UserUpsertWithoutMediaFilesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMediaFilesInput, UserUpdateWithoutMediaFilesInput>, UserUncheckedUpdateWithoutMediaFilesInput>
  }

  export type AppUpdateOneWithoutMediaFilesNestedInput = {
    create?: XOR<AppCreateWithoutMediaFilesInput, AppUncheckedCreateWithoutMediaFilesInput>
    connectOrCreate?: AppCreateOrConnectWithoutMediaFilesInput
    upsert?: AppUpsertWithoutMediaFilesInput
    disconnect?: AppWhereInput | boolean
    delete?: AppWhereInput | boolean
    connect?: AppWhereUniqueInput
    update?: XOR<XOR<AppUpdateToOneWithWhereWithoutMediaFilesInput, AppUpdateWithoutMediaFilesInput>, AppUncheckedUpdateWithoutMediaFilesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumAppStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AppStatus | EnumAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppStatusFilter<$PrismaModel> | $Enums.AppStatus
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumAppStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AppStatus | EnumAppStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AppStatus[] | ListEnumAppStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAppStatusWithAggregatesFilter<$PrismaModel> | $Enums.AppStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAppStatusFilter<$PrismaModel>
    _max?: NestedEnumAppStatusFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumFieldTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeFilter<$PrismaModel> | $Enums.FieldType
  }

  export type NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FieldType | EnumFieldTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FieldType[] | ListEnumFieldTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFieldTypeWithAggregatesFilter<$PrismaModel> | $Enums.FieldType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFieldTypeFilter<$PrismaModel>
    _max?: NestedEnumFieldTypeFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumIssueSeverityFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueSeverity | EnumIssueSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IssueSeverity[] | ListEnumIssueSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueSeverity[] | ListEnumIssueSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueSeverityFilter<$PrismaModel> | $Enums.IssueSeverity
  }

  export type NestedEnumIssueStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueStatus | EnumIssueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueStatusFilter<$PrismaModel> | $Enums.IssueStatus
  }

  export type NestedEnumIssueSeverityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueSeverity | EnumIssueSeverityFieldRefInput<$PrismaModel>
    in?: $Enums.IssueSeverity[] | ListEnumIssueSeverityFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueSeverity[] | ListEnumIssueSeverityFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueSeverityWithAggregatesFilter<$PrismaModel> | $Enums.IssueSeverity
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIssueSeverityFilter<$PrismaModel>
    _max?: NestedEnumIssueSeverityFilter<$PrismaModel>
  }

  export type NestedEnumIssueStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.IssueStatus | EnumIssueStatusFieldRefInput<$PrismaModel>
    in?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.IssueStatus[] | ListEnumIssueStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumIssueStatusWithAggregatesFilter<$PrismaModel> | $Enums.IssueStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumIssueStatusFilter<$PrismaModel>
    _max?: NestedEnumIssueStatusFilter<$PrismaModel>
  }

  export type NestedEnumElementTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeFilter<$PrismaModel> | $Enums.ElementType
  }

  export type NestedEnumElementTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ElementType | EnumElementTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ElementType[] | ListEnumElementTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumElementTypeWithAggregatesFilter<$PrismaModel> | $Enums.ElementType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumElementTypeFilter<$PrismaModel>
    _max?: NestedEnumElementTypeFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AppCreateWithoutOwnerInput = {
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    template?: TemplateCreateNestedOneWithoutAppsInput
    components?: ComponentCreateNestedManyWithoutAppInput
    workflows?: WorkflowCreateNestedManyWithoutAppInput
    schemas?: AppSchemaCreateNestedManyWithoutAppInput
    metrics?: AppMetricCreateNestedManyWithoutAppInput
    issues?: AppIssueCreateNestedManyWithoutAppInput
    warnings?: AppWarningCreateNestedManyWithoutAppInput
    canvas?: CanvasCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileCreateNestedManyWithoutAppInput
  }

  export type AppUncheckedCreateWithoutOwnerInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    templateId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ComponentUncheckedCreateNestedManyWithoutAppInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAppInput
    schemas?: AppSchemaUncheckedCreateNestedManyWithoutAppInput
    metrics?: AppMetricUncheckedCreateNestedManyWithoutAppInput
    issues?: AppIssueUncheckedCreateNestedManyWithoutAppInput
    warnings?: AppWarningUncheckedCreateNestedManyWithoutAppInput
    canvas?: CanvasUncheckedCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutAppInput
  }

  export type AppCreateOrConnectWithoutOwnerInput = {
    where: AppWhereUniqueInput
    create: XOR<AppCreateWithoutOwnerInput, AppUncheckedCreateWithoutOwnerInput>
  }

  export type AppCreateManyOwnerInputEnvelope = {
    data: AppCreateManyOwnerInput | AppCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: number
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type CanvasHistoryCreateWithoutUserInput = {
    action: string
    elementId?: string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutHistoryInput
  }

  export type CanvasHistoryUncheckedCreateWithoutUserInput = {
    id?: number
    canvasId: number
    action: string
    elementId?: string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type CanvasHistoryCreateOrConnectWithoutUserInput = {
    where: CanvasHistoryWhereUniqueInput
    create: XOR<CanvasHistoryCreateWithoutUserInput, CanvasHistoryUncheckedCreateWithoutUserInput>
  }

  export type CanvasHistoryCreateManyUserInputEnvelope = {
    data: CanvasHistoryCreateManyUserInput | CanvasHistoryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MediaFileCreateWithoutUserInput = {
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    thumbnail?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    app?: AppCreateNestedOneWithoutMediaFilesInput
  }

  export type MediaFileUncheckedCreateWithoutUserInput = {
    id?: number
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    thumbnail?: string | null
    appId?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MediaFileCreateOrConnectWithoutUserInput = {
    where: MediaFileWhereUniqueInput
    create: XOR<MediaFileCreateWithoutUserInput, MediaFileUncheckedCreateWithoutUserInput>
  }

  export type MediaFileCreateManyUserInputEnvelope = {
    data: MediaFileCreateManyUserInput | MediaFileCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type AppUpsertWithWhereUniqueWithoutOwnerInput = {
    where: AppWhereUniqueInput
    update: XOR<AppUpdateWithoutOwnerInput, AppUncheckedUpdateWithoutOwnerInput>
    create: XOR<AppCreateWithoutOwnerInput, AppUncheckedCreateWithoutOwnerInput>
  }

  export type AppUpdateWithWhereUniqueWithoutOwnerInput = {
    where: AppWhereUniqueInput
    data: XOR<AppUpdateWithoutOwnerInput, AppUncheckedUpdateWithoutOwnerInput>
  }

  export type AppUpdateManyWithWhereWithoutOwnerInput = {
    where: AppScalarWhereInput
    data: XOR<AppUpdateManyMutationInput, AppUncheckedUpdateManyWithoutOwnerInput>
  }

  export type AppScalarWhereInput = {
    AND?: AppScalarWhereInput | AppScalarWhereInput[]
    OR?: AppScalarWhereInput[]
    NOT?: AppScalarWhereInput | AppScalarWhereInput[]
    id?: IntFilter<"App"> | number
    name?: StringFilter<"App"> | string
    description?: StringNullableFilter<"App"> | string | null
    status?: EnumAppStatusFilter<"App"> | $Enums.AppStatus
    archived?: BoolFilter<"App"> | boolean
    ownerId?: IntFilter<"App"> | number
    templateId?: IntNullableFilter<"App"> | number | null
    createdAt?: DateTimeFilter<"App"> | Date | string
    updatedAt?: DateTimeFilter<"App"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: IntFilter<"Notification"> | number
    userId?: IntFilter<"Notification"> | number
    type?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    read?: BoolFilter<"Notification"> | boolean
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type CanvasHistoryUpsertWithWhereUniqueWithoutUserInput = {
    where: CanvasHistoryWhereUniqueInput
    update: XOR<CanvasHistoryUpdateWithoutUserInput, CanvasHistoryUncheckedUpdateWithoutUserInput>
    create: XOR<CanvasHistoryCreateWithoutUserInput, CanvasHistoryUncheckedCreateWithoutUserInput>
  }

  export type CanvasHistoryUpdateWithWhereUniqueWithoutUserInput = {
    where: CanvasHistoryWhereUniqueInput
    data: XOR<CanvasHistoryUpdateWithoutUserInput, CanvasHistoryUncheckedUpdateWithoutUserInput>
  }

  export type CanvasHistoryUpdateManyWithWhereWithoutUserInput = {
    where: CanvasHistoryScalarWhereInput
    data: XOR<CanvasHistoryUpdateManyMutationInput, CanvasHistoryUncheckedUpdateManyWithoutUserInput>
  }

  export type CanvasHistoryScalarWhereInput = {
    AND?: CanvasHistoryScalarWhereInput | CanvasHistoryScalarWhereInput[]
    OR?: CanvasHistoryScalarWhereInput[]
    NOT?: CanvasHistoryScalarWhereInput | CanvasHistoryScalarWhereInput[]
    id?: IntFilter<"CanvasHistory"> | number
    canvasId?: IntFilter<"CanvasHistory"> | number
    action?: StringFilter<"CanvasHistory"> | string
    elementId?: StringNullableFilter<"CanvasHistory"> | string | null
    oldState?: JsonNullableFilter<"CanvasHistory">
    newState?: JsonNullableFilter<"CanvasHistory">
    userId?: IntFilter<"CanvasHistory"> | number
    createdAt?: DateTimeFilter<"CanvasHistory"> | Date | string
  }

  export type MediaFileUpsertWithWhereUniqueWithoutUserInput = {
    where: MediaFileWhereUniqueInput
    update: XOR<MediaFileUpdateWithoutUserInput, MediaFileUncheckedUpdateWithoutUserInput>
    create: XOR<MediaFileCreateWithoutUserInput, MediaFileUncheckedCreateWithoutUserInput>
  }

  export type MediaFileUpdateWithWhereUniqueWithoutUserInput = {
    where: MediaFileWhereUniqueInput
    data: XOR<MediaFileUpdateWithoutUserInput, MediaFileUncheckedUpdateWithoutUserInput>
  }

  export type MediaFileUpdateManyWithWhereWithoutUserInput = {
    where: MediaFileScalarWhereInput
    data: XOR<MediaFileUpdateManyMutationInput, MediaFileUncheckedUpdateManyWithoutUserInput>
  }

  export type MediaFileScalarWhereInput = {
    AND?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
    OR?: MediaFileScalarWhereInput[]
    NOT?: MediaFileScalarWhereInput | MediaFileScalarWhereInput[]
    id?: IntFilter<"MediaFile"> | number
    filename?: StringFilter<"MediaFile"> | string
    originalName?: StringFilter<"MediaFile"> | string
    mimeType?: StringFilter<"MediaFile"> | string
    size?: IntFilter<"MediaFile"> | number
    url?: StringFilter<"MediaFile"> | string
    thumbnail?: StringNullableFilter<"MediaFile"> | string | null
    userId?: IntFilter<"MediaFile"> | number
    appId?: IntNullableFilter<"MediaFile"> | number | null
    metadata?: JsonFilter<"MediaFile">
    createdAt?: DateTimeFilter<"MediaFile"> | Date | string
  }

  export type UserCreateWithoutAppsInput = {
    email: string
    password: string
    createdAt?: Date | string
    role?: string
    updatedAt?: Date | string
    verified?: boolean
    notifications?: NotificationCreateNestedManyWithoutUserInput
    canvasHistory?: CanvasHistoryCreateNestedManyWithoutUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutAppsInput = {
    id?: number
    email: string
    password: string
    createdAt?: Date | string
    role?: string
    updatedAt?: Date | string
    verified?: boolean
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    canvasHistory?: CanvasHistoryUncheckedCreateNestedManyWithoutUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutAppsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAppsInput, UserUncheckedCreateWithoutAppsInput>
  }

  export type TemplateCreateWithoutAppsInput = {
    name: string
    description: string
    preview_image?: string | null
    app_schema: JsonNullValueInput | InputJsonValue
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateUncheckedCreateWithoutAppsInput = {
    id?: number
    name: string
    description: string
    preview_image?: string | null
    app_schema: JsonNullValueInput | InputJsonValue
    category?: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TemplateCreateOrConnectWithoutAppsInput = {
    where: TemplateWhereUniqueInput
    create: XOR<TemplateCreateWithoutAppsInput, TemplateUncheckedCreateWithoutAppsInput>
  }

  export type ComponentCreateWithoutAppInput = {
    name: string
    type: string
    properties: JsonNullValueInput | InputJsonValue
  }

  export type ComponentUncheckedCreateWithoutAppInput = {
    id?: number
    name: string
    type: string
    properties: JsonNullValueInput | InputJsonValue
  }

  export type ComponentCreateOrConnectWithoutAppInput = {
    where: ComponentWhereUniqueInput
    create: XOR<ComponentCreateWithoutAppInput, ComponentUncheckedCreateWithoutAppInput>
  }

  export type ComponentCreateManyAppInputEnvelope = {
    data: ComponentCreateManyAppInput | ComponentCreateManyAppInput[]
    skipDuplicates?: boolean
  }

  export type WorkflowCreateWithoutAppInput = {
    name: string
    steps: JsonNullValueInput | InputJsonValue
  }

  export type WorkflowUncheckedCreateWithoutAppInput = {
    id?: number
    name: string
    steps: JsonNullValueInput | InputJsonValue
  }

  export type WorkflowCreateOrConnectWithoutAppInput = {
    where: WorkflowWhereUniqueInput
    create: XOR<WorkflowCreateWithoutAppInput, WorkflowUncheckedCreateWithoutAppInput>
  }

  export type WorkflowCreateManyAppInputEnvelope = {
    data: WorkflowCreateManyAppInput | WorkflowCreateManyAppInput[]
    skipDuplicates?: boolean
  }

  export type AppSchemaCreateWithoutAppInput = {
    name: string
    createdAt?: Date | string
    data?: AppDataCreateNestedManyWithoutSchemaInput
    relatedFields?: AppFieldCreateNestedManyWithoutRelatedSchemaInput
    fields?: AppFieldCreateNestedManyWithoutSchemaInput
  }

  export type AppSchemaUncheckedCreateWithoutAppInput = {
    id?: number
    name: string
    createdAt?: Date | string
    data?: AppDataUncheckedCreateNestedManyWithoutSchemaInput
    relatedFields?: AppFieldUncheckedCreateNestedManyWithoutRelatedSchemaInput
    fields?: AppFieldUncheckedCreateNestedManyWithoutSchemaInput
  }

  export type AppSchemaCreateOrConnectWithoutAppInput = {
    where: AppSchemaWhereUniqueInput
    create: XOR<AppSchemaCreateWithoutAppInput, AppSchemaUncheckedCreateWithoutAppInput>
  }

  export type AppSchemaCreateManyAppInputEnvelope = {
    data: AppSchemaCreateManyAppInput | AppSchemaCreateManyAppInput[]
    skipDuplicates?: boolean
  }

  export type AppMetricCreateWithoutAppInput = {
    activeDays: number
    downtime: number
    totalUsers: number
    traffic: number
    createdAt?: Date | string
  }

  export type AppMetricUncheckedCreateWithoutAppInput = {
    id?: number
    activeDays: number
    downtime: number
    totalUsers: number
    traffic: number
    createdAt?: Date | string
  }

  export type AppMetricCreateOrConnectWithoutAppInput = {
    where: AppMetricWhereUniqueInput
    create: XOR<AppMetricCreateWithoutAppInput, AppMetricUncheckedCreateWithoutAppInput>
  }

  export type AppMetricCreateManyAppInputEnvelope = {
    data: AppMetricCreateManyAppInput | AppMetricCreateManyAppInput[]
    skipDuplicates?: boolean
  }

  export type AppIssueCreateWithoutAppInput = {
    severity: $Enums.IssueSeverity
    description: string
    status?: $Enums.IssueStatus
    createdAt?: Date | string
  }

  export type AppIssueUncheckedCreateWithoutAppInput = {
    id?: number
    severity: $Enums.IssueSeverity
    description: string
    status?: $Enums.IssueStatus
    createdAt?: Date | string
  }

  export type AppIssueCreateOrConnectWithoutAppInput = {
    where: AppIssueWhereUniqueInput
    create: XOR<AppIssueCreateWithoutAppInput, AppIssueUncheckedCreateWithoutAppInput>
  }

  export type AppIssueCreateManyAppInputEnvelope = {
    data: AppIssueCreateManyAppInput | AppIssueCreateManyAppInput[]
    skipDuplicates?: boolean
  }

  export type AppWarningCreateWithoutAppInput = {
    message: string
    createdAt?: Date | string
  }

  export type AppWarningUncheckedCreateWithoutAppInput = {
    id?: number
    message: string
    createdAt?: Date | string
  }

  export type AppWarningCreateOrConnectWithoutAppInput = {
    where: AppWarningWhereUniqueInput
    create: XOR<AppWarningCreateWithoutAppInput, AppWarningUncheckedCreateWithoutAppInput>
  }

  export type AppWarningCreateManyAppInputEnvelope = {
    data: AppWarningCreateManyAppInput | AppWarningCreateManyAppInput[]
    skipDuplicates?: boolean
  }

  export type CanvasCreateWithoutAppInput = {
    name?: string
    description?: string | null
    width?: number
    height?: number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: boolean
    snapEnabled?: boolean
    zoomLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    elements?: CanvasElementCreateNestedManyWithoutCanvasInput
    history?: CanvasHistoryCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUncheckedCreateWithoutAppInput = {
    id?: number
    name?: string
    description?: string | null
    width?: number
    height?: number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: boolean
    snapEnabled?: boolean
    zoomLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    elements?: CanvasElementUncheckedCreateNestedManyWithoutCanvasInput
    history?: CanvasHistoryUncheckedCreateNestedManyWithoutCanvasInput
  }

  export type CanvasCreateOrConnectWithoutAppInput = {
    where: CanvasWhereUniqueInput
    create: XOR<CanvasCreateWithoutAppInput, CanvasUncheckedCreateWithoutAppInput>
  }

  export type MediaFileCreateWithoutAppInput = {
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    thumbnail?: string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutMediaFilesInput
  }

  export type MediaFileUncheckedCreateWithoutAppInput = {
    id?: number
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    thumbnail?: string | null
    userId: number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MediaFileCreateOrConnectWithoutAppInput = {
    where: MediaFileWhereUniqueInput
    create: XOR<MediaFileCreateWithoutAppInput, MediaFileUncheckedCreateWithoutAppInput>
  }

  export type MediaFileCreateManyAppInputEnvelope = {
    data: MediaFileCreateManyAppInput | MediaFileCreateManyAppInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutAppsInput = {
    update: XOR<UserUpdateWithoutAppsInput, UserUncheckedUpdateWithoutAppsInput>
    create: XOR<UserCreateWithoutAppsInput, UserUncheckedCreateWithoutAppsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAppsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAppsInput, UserUncheckedUpdateWithoutAppsInput>
  }

  export type UserUpdateWithoutAppsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    canvasHistory?: CanvasHistoryUpdateManyWithoutUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutAppsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    canvasHistory?: CanvasHistoryUncheckedUpdateManyWithoutUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUserNestedInput
  }

  export type TemplateUpsertWithoutAppsInput = {
    update: XOR<TemplateUpdateWithoutAppsInput, TemplateUncheckedUpdateWithoutAppsInput>
    create: XOR<TemplateCreateWithoutAppsInput, TemplateUncheckedCreateWithoutAppsInput>
    where?: TemplateWhereInput
  }

  export type TemplateUpdateToOneWithWhereWithoutAppsInput = {
    where?: TemplateWhereInput
    data: XOR<TemplateUpdateWithoutAppsInput, TemplateUncheckedUpdateWithoutAppsInput>
  }

  export type TemplateUpdateWithoutAppsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    preview_image?: NullableStringFieldUpdateOperationsInput | string | null
    app_schema?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TemplateUncheckedUpdateWithoutAppsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    preview_image?: NullableStringFieldUpdateOperationsInput | string | null
    app_schema?: JsonNullValueInput | InputJsonValue
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentUpsertWithWhereUniqueWithoutAppInput = {
    where: ComponentWhereUniqueInput
    update: XOR<ComponentUpdateWithoutAppInput, ComponentUncheckedUpdateWithoutAppInput>
    create: XOR<ComponentCreateWithoutAppInput, ComponentUncheckedCreateWithoutAppInput>
  }

  export type ComponentUpdateWithWhereUniqueWithoutAppInput = {
    where: ComponentWhereUniqueInput
    data: XOR<ComponentUpdateWithoutAppInput, ComponentUncheckedUpdateWithoutAppInput>
  }

  export type ComponentUpdateManyWithWhereWithoutAppInput = {
    where: ComponentScalarWhereInput
    data: XOR<ComponentUpdateManyMutationInput, ComponentUncheckedUpdateManyWithoutAppInput>
  }

  export type ComponentScalarWhereInput = {
    AND?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
    OR?: ComponentScalarWhereInput[]
    NOT?: ComponentScalarWhereInput | ComponentScalarWhereInput[]
    id?: IntFilter<"Component"> | number
    name?: StringFilter<"Component"> | string
    type?: StringFilter<"Component"> | string
    appId?: IntFilter<"Component"> | number
    properties?: JsonFilter<"Component">
  }

  export type WorkflowUpsertWithWhereUniqueWithoutAppInput = {
    where: WorkflowWhereUniqueInput
    update: XOR<WorkflowUpdateWithoutAppInput, WorkflowUncheckedUpdateWithoutAppInput>
    create: XOR<WorkflowCreateWithoutAppInput, WorkflowUncheckedCreateWithoutAppInput>
  }

  export type WorkflowUpdateWithWhereUniqueWithoutAppInput = {
    where: WorkflowWhereUniqueInput
    data: XOR<WorkflowUpdateWithoutAppInput, WorkflowUncheckedUpdateWithoutAppInput>
  }

  export type WorkflowUpdateManyWithWhereWithoutAppInput = {
    where: WorkflowScalarWhereInput
    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutAppInput>
  }

  export type WorkflowScalarWhereInput = {
    AND?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
    OR?: WorkflowScalarWhereInput[]
    NOT?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]
    id?: IntFilter<"Workflow"> | number
    name?: StringFilter<"Workflow"> | string
    appId?: IntFilter<"Workflow"> | number
    steps?: JsonFilter<"Workflow">
  }

  export type AppSchemaUpsertWithWhereUniqueWithoutAppInput = {
    where: AppSchemaWhereUniqueInput
    update: XOR<AppSchemaUpdateWithoutAppInput, AppSchemaUncheckedUpdateWithoutAppInput>
    create: XOR<AppSchemaCreateWithoutAppInput, AppSchemaUncheckedCreateWithoutAppInput>
  }

  export type AppSchemaUpdateWithWhereUniqueWithoutAppInput = {
    where: AppSchemaWhereUniqueInput
    data: XOR<AppSchemaUpdateWithoutAppInput, AppSchemaUncheckedUpdateWithoutAppInput>
  }

  export type AppSchemaUpdateManyWithWhereWithoutAppInput = {
    where: AppSchemaScalarWhereInput
    data: XOR<AppSchemaUpdateManyMutationInput, AppSchemaUncheckedUpdateManyWithoutAppInput>
  }

  export type AppSchemaScalarWhereInput = {
    AND?: AppSchemaScalarWhereInput | AppSchemaScalarWhereInput[]
    OR?: AppSchemaScalarWhereInput[]
    NOT?: AppSchemaScalarWhereInput | AppSchemaScalarWhereInput[]
    id?: IntFilter<"AppSchema"> | number
    appId?: IntFilter<"AppSchema"> | number
    name?: StringFilter<"AppSchema"> | string
    createdAt?: DateTimeFilter<"AppSchema"> | Date | string
  }

  export type AppMetricUpsertWithWhereUniqueWithoutAppInput = {
    where: AppMetricWhereUniqueInput
    update: XOR<AppMetricUpdateWithoutAppInput, AppMetricUncheckedUpdateWithoutAppInput>
    create: XOR<AppMetricCreateWithoutAppInput, AppMetricUncheckedCreateWithoutAppInput>
  }

  export type AppMetricUpdateWithWhereUniqueWithoutAppInput = {
    where: AppMetricWhereUniqueInput
    data: XOR<AppMetricUpdateWithoutAppInput, AppMetricUncheckedUpdateWithoutAppInput>
  }

  export type AppMetricUpdateManyWithWhereWithoutAppInput = {
    where: AppMetricScalarWhereInput
    data: XOR<AppMetricUpdateManyMutationInput, AppMetricUncheckedUpdateManyWithoutAppInput>
  }

  export type AppMetricScalarWhereInput = {
    AND?: AppMetricScalarWhereInput | AppMetricScalarWhereInput[]
    OR?: AppMetricScalarWhereInput[]
    NOT?: AppMetricScalarWhereInput | AppMetricScalarWhereInput[]
    id?: IntFilter<"AppMetric"> | number
    appId?: IntFilter<"AppMetric"> | number
    activeDays?: IntFilter<"AppMetric"> | number
    downtime?: FloatFilter<"AppMetric"> | number
    totalUsers?: IntFilter<"AppMetric"> | number
    traffic?: IntFilter<"AppMetric"> | number
    createdAt?: DateTimeFilter<"AppMetric"> | Date | string
  }

  export type AppIssueUpsertWithWhereUniqueWithoutAppInput = {
    where: AppIssueWhereUniqueInput
    update: XOR<AppIssueUpdateWithoutAppInput, AppIssueUncheckedUpdateWithoutAppInput>
    create: XOR<AppIssueCreateWithoutAppInput, AppIssueUncheckedCreateWithoutAppInput>
  }

  export type AppIssueUpdateWithWhereUniqueWithoutAppInput = {
    where: AppIssueWhereUniqueInput
    data: XOR<AppIssueUpdateWithoutAppInput, AppIssueUncheckedUpdateWithoutAppInput>
  }

  export type AppIssueUpdateManyWithWhereWithoutAppInput = {
    where: AppIssueScalarWhereInput
    data: XOR<AppIssueUpdateManyMutationInput, AppIssueUncheckedUpdateManyWithoutAppInput>
  }

  export type AppIssueScalarWhereInput = {
    AND?: AppIssueScalarWhereInput | AppIssueScalarWhereInput[]
    OR?: AppIssueScalarWhereInput[]
    NOT?: AppIssueScalarWhereInput | AppIssueScalarWhereInput[]
    id?: IntFilter<"AppIssue"> | number
    appId?: IntFilter<"AppIssue"> | number
    severity?: EnumIssueSeverityFilter<"AppIssue"> | $Enums.IssueSeverity
    description?: StringFilter<"AppIssue"> | string
    status?: EnumIssueStatusFilter<"AppIssue"> | $Enums.IssueStatus
    createdAt?: DateTimeFilter<"AppIssue"> | Date | string
  }

  export type AppWarningUpsertWithWhereUniqueWithoutAppInput = {
    where: AppWarningWhereUniqueInput
    update: XOR<AppWarningUpdateWithoutAppInput, AppWarningUncheckedUpdateWithoutAppInput>
    create: XOR<AppWarningCreateWithoutAppInput, AppWarningUncheckedCreateWithoutAppInput>
  }

  export type AppWarningUpdateWithWhereUniqueWithoutAppInput = {
    where: AppWarningWhereUniqueInput
    data: XOR<AppWarningUpdateWithoutAppInput, AppWarningUncheckedUpdateWithoutAppInput>
  }

  export type AppWarningUpdateManyWithWhereWithoutAppInput = {
    where: AppWarningScalarWhereInput
    data: XOR<AppWarningUpdateManyMutationInput, AppWarningUncheckedUpdateManyWithoutAppInput>
  }

  export type AppWarningScalarWhereInput = {
    AND?: AppWarningScalarWhereInput | AppWarningScalarWhereInput[]
    OR?: AppWarningScalarWhereInput[]
    NOT?: AppWarningScalarWhereInput | AppWarningScalarWhereInput[]
    id?: IntFilter<"AppWarning"> | number
    appId?: IntFilter<"AppWarning"> | number
    message?: StringFilter<"AppWarning"> | string
    createdAt?: DateTimeFilter<"AppWarning"> | Date | string
  }

  export type CanvasUpsertWithoutAppInput = {
    update: XOR<CanvasUpdateWithoutAppInput, CanvasUncheckedUpdateWithoutAppInput>
    create: XOR<CanvasCreateWithoutAppInput, CanvasUncheckedCreateWithoutAppInput>
    where?: CanvasWhereInput
  }

  export type CanvasUpdateToOneWithWhereWithoutAppInput = {
    where?: CanvasWhereInput
    data: XOR<CanvasUpdateWithoutAppInput, CanvasUncheckedUpdateWithoutAppInput>
  }

  export type CanvasUpdateWithoutAppInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    snapEnabled?: BoolFieldUpdateOperationsInput | boolean
    zoomLevel?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: CanvasElementUpdateManyWithoutCanvasNestedInput
    history?: CanvasHistoryUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    snapEnabled?: BoolFieldUpdateOperationsInput | boolean
    zoomLevel?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: CanvasElementUncheckedUpdateManyWithoutCanvasNestedInput
    history?: CanvasHistoryUncheckedUpdateManyWithoutCanvasNestedInput
  }

  export type MediaFileUpsertWithWhereUniqueWithoutAppInput = {
    where: MediaFileWhereUniqueInput
    update: XOR<MediaFileUpdateWithoutAppInput, MediaFileUncheckedUpdateWithoutAppInput>
    create: XOR<MediaFileCreateWithoutAppInput, MediaFileUncheckedCreateWithoutAppInput>
  }

  export type MediaFileUpdateWithWhereUniqueWithoutAppInput = {
    where: MediaFileWhereUniqueInput
    data: XOR<MediaFileUpdateWithoutAppInput, MediaFileUncheckedUpdateWithoutAppInput>
  }

  export type MediaFileUpdateManyWithWhereWithoutAppInput = {
    where: MediaFileScalarWhereInput
    data: XOR<MediaFileUpdateManyMutationInput, MediaFileUncheckedUpdateManyWithoutAppInput>
  }

  export type AppCreateWithoutTemplateInput = {
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutAppsInput
    components?: ComponentCreateNestedManyWithoutAppInput
    workflows?: WorkflowCreateNestedManyWithoutAppInput
    schemas?: AppSchemaCreateNestedManyWithoutAppInput
    metrics?: AppMetricCreateNestedManyWithoutAppInput
    issues?: AppIssueCreateNestedManyWithoutAppInput
    warnings?: AppWarningCreateNestedManyWithoutAppInput
    canvas?: CanvasCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileCreateNestedManyWithoutAppInput
  }

  export type AppUncheckedCreateWithoutTemplateInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    ownerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ComponentUncheckedCreateNestedManyWithoutAppInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAppInput
    schemas?: AppSchemaUncheckedCreateNestedManyWithoutAppInput
    metrics?: AppMetricUncheckedCreateNestedManyWithoutAppInput
    issues?: AppIssueUncheckedCreateNestedManyWithoutAppInput
    warnings?: AppWarningUncheckedCreateNestedManyWithoutAppInput
    canvas?: CanvasUncheckedCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutAppInput
  }

  export type AppCreateOrConnectWithoutTemplateInput = {
    where: AppWhereUniqueInput
    create: XOR<AppCreateWithoutTemplateInput, AppUncheckedCreateWithoutTemplateInput>
  }

  export type AppCreateManyTemplateInputEnvelope = {
    data: AppCreateManyTemplateInput | AppCreateManyTemplateInput[]
    skipDuplicates?: boolean
  }

  export type AppUpsertWithWhereUniqueWithoutTemplateInput = {
    where: AppWhereUniqueInput
    update: XOR<AppUpdateWithoutTemplateInput, AppUncheckedUpdateWithoutTemplateInput>
    create: XOR<AppCreateWithoutTemplateInput, AppUncheckedCreateWithoutTemplateInput>
  }

  export type AppUpdateWithWhereUniqueWithoutTemplateInput = {
    where: AppWhereUniqueInput
    data: XOR<AppUpdateWithoutTemplateInput, AppUncheckedUpdateWithoutTemplateInput>
  }

  export type AppUpdateManyWithWhereWithoutTemplateInput = {
    where: AppScalarWhereInput
    data: XOR<AppUpdateManyMutationInput, AppUncheckedUpdateManyWithoutTemplateInput>
  }

  export type AppCreateWithoutComponentsInput = {
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutAppsInput
    template?: TemplateCreateNestedOneWithoutAppsInput
    workflows?: WorkflowCreateNestedManyWithoutAppInput
    schemas?: AppSchemaCreateNestedManyWithoutAppInput
    metrics?: AppMetricCreateNestedManyWithoutAppInput
    issues?: AppIssueCreateNestedManyWithoutAppInput
    warnings?: AppWarningCreateNestedManyWithoutAppInput
    canvas?: CanvasCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileCreateNestedManyWithoutAppInput
  }

  export type AppUncheckedCreateWithoutComponentsInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    ownerId: number
    templateId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAppInput
    schemas?: AppSchemaUncheckedCreateNestedManyWithoutAppInput
    metrics?: AppMetricUncheckedCreateNestedManyWithoutAppInput
    issues?: AppIssueUncheckedCreateNestedManyWithoutAppInput
    warnings?: AppWarningUncheckedCreateNestedManyWithoutAppInput
    canvas?: CanvasUncheckedCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutAppInput
  }

  export type AppCreateOrConnectWithoutComponentsInput = {
    where: AppWhereUniqueInput
    create: XOR<AppCreateWithoutComponentsInput, AppUncheckedCreateWithoutComponentsInput>
  }

  export type AppUpsertWithoutComponentsInput = {
    update: XOR<AppUpdateWithoutComponentsInput, AppUncheckedUpdateWithoutComponentsInput>
    create: XOR<AppCreateWithoutComponentsInput, AppUncheckedCreateWithoutComponentsInput>
    where?: AppWhereInput
  }

  export type AppUpdateToOneWithWhereWithoutComponentsInput = {
    where?: AppWhereInput
    data: XOR<AppUpdateWithoutComponentsInput, AppUncheckedUpdateWithoutComponentsInput>
  }

  export type AppUpdateWithoutComponentsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutAppsNestedInput
    template?: TemplateUpdateOneWithoutAppsNestedInput
    workflows?: WorkflowUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUpdateManyWithoutAppNestedInput
    issues?: AppIssueUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUpdateManyWithoutAppNestedInput
    canvas?: CanvasUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutAppNestedInput
  }

  export type AppUncheckedUpdateWithoutComponentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    workflows?: WorkflowUncheckedUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUncheckedUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUncheckedUpdateManyWithoutAppNestedInput
    issues?: AppIssueUncheckedUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUncheckedUpdateManyWithoutAppNestedInput
    canvas?: CanvasUncheckedUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutAppNestedInput
  }

  export type AppCreateWithoutWorkflowsInput = {
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutAppsInput
    template?: TemplateCreateNestedOneWithoutAppsInput
    components?: ComponentCreateNestedManyWithoutAppInput
    schemas?: AppSchemaCreateNestedManyWithoutAppInput
    metrics?: AppMetricCreateNestedManyWithoutAppInput
    issues?: AppIssueCreateNestedManyWithoutAppInput
    warnings?: AppWarningCreateNestedManyWithoutAppInput
    canvas?: CanvasCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileCreateNestedManyWithoutAppInput
  }

  export type AppUncheckedCreateWithoutWorkflowsInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    ownerId: number
    templateId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ComponentUncheckedCreateNestedManyWithoutAppInput
    schemas?: AppSchemaUncheckedCreateNestedManyWithoutAppInput
    metrics?: AppMetricUncheckedCreateNestedManyWithoutAppInput
    issues?: AppIssueUncheckedCreateNestedManyWithoutAppInput
    warnings?: AppWarningUncheckedCreateNestedManyWithoutAppInput
    canvas?: CanvasUncheckedCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutAppInput
  }

  export type AppCreateOrConnectWithoutWorkflowsInput = {
    where: AppWhereUniqueInput
    create: XOR<AppCreateWithoutWorkflowsInput, AppUncheckedCreateWithoutWorkflowsInput>
  }

  export type AppUpsertWithoutWorkflowsInput = {
    update: XOR<AppUpdateWithoutWorkflowsInput, AppUncheckedUpdateWithoutWorkflowsInput>
    create: XOR<AppCreateWithoutWorkflowsInput, AppUncheckedCreateWithoutWorkflowsInput>
    where?: AppWhereInput
  }

  export type AppUpdateToOneWithWhereWithoutWorkflowsInput = {
    where?: AppWhereInput
    data: XOR<AppUpdateWithoutWorkflowsInput, AppUncheckedUpdateWithoutWorkflowsInput>
  }

  export type AppUpdateWithoutWorkflowsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutAppsNestedInput
    template?: TemplateUpdateOneWithoutAppsNestedInput
    components?: ComponentUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUpdateManyWithoutAppNestedInput
    issues?: AppIssueUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUpdateManyWithoutAppNestedInput
    canvas?: CanvasUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutAppNestedInput
  }

  export type AppUncheckedUpdateWithoutWorkflowsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ComponentUncheckedUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUncheckedUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUncheckedUpdateManyWithoutAppNestedInput
    issues?: AppIssueUncheckedUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUncheckedUpdateManyWithoutAppNestedInput
    canvas?: CanvasUncheckedUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutAppNestedInput
  }

  export type AppDataCreateWithoutSchemaInput = {
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AppDataUncheckedCreateWithoutSchemaInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AppDataCreateOrConnectWithoutSchemaInput = {
    where: AppDataWhereUniqueInput
    create: XOR<AppDataCreateWithoutSchemaInput, AppDataUncheckedCreateWithoutSchemaInput>
  }

  export type AppDataCreateManySchemaInputEnvelope = {
    data: AppDataCreateManySchemaInput | AppDataCreateManySchemaInput[]
    skipDuplicates?: boolean
  }

  export type AppFieldCreateWithoutRelatedSchemaInput = {
    name: string
    type: $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    schema: AppSchemaCreateNestedOneWithoutFieldsInput
  }

  export type AppFieldUncheckedCreateWithoutRelatedSchemaInput = {
    id?: number
    schemaId: number
    name: string
    type: $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AppFieldCreateOrConnectWithoutRelatedSchemaInput = {
    where: AppFieldWhereUniqueInput
    create: XOR<AppFieldCreateWithoutRelatedSchemaInput, AppFieldUncheckedCreateWithoutRelatedSchemaInput>
  }

  export type AppFieldCreateManyRelatedSchemaInputEnvelope = {
    data: AppFieldCreateManyRelatedSchemaInput | AppFieldCreateManyRelatedSchemaInput[]
    skipDuplicates?: boolean
  }

  export type AppFieldCreateWithoutSchemaInput = {
    name: string
    type: $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    relatedSchema?: AppSchemaCreateNestedOneWithoutRelatedFieldsInput
  }

  export type AppFieldUncheckedCreateWithoutSchemaInput = {
    id?: number
    name: string
    type: $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    relatedSchemaId?: number | null
    createdAt?: Date | string
  }

  export type AppFieldCreateOrConnectWithoutSchemaInput = {
    where: AppFieldWhereUniqueInput
    create: XOR<AppFieldCreateWithoutSchemaInput, AppFieldUncheckedCreateWithoutSchemaInput>
  }

  export type AppFieldCreateManySchemaInputEnvelope = {
    data: AppFieldCreateManySchemaInput | AppFieldCreateManySchemaInput[]
    skipDuplicates?: boolean
  }

  export type AppCreateWithoutSchemasInput = {
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutAppsInput
    template?: TemplateCreateNestedOneWithoutAppsInput
    components?: ComponentCreateNestedManyWithoutAppInput
    workflows?: WorkflowCreateNestedManyWithoutAppInput
    metrics?: AppMetricCreateNestedManyWithoutAppInput
    issues?: AppIssueCreateNestedManyWithoutAppInput
    warnings?: AppWarningCreateNestedManyWithoutAppInput
    canvas?: CanvasCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileCreateNestedManyWithoutAppInput
  }

  export type AppUncheckedCreateWithoutSchemasInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    ownerId: number
    templateId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ComponentUncheckedCreateNestedManyWithoutAppInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAppInput
    metrics?: AppMetricUncheckedCreateNestedManyWithoutAppInput
    issues?: AppIssueUncheckedCreateNestedManyWithoutAppInput
    warnings?: AppWarningUncheckedCreateNestedManyWithoutAppInput
    canvas?: CanvasUncheckedCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutAppInput
  }

  export type AppCreateOrConnectWithoutSchemasInput = {
    where: AppWhereUniqueInput
    create: XOR<AppCreateWithoutSchemasInput, AppUncheckedCreateWithoutSchemasInput>
  }

  export type AppDataUpsertWithWhereUniqueWithoutSchemaInput = {
    where: AppDataWhereUniqueInput
    update: XOR<AppDataUpdateWithoutSchemaInput, AppDataUncheckedUpdateWithoutSchemaInput>
    create: XOR<AppDataCreateWithoutSchemaInput, AppDataUncheckedCreateWithoutSchemaInput>
  }

  export type AppDataUpdateWithWhereUniqueWithoutSchemaInput = {
    where: AppDataWhereUniqueInput
    data: XOR<AppDataUpdateWithoutSchemaInput, AppDataUncheckedUpdateWithoutSchemaInput>
  }

  export type AppDataUpdateManyWithWhereWithoutSchemaInput = {
    where: AppDataScalarWhereInput
    data: XOR<AppDataUpdateManyMutationInput, AppDataUncheckedUpdateManyWithoutSchemaInput>
  }

  export type AppDataScalarWhereInput = {
    AND?: AppDataScalarWhereInput | AppDataScalarWhereInput[]
    OR?: AppDataScalarWhereInput[]
    NOT?: AppDataScalarWhereInput | AppDataScalarWhereInput[]
    id?: IntFilter<"AppData"> | number
    schemaId?: IntFilter<"AppData"> | number
    data?: JsonFilter<"AppData">
    createdAt?: DateTimeFilter<"AppData"> | Date | string
  }

  export type AppFieldUpsertWithWhereUniqueWithoutRelatedSchemaInput = {
    where: AppFieldWhereUniqueInput
    update: XOR<AppFieldUpdateWithoutRelatedSchemaInput, AppFieldUncheckedUpdateWithoutRelatedSchemaInput>
    create: XOR<AppFieldCreateWithoutRelatedSchemaInput, AppFieldUncheckedCreateWithoutRelatedSchemaInput>
  }

  export type AppFieldUpdateWithWhereUniqueWithoutRelatedSchemaInput = {
    where: AppFieldWhereUniqueInput
    data: XOR<AppFieldUpdateWithoutRelatedSchemaInput, AppFieldUncheckedUpdateWithoutRelatedSchemaInput>
  }

  export type AppFieldUpdateManyWithWhereWithoutRelatedSchemaInput = {
    where: AppFieldScalarWhereInput
    data: XOR<AppFieldUpdateManyMutationInput, AppFieldUncheckedUpdateManyWithoutRelatedSchemaInput>
  }

  export type AppFieldScalarWhereInput = {
    AND?: AppFieldScalarWhereInput | AppFieldScalarWhereInput[]
    OR?: AppFieldScalarWhereInput[]
    NOT?: AppFieldScalarWhereInput | AppFieldScalarWhereInput[]
    id?: IntFilter<"AppField"> | number
    schemaId?: IntFilter<"AppField"> | number
    name?: StringFilter<"AppField"> | string
    type?: EnumFieldTypeFilter<"AppField"> | $Enums.FieldType
    constraints?: JsonFilter<"AppField">
    relatedSchemaId?: IntNullableFilter<"AppField"> | number | null
    createdAt?: DateTimeFilter<"AppField"> | Date | string
  }

  export type AppFieldUpsertWithWhereUniqueWithoutSchemaInput = {
    where: AppFieldWhereUniqueInput
    update: XOR<AppFieldUpdateWithoutSchemaInput, AppFieldUncheckedUpdateWithoutSchemaInput>
    create: XOR<AppFieldCreateWithoutSchemaInput, AppFieldUncheckedCreateWithoutSchemaInput>
  }

  export type AppFieldUpdateWithWhereUniqueWithoutSchemaInput = {
    where: AppFieldWhereUniqueInput
    data: XOR<AppFieldUpdateWithoutSchemaInput, AppFieldUncheckedUpdateWithoutSchemaInput>
  }

  export type AppFieldUpdateManyWithWhereWithoutSchemaInput = {
    where: AppFieldScalarWhereInput
    data: XOR<AppFieldUpdateManyMutationInput, AppFieldUncheckedUpdateManyWithoutSchemaInput>
  }

  export type AppUpsertWithoutSchemasInput = {
    update: XOR<AppUpdateWithoutSchemasInput, AppUncheckedUpdateWithoutSchemasInput>
    create: XOR<AppCreateWithoutSchemasInput, AppUncheckedCreateWithoutSchemasInput>
    where?: AppWhereInput
  }

  export type AppUpdateToOneWithWhereWithoutSchemasInput = {
    where?: AppWhereInput
    data: XOR<AppUpdateWithoutSchemasInput, AppUncheckedUpdateWithoutSchemasInput>
  }

  export type AppUpdateWithoutSchemasInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutAppsNestedInput
    template?: TemplateUpdateOneWithoutAppsNestedInput
    components?: ComponentUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUpdateManyWithoutAppNestedInput
    issues?: AppIssueUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUpdateManyWithoutAppNestedInput
    canvas?: CanvasUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutAppNestedInput
  }

  export type AppUncheckedUpdateWithoutSchemasInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ComponentUncheckedUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUncheckedUpdateManyWithoutAppNestedInput
    issues?: AppIssueUncheckedUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUncheckedUpdateManyWithoutAppNestedInput
    canvas?: CanvasUncheckedUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutAppNestedInput
  }

  export type AppSchemaCreateWithoutRelatedFieldsInput = {
    name: string
    createdAt?: Date | string
    data?: AppDataCreateNestedManyWithoutSchemaInput
    fields?: AppFieldCreateNestedManyWithoutSchemaInput
    app: AppCreateNestedOneWithoutSchemasInput
  }

  export type AppSchemaUncheckedCreateWithoutRelatedFieldsInput = {
    id?: number
    appId: number
    name: string
    createdAt?: Date | string
    data?: AppDataUncheckedCreateNestedManyWithoutSchemaInput
    fields?: AppFieldUncheckedCreateNestedManyWithoutSchemaInput
  }

  export type AppSchemaCreateOrConnectWithoutRelatedFieldsInput = {
    where: AppSchemaWhereUniqueInput
    create: XOR<AppSchemaCreateWithoutRelatedFieldsInput, AppSchemaUncheckedCreateWithoutRelatedFieldsInput>
  }

  export type AppSchemaCreateWithoutFieldsInput = {
    name: string
    createdAt?: Date | string
    data?: AppDataCreateNestedManyWithoutSchemaInput
    relatedFields?: AppFieldCreateNestedManyWithoutRelatedSchemaInput
    app: AppCreateNestedOneWithoutSchemasInput
  }

  export type AppSchemaUncheckedCreateWithoutFieldsInput = {
    id?: number
    appId: number
    name: string
    createdAt?: Date | string
    data?: AppDataUncheckedCreateNestedManyWithoutSchemaInput
    relatedFields?: AppFieldUncheckedCreateNestedManyWithoutRelatedSchemaInput
  }

  export type AppSchemaCreateOrConnectWithoutFieldsInput = {
    where: AppSchemaWhereUniqueInput
    create: XOR<AppSchemaCreateWithoutFieldsInput, AppSchemaUncheckedCreateWithoutFieldsInput>
  }

  export type AppSchemaUpsertWithoutRelatedFieldsInput = {
    update: XOR<AppSchemaUpdateWithoutRelatedFieldsInput, AppSchemaUncheckedUpdateWithoutRelatedFieldsInput>
    create: XOR<AppSchemaCreateWithoutRelatedFieldsInput, AppSchemaUncheckedCreateWithoutRelatedFieldsInput>
    where?: AppSchemaWhereInput
  }

  export type AppSchemaUpdateToOneWithWhereWithoutRelatedFieldsInput = {
    where?: AppSchemaWhereInput
    data: XOR<AppSchemaUpdateWithoutRelatedFieldsInput, AppSchemaUncheckedUpdateWithoutRelatedFieldsInput>
  }

  export type AppSchemaUpdateWithoutRelatedFieldsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: AppDataUpdateManyWithoutSchemaNestedInput
    fields?: AppFieldUpdateManyWithoutSchemaNestedInput
    app?: AppUpdateOneRequiredWithoutSchemasNestedInput
  }

  export type AppSchemaUncheckedUpdateWithoutRelatedFieldsInput = {
    id?: IntFieldUpdateOperationsInput | number
    appId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: AppDataUncheckedUpdateManyWithoutSchemaNestedInput
    fields?: AppFieldUncheckedUpdateManyWithoutSchemaNestedInput
  }

  export type AppSchemaUpsertWithoutFieldsInput = {
    update: XOR<AppSchemaUpdateWithoutFieldsInput, AppSchemaUncheckedUpdateWithoutFieldsInput>
    create: XOR<AppSchemaCreateWithoutFieldsInput, AppSchemaUncheckedCreateWithoutFieldsInput>
    where?: AppSchemaWhereInput
  }

  export type AppSchemaUpdateToOneWithWhereWithoutFieldsInput = {
    where?: AppSchemaWhereInput
    data: XOR<AppSchemaUpdateWithoutFieldsInput, AppSchemaUncheckedUpdateWithoutFieldsInput>
  }

  export type AppSchemaUpdateWithoutFieldsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: AppDataUpdateManyWithoutSchemaNestedInput
    relatedFields?: AppFieldUpdateManyWithoutRelatedSchemaNestedInput
    app?: AppUpdateOneRequiredWithoutSchemasNestedInput
  }

  export type AppSchemaUncheckedUpdateWithoutFieldsInput = {
    id?: IntFieldUpdateOperationsInput | number
    appId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: AppDataUncheckedUpdateManyWithoutSchemaNestedInput
    relatedFields?: AppFieldUncheckedUpdateManyWithoutRelatedSchemaNestedInput
  }

  export type AppSchemaCreateWithoutDataInput = {
    name: string
    createdAt?: Date | string
    relatedFields?: AppFieldCreateNestedManyWithoutRelatedSchemaInput
    fields?: AppFieldCreateNestedManyWithoutSchemaInput
    app: AppCreateNestedOneWithoutSchemasInput
  }

  export type AppSchemaUncheckedCreateWithoutDataInput = {
    id?: number
    appId: number
    name: string
    createdAt?: Date | string
    relatedFields?: AppFieldUncheckedCreateNestedManyWithoutRelatedSchemaInput
    fields?: AppFieldUncheckedCreateNestedManyWithoutSchemaInput
  }

  export type AppSchemaCreateOrConnectWithoutDataInput = {
    where: AppSchemaWhereUniqueInput
    create: XOR<AppSchemaCreateWithoutDataInput, AppSchemaUncheckedCreateWithoutDataInput>
  }

  export type AppSchemaUpsertWithoutDataInput = {
    update: XOR<AppSchemaUpdateWithoutDataInput, AppSchemaUncheckedUpdateWithoutDataInput>
    create: XOR<AppSchemaCreateWithoutDataInput, AppSchemaUncheckedCreateWithoutDataInput>
    where?: AppSchemaWhereInput
  }

  export type AppSchemaUpdateToOneWithWhereWithoutDataInput = {
    where?: AppSchemaWhereInput
    data: XOR<AppSchemaUpdateWithoutDataInput, AppSchemaUncheckedUpdateWithoutDataInput>
  }

  export type AppSchemaUpdateWithoutDataInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedFields?: AppFieldUpdateManyWithoutRelatedSchemaNestedInput
    fields?: AppFieldUpdateManyWithoutSchemaNestedInput
    app?: AppUpdateOneRequiredWithoutSchemasNestedInput
  }

  export type AppSchemaUncheckedUpdateWithoutDataInput = {
    id?: IntFieldUpdateOperationsInput | number
    appId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedFields?: AppFieldUncheckedUpdateManyWithoutRelatedSchemaNestedInput
    fields?: AppFieldUncheckedUpdateManyWithoutSchemaNestedInput
  }

  export type AppCreateWithoutMetricsInput = {
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutAppsInput
    template?: TemplateCreateNestedOneWithoutAppsInput
    components?: ComponentCreateNestedManyWithoutAppInput
    workflows?: WorkflowCreateNestedManyWithoutAppInput
    schemas?: AppSchemaCreateNestedManyWithoutAppInput
    issues?: AppIssueCreateNestedManyWithoutAppInput
    warnings?: AppWarningCreateNestedManyWithoutAppInput
    canvas?: CanvasCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileCreateNestedManyWithoutAppInput
  }

  export type AppUncheckedCreateWithoutMetricsInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    ownerId: number
    templateId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ComponentUncheckedCreateNestedManyWithoutAppInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAppInput
    schemas?: AppSchemaUncheckedCreateNestedManyWithoutAppInput
    issues?: AppIssueUncheckedCreateNestedManyWithoutAppInput
    warnings?: AppWarningUncheckedCreateNestedManyWithoutAppInput
    canvas?: CanvasUncheckedCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutAppInput
  }

  export type AppCreateOrConnectWithoutMetricsInput = {
    where: AppWhereUniqueInput
    create: XOR<AppCreateWithoutMetricsInput, AppUncheckedCreateWithoutMetricsInput>
  }

  export type AppUpsertWithoutMetricsInput = {
    update: XOR<AppUpdateWithoutMetricsInput, AppUncheckedUpdateWithoutMetricsInput>
    create: XOR<AppCreateWithoutMetricsInput, AppUncheckedCreateWithoutMetricsInput>
    where?: AppWhereInput
  }

  export type AppUpdateToOneWithWhereWithoutMetricsInput = {
    where?: AppWhereInput
    data: XOR<AppUpdateWithoutMetricsInput, AppUncheckedUpdateWithoutMetricsInput>
  }

  export type AppUpdateWithoutMetricsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutAppsNestedInput
    template?: TemplateUpdateOneWithoutAppsNestedInput
    components?: ComponentUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUpdateManyWithoutAppNestedInput
    issues?: AppIssueUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUpdateManyWithoutAppNestedInput
    canvas?: CanvasUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutAppNestedInput
  }

  export type AppUncheckedUpdateWithoutMetricsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ComponentUncheckedUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUncheckedUpdateManyWithoutAppNestedInput
    issues?: AppIssueUncheckedUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUncheckedUpdateManyWithoutAppNestedInput
    canvas?: CanvasUncheckedUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutAppNestedInput
  }

  export type AppCreateWithoutIssuesInput = {
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutAppsInput
    template?: TemplateCreateNestedOneWithoutAppsInput
    components?: ComponentCreateNestedManyWithoutAppInput
    workflows?: WorkflowCreateNestedManyWithoutAppInput
    schemas?: AppSchemaCreateNestedManyWithoutAppInput
    metrics?: AppMetricCreateNestedManyWithoutAppInput
    warnings?: AppWarningCreateNestedManyWithoutAppInput
    canvas?: CanvasCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileCreateNestedManyWithoutAppInput
  }

  export type AppUncheckedCreateWithoutIssuesInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    ownerId: number
    templateId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ComponentUncheckedCreateNestedManyWithoutAppInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAppInput
    schemas?: AppSchemaUncheckedCreateNestedManyWithoutAppInput
    metrics?: AppMetricUncheckedCreateNestedManyWithoutAppInput
    warnings?: AppWarningUncheckedCreateNestedManyWithoutAppInput
    canvas?: CanvasUncheckedCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutAppInput
  }

  export type AppCreateOrConnectWithoutIssuesInput = {
    where: AppWhereUniqueInput
    create: XOR<AppCreateWithoutIssuesInput, AppUncheckedCreateWithoutIssuesInput>
  }

  export type AppUpsertWithoutIssuesInput = {
    update: XOR<AppUpdateWithoutIssuesInput, AppUncheckedUpdateWithoutIssuesInput>
    create: XOR<AppCreateWithoutIssuesInput, AppUncheckedCreateWithoutIssuesInput>
    where?: AppWhereInput
  }

  export type AppUpdateToOneWithWhereWithoutIssuesInput = {
    where?: AppWhereInput
    data: XOR<AppUpdateWithoutIssuesInput, AppUncheckedUpdateWithoutIssuesInput>
  }

  export type AppUpdateWithoutIssuesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutAppsNestedInput
    template?: TemplateUpdateOneWithoutAppsNestedInput
    components?: ComponentUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUpdateManyWithoutAppNestedInput
    canvas?: CanvasUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutAppNestedInput
  }

  export type AppUncheckedUpdateWithoutIssuesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ComponentUncheckedUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUncheckedUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUncheckedUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUncheckedUpdateManyWithoutAppNestedInput
    canvas?: CanvasUncheckedUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutAppNestedInput
  }

  export type AppCreateWithoutWarningsInput = {
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutAppsInput
    template?: TemplateCreateNestedOneWithoutAppsInput
    components?: ComponentCreateNestedManyWithoutAppInput
    workflows?: WorkflowCreateNestedManyWithoutAppInput
    schemas?: AppSchemaCreateNestedManyWithoutAppInput
    metrics?: AppMetricCreateNestedManyWithoutAppInput
    issues?: AppIssueCreateNestedManyWithoutAppInput
    canvas?: CanvasCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileCreateNestedManyWithoutAppInput
  }

  export type AppUncheckedCreateWithoutWarningsInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    ownerId: number
    templateId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ComponentUncheckedCreateNestedManyWithoutAppInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAppInput
    schemas?: AppSchemaUncheckedCreateNestedManyWithoutAppInput
    metrics?: AppMetricUncheckedCreateNestedManyWithoutAppInput
    issues?: AppIssueUncheckedCreateNestedManyWithoutAppInput
    canvas?: CanvasUncheckedCreateNestedOneWithoutAppInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutAppInput
  }

  export type AppCreateOrConnectWithoutWarningsInput = {
    where: AppWhereUniqueInput
    create: XOR<AppCreateWithoutWarningsInput, AppUncheckedCreateWithoutWarningsInput>
  }

  export type AppUpsertWithoutWarningsInput = {
    update: XOR<AppUpdateWithoutWarningsInput, AppUncheckedUpdateWithoutWarningsInput>
    create: XOR<AppCreateWithoutWarningsInput, AppUncheckedCreateWithoutWarningsInput>
    where?: AppWhereInput
  }

  export type AppUpdateToOneWithWhereWithoutWarningsInput = {
    where?: AppWhereInput
    data: XOR<AppUpdateWithoutWarningsInput, AppUncheckedUpdateWithoutWarningsInput>
  }

  export type AppUpdateWithoutWarningsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutAppsNestedInput
    template?: TemplateUpdateOneWithoutAppsNestedInput
    components?: ComponentUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUpdateManyWithoutAppNestedInput
    issues?: AppIssueUpdateManyWithoutAppNestedInput
    canvas?: CanvasUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutAppNestedInput
  }

  export type AppUncheckedUpdateWithoutWarningsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ComponentUncheckedUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUncheckedUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUncheckedUpdateManyWithoutAppNestedInput
    issues?: AppIssueUncheckedUpdateManyWithoutAppNestedInput
    canvas?: CanvasUncheckedUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutAppNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    email: string
    password: string
    createdAt?: Date | string
    role?: string
    updatedAt?: Date | string
    verified?: boolean
    apps?: AppCreateNestedManyWithoutOwnerInput
    canvasHistory?: CanvasHistoryCreateNestedManyWithoutUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: number
    email: string
    password: string
    createdAt?: Date | string
    role?: string
    updatedAt?: Date | string
    verified?: boolean
    apps?: AppUncheckedCreateNestedManyWithoutOwnerInput
    canvasHistory?: CanvasHistoryUncheckedCreateNestedManyWithoutUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    apps?: AppUpdateManyWithoutOwnerNestedInput
    canvasHistory?: CanvasHistoryUpdateManyWithoutUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    apps?: AppUncheckedUpdateManyWithoutOwnerNestedInput
    canvasHistory?: CanvasHistoryUncheckedUpdateManyWithoutUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AppCreateWithoutCanvasInput = {
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutAppsInput
    template?: TemplateCreateNestedOneWithoutAppsInput
    components?: ComponentCreateNestedManyWithoutAppInput
    workflows?: WorkflowCreateNestedManyWithoutAppInput
    schemas?: AppSchemaCreateNestedManyWithoutAppInput
    metrics?: AppMetricCreateNestedManyWithoutAppInput
    issues?: AppIssueCreateNestedManyWithoutAppInput
    warnings?: AppWarningCreateNestedManyWithoutAppInput
    mediaFiles?: MediaFileCreateNestedManyWithoutAppInput
  }

  export type AppUncheckedCreateWithoutCanvasInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    ownerId: number
    templateId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ComponentUncheckedCreateNestedManyWithoutAppInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAppInput
    schemas?: AppSchemaUncheckedCreateNestedManyWithoutAppInput
    metrics?: AppMetricUncheckedCreateNestedManyWithoutAppInput
    issues?: AppIssueUncheckedCreateNestedManyWithoutAppInput
    warnings?: AppWarningUncheckedCreateNestedManyWithoutAppInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutAppInput
  }

  export type AppCreateOrConnectWithoutCanvasInput = {
    where: AppWhereUniqueInput
    create: XOR<AppCreateWithoutCanvasInput, AppUncheckedCreateWithoutCanvasInput>
  }

  export type CanvasElementCreateWithoutCanvasInput = {
    elementId: string
    type: $Enums.ElementType
    name?: string
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    zIndex?: number
    locked?: boolean
    visible?: boolean
    groupId?: string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    parent?: CanvasElementCreateNestedOneWithoutChildrenInput
    children?: CanvasElementCreateNestedManyWithoutParentInput
    interactions?: ElementInteractionCreateNestedManyWithoutElementInput
    validations?: ElementValidationCreateNestedManyWithoutElementInput
  }

  export type CanvasElementUncheckedCreateWithoutCanvasInput = {
    id?: number
    elementId: string
    type: $Enums.ElementType
    name?: string
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    zIndex?: number
    locked?: boolean
    visible?: boolean
    groupId?: string | null
    parentId?: number | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CanvasElementUncheckedCreateNestedManyWithoutParentInput
    interactions?: ElementInteractionUncheckedCreateNestedManyWithoutElementInput
    validations?: ElementValidationUncheckedCreateNestedManyWithoutElementInput
  }

  export type CanvasElementCreateOrConnectWithoutCanvasInput = {
    where: CanvasElementWhereUniqueInput
    create: XOR<CanvasElementCreateWithoutCanvasInput, CanvasElementUncheckedCreateWithoutCanvasInput>
  }

  export type CanvasElementCreateManyCanvasInputEnvelope = {
    data: CanvasElementCreateManyCanvasInput | CanvasElementCreateManyCanvasInput[]
    skipDuplicates?: boolean
  }

  export type CanvasHistoryCreateWithoutCanvasInput = {
    action: string
    elementId?: string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutCanvasHistoryInput
  }

  export type CanvasHistoryUncheckedCreateWithoutCanvasInput = {
    id?: number
    action: string
    elementId?: string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    userId: number
    createdAt?: Date | string
  }

  export type CanvasHistoryCreateOrConnectWithoutCanvasInput = {
    where: CanvasHistoryWhereUniqueInput
    create: XOR<CanvasHistoryCreateWithoutCanvasInput, CanvasHistoryUncheckedCreateWithoutCanvasInput>
  }

  export type CanvasHistoryCreateManyCanvasInputEnvelope = {
    data: CanvasHistoryCreateManyCanvasInput | CanvasHistoryCreateManyCanvasInput[]
    skipDuplicates?: boolean
  }

  export type AppUpsertWithoutCanvasInput = {
    update: XOR<AppUpdateWithoutCanvasInput, AppUncheckedUpdateWithoutCanvasInput>
    create: XOR<AppCreateWithoutCanvasInput, AppUncheckedCreateWithoutCanvasInput>
    where?: AppWhereInput
  }

  export type AppUpdateToOneWithWhereWithoutCanvasInput = {
    where?: AppWhereInput
    data: XOR<AppUpdateWithoutCanvasInput, AppUncheckedUpdateWithoutCanvasInput>
  }

  export type AppUpdateWithoutCanvasInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutAppsNestedInput
    template?: TemplateUpdateOneWithoutAppsNestedInput
    components?: ComponentUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUpdateManyWithoutAppNestedInput
    issues?: AppIssueUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUpdateManyWithoutAppNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutAppNestedInput
  }

  export type AppUncheckedUpdateWithoutCanvasInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ComponentUncheckedUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUncheckedUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUncheckedUpdateManyWithoutAppNestedInput
    issues?: AppIssueUncheckedUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUncheckedUpdateManyWithoutAppNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutAppNestedInput
  }

  export type CanvasElementUpsertWithWhereUniqueWithoutCanvasInput = {
    where: CanvasElementWhereUniqueInput
    update: XOR<CanvasElementUpdateWithoutCanvasInput, CanvasElementUncheckedUpdateWithoutCanvasInput>
    create: XOR<CanvasElementCreateWithoutCanvasInput, CanvasElementUncheckedCreateWithoutCanvasInput>
  }

  export type CanvasElementUpdateWithWhereUniqueWithoutCanvasInput = {
    where: CanvasElementWhereUniqueInput
    data: XOR<CanvasElementUpdateWithoutCanvasInput, CanvasElementUncheckedUpdateWithoutCanvasInput>
  }

  export type CanvasElementUpdateManyWithWhereWithoutCanvasInput = {
    where: CanvasElementScalarWhereInput
    data: XOR<CanvasElementUpdateManyMutationInput, CanvasElementUncheckedUpdateManyWithoutCanvasInput>
  }

  export type CanvasElementScalarWhereInput = {
    AND?: CanvasElementScalarWhereInput | CanvasElementScalarWhereInput[]
    OR?: CanvasElementScalarWhereInput[]
    NOT?: CanvasElementScalarWhereInput | CanvasElementScalarWhereInput[]
    id?: IntFilter<"CanvasElement"> | number
    canvasId?: IntFilter<"CanvasElement"> | number
    elementId?: StringFilter<"CanvasElement"> | string
    type?: EnumElementTypeFilter<"CanvasElement"> | $Enums.ElementType
    name?: StringFilter<"CanvasElement"> | string
    x?: FloatFilter<"CanvasElement"> | number
    y?: FloatFilter<"CanvasElement"> | number
    width?: FloatFilter<"CanvasElement"> | number
    height?: FloatFilter<"CanvasElement"> | number
    rotation?: FloatFilter<"CanvasElement"> | number
    zIndex?: IntFilter<"CanvasElement"> | number
    locked?: BoolFilter<"CanvasElement"> | boolean
    visible?: BoolFilter<"CanvasElement"> | boolean
    groupId?: StringNullableFilter<"CanvasElement"> | string | null
    parentId?: IntNullableFilter<"CanvasElement"> | number | null
    properties?: JsonFilter<"CanvasElement">
    styles?: JsonFilter<"CanvasElement">
    constraints?: JsonFilter<"CanvasElement">
    createdAt?: DateTimeFilter<"CanvasElement"> | Date | string
    updatedAt?: DateTimeFilter<"CanvasElement"> | Date | string
  }

  export type CanvasHistoryUpsertWithWhereUniqueWithoutCanvasInput = {
    where: CanvasHistoryWhereUniqueInput
    update: XOR<CanvasHistoryUpdateWithoutCanvasInput, CanvasHistoryUncheckedUpdateWithoutCanvasInput>
    create: XOR<CanvasHistoryCreateWithoutCanvasInput, CanvasHistoryUncheckedCreateWithoutCanvasInput>
  }

  export type CanvasHistoryUpdateWithWhereUniqueWithoutCanvasInput = {
    where: CanvasHistoryWhereUniqueInput
    data: XOR<CanvasHistoryUpdateWithoutCanvasInput, CanvasHistoryUncheckedUpdateWithoutCanvasInput>
  }

  export type CanvasHistoryUpdateManyWithWhereWithoutCanvasInput = {
    where: CanvasHistoryScalarWhereInput
    data: XOR<CanvasHistoryUpdateManyMutationInput, CanvasHistoryUncheckedUpdateManyWithoutCanvasInput>
  }

  export type CanvasCreateWithoutElementsInput = {
    name?: string
    description?: string | null
    width?: number
    height?: number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: boolean
    snapEnabled?: boolean
    zoomLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    app: AppCreateNestedOneWithoutCanvasInput
    history?: CanvasHistoryCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUncheckedCreateWithoutElementsInput = {
    id?: number
    appId: number
    name?: string
    description?: string | null
    width?: number
    height?: number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: boolean
    snapEnabled?: boolean
    zoomLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    history?: CanvasHistoryUncheckedCreateNestedManyWithoutCanvasInput
  }

  export type CanvasCreateOrConnectWithoutElementsInput = {
    where: CanvasWhereUniqueInput
    create: XOR<CanvasCreateWithoutElementsInput, CanvasUncheckedCreateWithoutElementsInput>
  }

  export type CanvasElementCreateWithoutChildrenInput = {
    elementId: string
    type: $Enums.ElementType
    name?: string
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    zIndex?: number
    locked?: boolean
    visible?: boolean
    groupId?: string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutElementsInput
    parent?: CanvasElementCreateNestedOneWithoutChildrenInput
    interactions?: ElementInteractionCreateNestedManyWithoutElementInput
    validations?: ElementValidationCreateNestedManyWithoutElementInput
  }

  export type CanvasElementUncheckedCreateWithoutChildrenInput = {
    id?: number
    canvasId: number
    elementId: string
    type: $Enums.ElementType
    name?: string
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    zIndex?: number
    locked?: boolean
    visible?: boolean
    groupId?: string | null
    parentId?: number | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    interactions?: ElementInteractionUncheckedCreateNestedManyWithoutElementInput
    validations?: ElementValidationUncheckedCreateNestedManyWithoutElementInput
  }

  export type CanvasElementCreateOrConnectWithoutChildrenInput = {
    where: CanvasElementWhereUniqueInput
    create: XOR<CanvasElementCreateWithoutChildrenInput, CanvasElementUncheckedCreateWithoutChildrenInput>
  }

  export type CanvasElementCreateWithoutParentInput = {
    elementId: string
    type: $Enums.ElementType
    name?: string
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    zIndex?: number
    locked?: boolean
    visible?: boolean
    groupId?: string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutElementsInput
    children?: CanvasElementCreateNestedManyWithoutParentInput
    interactions?: ElementInteractionCreateNestedManyWithoutElementInput
    validations?: ElementValidationCreateNestedManyWithoutElementInput
  }

  export type CanvasElementUncheckedCreateWithoutParentInput = {
    id?: number
    canvasId: number
    elementId: string
    type: $Enums.ElementType
    name?: string
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    zIndex?: number
    locked?: boolean
    visible?: boolean
    groupId?: string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CanvasElementUncheckedCreateNestedManyWithoutParentInput
    interactions?: ElementInteractionUncheckedCreateNestedManyWithoutElementInput
    validations?: ElementValidationUncheckedCreateNestedManyWithoutElementInput
  }

  export type CanvasElementCreateOrConnectWithoutParentInput = {
    where: CanvasElementWhereUniqueInput
    create: XOR<CanvasElementCreateWithoutParentInput, CanvasElementUncheckedCreateWithoutParentInput>
  }

  export type CanvasElementCreateManyParentInputEnvelope = {
    data: CanvasElementCreateManyParentInput | CanvasElementCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type ElementInteractionCreateWithoutElementInput = {
    event: string
    action: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ElementInteractionUncheckedCreateWithoutElementInput = {
    id?: number
    event: string
    action: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ElementInteractionCreateOrConnectWithoutElementInput = {
    where: ElementInteractionWhereUniqueInput
    create: XOR<ElementInteractionCreateWithoutElementInput, ElementInteractionUncheckedCreateWithoutElementInput>
  }

  export type ElementInteractionCreateManyElementInputEnvelope = {
    data: ElementInteractionCreateManyElementInput | ElementInteractionCreateManyElementInput[]
    skipDuplicates?: boolean
  }

  export type ElementValidationCreateWithoutElementInput = {
    rule: string
    value: JsonNullValueInput | InputJsonValue
    message: string
    createdAt?: Date | string
  }

  export type ElementValidationUncheckedCreateWithoutElementInput = {
    id?: number
    rule: string
    value: JsonNullValueInput | InputJsonValue
    message: string
    createdAt?: Date | string
  }

  export type ElementValidationCreateOrConnectWithoutElementInput = {
    where: ElementValidationWhereUniqueInput
    create: XOR<ElementValidationCreateWithoutElementInput, ElementValidationUncheckedCreateWithoutElementInput>
  }

  export type ElementValidationCreateManyElementInputEnvelope = {
    data: ElementValidationCreateManyElementInput | ElementValidationCreateManyElementInput[]
    skipDuplicates?: boolean
  }

  export type CanvasUpsertWithoutElementsInput = {
    update: XOR<CanvasUpdateWithoutElementsInput, CanvasUncheckedUpdateWithoutElementsInput>
    create: XOR<CanvasCreateWithoutElementsInput, CanvasUncheckedCreateWithoutElementsInput>
    where?: CanvasWhereInput
  }

  export type CanvasUpdateToOneWithWhereWithoutElementsInput = {
    where?: CanvasWhereInput
    data: XOR<CanvasUpdateWithoutElementsInput, CanvasUncheckedUpdateWithoutElementsInput>
  }

  export type CanvasUpdateWithoutElementsInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    snapEnabled?: BoolFieldUpdateOperationsInput | boolean
    zoomLevel?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    app?: AppUpdateOneRequiredWithoutCanvasNestedInput
    history?: CanvasHistoryUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateWithoutElementsInput = {
    id?: IntFieldUpdateOperationsInput | number
    appId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    snapEnabled?: BoolFieldUpdateOperationsInput | boolean
    zoomLevel?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    history?: CanvasHistoryUncheckedUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasElementUpsertWithoutChildrenInput = {
    update: XOR<CanvasElementUpdateWithoutChildrenInput, CanvasElementUncheckedUpdateWithoutChildrenInput>
    create: XOR<CanvasElementCreateWithoutChildrenInput, CanvasElementUncheckedCreateWithoutChildrenInput>
    where?: CanvasElementWhereInput
  }

  export type CanvasElementUpdateToOneWithWhereWithoutChildrenInput = {
    where?: CanvasElementWhereInput
    data: XOR<CanvasElementUpdateWithoutChildrenInput, CanvasElementUncheckedUpdateWithoutChildrenInput>
  }

  export type CanvasElementUpdateWithoutChildrenInput = {
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutElementsNestedInput
    parent?: CanvasElementUpdateOneWithoutChildrenNestedInput
    interactions?: ElementInteractionUpdateManyWithoutElementNestedInput
    validations?: ElementValidationUpdateManyWithoutElementNestedInput
  }

  export type CanvasElementUncheckedUpdateWithoutChildrenInput = {
    id?: IntFieldUpdateOperationsInput | number
    canvasId?: IntFieldUpdateOperationsInput | number
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    interactions?: ElementInteractionUncheckedUpdateManyWithoutElementNestedInput
    validations?: ElementValidationUncheckedUpdateManyWithoutElementNestedInput
  }

  export type CanvasElementUpsertWithWhereUniqueWithoutParentInput = {
    where: CanvasElementWhereUniqueInput
    update: XOR<CanvasElementUpdateWithoutParentInput, CanvasElementUncheckedUpdateWithoutParentInput>
    create: XOR<CanvasElementCreateWithoutParentInput, CanvasElementUncheckedCreateWithoutParentInput>
  }

  export type CanvasElementUpdateWithWhereUniqueWithoutParentInput = {
    where: CanvasElementWhereUniqueInput
    data: XOR<CanvasElementUpdateWithoutParentInput, CanvasElementUncheckedUpdateWithoutParentInput>
  }

  export type CanvasElementUpdateManyWithWhereWithoutParentInput = {
    where: CanvasElementScalarWhereInput
    data: XOR<CanvasElementUpdateManyMutationInput, CanvasElementUncheckedUpdateManyWithoutParentInput>
  }

  export type ElementInteractionUpsertWithWhereUniqueWithoutElementInput = {
    where: ElementInteractionWhereUniqueInput
    update: XOR<ElementInteractionUpdateWithoutElementInput, ElementInteractionUncheckedUpdateWithoutElementInput>
    create: XOR<ElementInteractionCreateWithoutElementInput, ElementInteractionUncheckedCreateWithoutElementInput>
  }

  export type ElementInteractionUpdateWithWhereUniqueWithoutElementInput = {
    where: ElementInteractionWhereUniqueInput
    data: XOR<ElementInteractionUpdateWithoutElementInput, ElementInteractionUncheckedUpdateWithoutElementInput>
  }

  export type ElementInteractionUpdateManyWithWhereWithoutElementInput = {
    where: ElementInteractionScalarWhereInput
    data: XOR<ElementInteractionUpdateManyMutationInput, ElementInteractionUncheckedUpdateManyWithoutElementInput>
  }

  export type ElementInteractionScalarWhereInput = {
    AND?: ElementInteractionScalarWhereInput | ElementInteractionScalarWhereInput[]
    OR?: ElementInteractionScalarWhereInput[]
    NOT?: ElementInteractionScalarWhereInput | ElementInteractionScalarWhereInput[]
    id?: IntFilter<"ElementInteraction"> | number
    elementId?: IntFilter<"ElementInteraction"> | number
    event?: StringFilter<"ElementInteraction"> | string
    action?: JsonFilter<"ElementInteraction">
    createdAt?: DateTimeFilter<"ElementInteraction"> | Date | string
  }

  export type ElementValidationUpsertWithWhereUniqueWithoutElementInput = {
    where: ElementValidationWhereUniqueInput
    update: XOR<ElementValidationUpdateWithoutElementInput, ElementValidationUncheckedUpdateWithoutElementInput>
    create: XOR<ElementValidationCreateWithoutElementInput, ElementValidationUncheckedCreateWithoutElementInput>
  }

  export type ElementValidationUpdateWithWhereUniqueWithoutElementInput = {
    where: ElementValidationWhereUniqueInput
    data: XOR<ElementValidationUpdateWithoutElementInput, ElementValidationUncheckedUpdateWithoutElementInput>
  }

  export type ElementValidationUpdateManyWithWhereWithoutElementInput = {
    where: ElementValidationScalarWhereInput
    data: XOR<ElementValidationUpdateManyMutationInput, ElementValidationUncheckedUpdateManyWithoutElementInput>
  }

  export type ElementValidationScalarWhereInput = {
    AND?: ElementValidationScalarWhereInput | ElementValidationScalarWhereInput[]
    OR?: ElementValidationScalarWhereInput[]
    NOT?: ElementValidationScalarWhereInput | ElementValidationScalarWhereInput[]
    id?: IntFilter<"ElementValidation"> | number
    elementId?: IntFilter<"ElementValidation"> | number
    rule?: StringFilter<"ElementValidation"> | string
    value?: JsonFilter<"ElementValidation">
    message?: StringFilter<"ElementValidation"> | string
    createdAt?: DateTimeFilter<"ElementValidation"> | Date | string
  }

  export type CanvasElementCreateWithoutInteractionsInput = {
    elementId: string
    type: $Enums.ElementType
    name?: string
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    zIndex?: number
    locked?: boolean
    visible?: boolean
    groupId?: string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutElementsInput
    parent?: CanvasElementCreateNestedOneWithoutChildrenInput
    children?: CanvasElementCreateNestedManyWithoutParentInput
    validations?: ElementValidationCreateNestedManyWithoutElementInput
  }

  export type CanvasElementUncheckedCreateWithoutInteractionsInput = {
    id?: number
    canvasId: number
    elementId: string
    type: $Enums.ElementType
    name?: string
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    zIndex?: number
    locked?: boolean
    visible?: boolean
    groupId?: string | null
    parentId?: number | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CanvasElementUncheckedCreateNestedManyWithoutParentInput
    validations?: ElementValidationUncheckedCreateNestedManyWithoutElementInput
  }

  export type CanvasElementCreateOrConnectWithoutInteractionsInput = {
    where: CanvasElementWhereUniqueInput
    create: XOR<CanvasElementCreateWithoutInteractionsInput, CanvasElementUncheckedCreateWithoutInteractionsInput>
  }

  export type CanvasElementUpsertWithoutInteractionsInput = {
    update: XOR<CanvasElementUpdateWithoutInteractionsInput, CanvasElementUncheckedUpdateWithoutInteractionsInput>
    create: XOR<CanvasElementCreateWithoutInteractionsInput, CanvasElementUncheckedCreateWithoutInteractionsInput>
    where?: CanvasElementWhereInput
  }

  export type CanvasElementUpdateToOneWithWhereWithoutInteractionsInput = {
    where?: CanvasElementWhereInput
    data: XOR<CanvasElementUpdateWithoutInteractionsInput, CanvasElementUncheckedUpdateWithoutInteractionsInput>
  }

  export type CanvasElementUpdateWithoutInteractionsInput = {
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutElementsNestedInput
    parent?: CanvasElementUpdateOneWithoutChildrenNestedInput
    children?: CanvasElementUpdateManyWithoutParentNestedInput
    validations?: ElementValidationUpdateManyWithoutElementNestedInput
  }

  export type CanvasElementUncheckedUpdateWithoutInteractionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    canvasId?: IntFieldUpdateOperationsInput | number
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CanvasElementUncheckedUpdateManyWithoutParentNestedInput
    validations?: ElementValidationUncheckedUpdateManyWithoutElementNestedInput
  }

  export type CanvasElementCreateWithoutValidationsInput = {
    elementId: string
    type: $Enums.ElementType
    name?: string
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    zIndex?: number
    locked?: boolean
    visible?: boolean
    groupId?: string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    canvas: CanvasCreateNestedOneWithoutElementsInput
    parent?: CanvasElementCreateNestedOneWithoutChildrenInput
    children?: CanvasElementCreateNestedManyWithoutParentInput
    interactions?: ElementInteractionCreateNestedManyWithoutElementInput
  }

  export type CanvasElementUncheckedCreateWithoutValidationsInput = {
    id?: number
    canvasId: number
    elementId: string
    type: $Enums.ElementType
    name?: string
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    zIndex?: number
    locked?: boolean
    visible?: boolean
    groupId?: string | null
    parentId?: number | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    children?: CanvasElementUncheckedCreateNestedManyWithoutParentInput
    interactions?: ElementInteractionUncheckedCreateNestedManyWithoutElementInput
  }

  export type CanvasElementCreateOrConnectWithoutValidationsInput = {
    where: CanvasElementWhereUniqueInput
    create: XOR<CanvasElementCreateWithoutValidationsInput, CanvasElementUncheckedCreateWithoutValidationsInput>
  }

  export type CanvasElementUpsertWithoutValidationsInput = {
    update: XOR<CanvasElementUpdateWithoutValidationsInput, CanvasElementUncheckedUpdateWithoutValidationsInput>
    create: XOR<CanvasElementCreateWithoutValidationsInput, CanvasElementUncheckedCreateWithoutValidationsInput>
    where?: CanvasElementWhereInput
  }

  export type CanvasElementUpdateToOneWithWhereWithoutValidationsInput = {
    where?: CanvasElementWhereInput
    data: XOR<CanvasElementUpdateWithoutValidationsInput, CanvasElementUncheckedUpdateWithoutValidationsInput>
  }

  export type CanvasElementUpdateWithoutValidationsInput = {
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutElementsNestedInput
    parent?: CanvasElementUpdateOneWithoutChildrenNestedInput
    children?: CanvasElementUpdateManyWithoutParentNestedInput
    interactions?: ElementInteractionUpdateManyWithoutElementNestedInput
  }

  export type CanvasElementUncheckedUpdateWithoutValidationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    canvasId?: IntFieldUpdateOperationsInput | number
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CanvasElementUncheckedUpdateManyWithoutParentNestedInput
    interactions?: ElementInteractionUncheckedUpdateManyWithoutElementNestedInput
  }

  export type CanvasCreateWithoutHistoryInput = {
    name?: string
    description?: string | null
    width?: number
    height?: number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: boolean
    snapEnabled?: boolean
    zoomLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    app: AppCreateNestedOneWithoutCanvasInput
    elements?: CanvasElementCreateNestedManyWithoutCanvasInput
  }

  export type CanvasUncheckedCreateWithoutHistoryInput = {
    id?: number
    appId: number
    name?: string
    description?: string | null
    width?: number
    height?: number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: boolean
    snapEnabled?: boolean
    zoomLevel?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    elements?: CanvasElementUncheckedCreateNestedManyWithoutCanvasInput
  }

  export type CanvasCreateOrConnectWithoutHistoryInput = {
    where: CanvasWhereUniqueInput
    create: XOR<CanvasCreateWithoutHistoryInput, CanvasUncheckedCreateWithoutHistoryInput>
  }

  export type UserCreateWithoutCanvasHistoryInput = {
    email: string
    password: string
    createdAt?: Date | string
    role?: string
    updatedAt?: Date | string
    verified?: boolean
    apps?: AppCreateNestedManyWithoutOwnerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    mediaFiles?: MediaFileCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutCanvasHistoryInput = {
    id?: number
    email: string
    password: string
    createdAt?: Date | string
    role?: string
    updatedAt?: Date | string
    verified?: boolean
    apps?: AppUncheckedCreateNestedManyWithoutOwnerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    mediaFiles?: MediaFileUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutCanvasHistoryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCanvasHistoryInput, UserUncheckedCreateWithoutCanvasHistoryInput>
  }

  export type CanvasUpsertWithoutHistoryInput = {
    update: XOR<CanvasUpdateWithoutHistoryInput, CanvasUncheckedUpdateWithoutHistoryInput>
    create: XOR<CanvasCreateWithoutHistoryInput, CanvasUncheckedCreateWithoutHistoryInput>
    where?: CanvasWhereInput
  }

  export type CanvasUpdateToOneWithWhereWithoutHistoryInput = {
    where?: CanvasWhereInput
    data: XOR<CanvasUpdateWithoutHistoryInput, CanvasUncheckedUpdateWithoutHistoryInput>
  }

  export type CanvasUpdateWithoutHistoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    snapEnabled?: BoolFieldUpdateOperationsInput | boolean
    zoomLevel?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    app?: AppUpdateOneRequiredWithoutCanvasNestedInput
    elements?: CanvasElementUpdateManyWithoutCanvasNestedInput
  }

  export type CanvasUncheckedUpdateWithoutHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    appId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    width?: IntFieldUpdateOperationsInput | number
    height?: IntFieldUpdateOperationsInput | number
    background?: JsonNullValueInput | InputJsonValue
    gridEnabled?: BoolFieldUpdateOperationsInput | boolean
    snapEnabled?: BoolFieldUpdateOperationsInput | boolean
    zoomLevel?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    elements?: CanvasElementUncheckedUpdateManyWithoutCanvasNestedInput
  }

  export type UserUpsertWithoutCanvasHistoryInput = {
    update: XOR<UserUpdateWithoutCanvasHistoryInput, UserUncheckedUpdateWithoutCanvasHistoryInput>
    create: XOR<UserCreateWithoutCanvasHistoryInput, UserUncheckedCreateWithoutCanvasHistoryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCanvasHistoryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCanvasHistoryInput, UserUncheckedUpdateWithoutCanvasHistoryInput>
  }

  export type UserUpdateWithoutCanvasHistoryInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    apps?: AppUpdateManyWithoutOwnerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutCanvasHistoryInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    apps?: AppUncheckedUpdateManyWithoutOwnerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserCreateWithoutMediaFilesInput = {
    email: string
    password: string
    createdAt?: Date | string
    role?: string
    updatedAt?: Date | string
    verified?: boolean
    apps?: AppCreateNestedManyWithoutOwnerInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    canvasHistory?: CanvasHistoryCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutMediaFilesInput = {
    id?: number
    email: string
    password: string
    createdAt?: Date | string
    role?: string
    updatedAt?: Date | string
    verified?: boolean
    apps?: AppUncheckedCreateNestedManyWithoutOwnerInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    canvasHistory?: CanvasHistoryUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutMediaFilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMediaFilesInput, UserUncheckedCreateWithoutMediaFilesInput>
  }

  export type AppCreateWithoutMediaFilesInput = {
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutAppsInput
    template?: TemplateCreateNestedOneWithoutAppsInput
    components?: ComponentCreateNestedManyWithoutAppInput
    workflows?: WorkflowCreateNestedManyWithoutAppInput
    schemas?: AppSchemaCreateNestedManyWithoutAppInput
    metrics?: AppMetricCreateNestedManyWithoutAppInput
    issues?: AppIssueCreateNestedManyWithoutAppInput
    warnings?: AppWarningCreateNestedManyWithoutAppInput
    canvas?: CanvasCreateNestedOneWithoutAppInput
  }

  export type AppUncheckedCreateWithoutMediaFilesInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    ownerId: number
    templateId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
    components?: ComponentUncheckedCreateNestedManyWithoutAppInput
    workflows?: WorkflowUncheckedCreateNestedManyWithoutAppInput
    schemas?: AppSchemaUncheckedCreateNestedManyWithoutAppInput
    metrics?: AppMetricUncheckedCreateNestedManyWithoutAppInput
    issues?: AppIssueUncheckedCreateNestedManyWithoutAppInput
    warnings?: AppWarningUncheckedCreateNestedManyWithoutAppInput
    canvas?: CanvasUncheckedCreateNestedOneWithoutAppInput
  }

  export type AppCreateOrConnectWithoutMediaFilesInput = {
    where: AppWhereUniqueInput
    create: XOR<AppCreateWithoutMediaFilesInput, AppUncheckedCreateWithoutMediaFilesInput>
  }

  export type UserUpsertWithoutMediaFilesInput = {
    update: XOR<UserUpdateWithoutMediaFilesInput, UserUncheckedUpdateWithoutMediaFilesInput>
    create: XOR<UserCreateWithoutMediaFilesInput, UserUncheckedCreateWithoutMediaFilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMediaFilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMediaFilesInput, UserUncheckedUpdateWithoutMediaFilesInput>
  }

  export type UserUpdateWithoutMediaFilesInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    apps?: AppUpdateManyWithoutOwnerNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    canvasHistory?: CanvasHistoryUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutMediaFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    role?: StringFieldUpdateOperationsInput | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    apps?: AppUncheckedUpdateManyWithoutOwnerNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    canvasHistory?: CanvasHistoryUncheckedUpdateManyWithoutUserNestedInput
  }

  export type AppUpsertWithoutMediaFilesInput = {
    update: XOR<AppUpdateWithoutMediaFilesInput, AppUncheckedUpdateWithoutMediaFilesInput>
    create: XOR<AppCreateWithoutMediaFilesInput, AppUncheckedCreateWithoutMediaFilesInput>
    where?: AppWhereInput
  }

  export type AppUpdateToOneWithWhereWithoutMediaFilesInput = {
    where?: AppWhereInput
    data: XOR<AppUpdateWithoutMediaFilesInput, AppUncheckedUpdateWithoutMediaFilesInput>
  }

  export type AppUpdateWithoutMediaFilesInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutAppsNestedInput
    template?: TemplateUpdateOneWithoutAppsNestedInput
    components?: ComponentUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUpdateManyWithoutAppNestedInput
    issues?: AppIssueUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUpdateManyWithoutAppNestedInput
    canvas?: CanvasUpdateOneWithoutAppNestedInput
  }

  export type AppUncheckedUpdateWithoutMediaFilesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: IntFieldUpdateOperationsInput | number
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ComponentUncheckedUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUncheckedUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUncheckedUpdateManyWithoutAppNestedInput
    issues?: AppIssueUncheckedUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUncheckedUpdateManyWithoutAppNestedInput
    canvas?: CanvasUncheckedUpdateOneWithoutAppNestedInput
  }

  export type AppCreateManyOwnerInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    templateId?: number | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: number
    type: string
    message: string
    read?: boolean
    createdAt?: Date | string
  }

  export type CanvasHistoryCreateManyUserInput = {
    id?: number
    canvasId: number
    action: string
    elementId?: string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type MediaFileCreateManyUserInput = {
    id?: number
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    thumbnail?: string | null
    appId?: number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AppUpdateWithoutOwnerInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    template?: TemplateUpdateOneWithoutAppsNestedInput
    components?: ComponentUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUpdateManyWithoutAppNestedInput
    issues?: AppIssueUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUpdateManyWithoutAppNestedInput
    canvas?: CanvasUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutAppNestedInput
  }

  export type AppUncheckedUpdateWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ComponentUncheckedUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUncheckedUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUncheckedUpdateManyWithoutAppNestedInput
    issues?: AppIssueUncheckedUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUncheckedUpdateManyWithoutAppNestedInput
    canvas?: CanvasUncheckedUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutAppNestedInput
  }

  export type AppUncheckedUpdateManyWithoutOwnerInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    templateId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    type?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    read?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasHistoryUpdateWithoutUserInput = {
    action?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutHistoryNestedInput
  }

  export type CanvasHistoryUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    canvasId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasHistoryUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    canvasId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileUpdateWithoutUserInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    app?: AppUpdateOneWithoutMediaFilesNestedInput
  }

  export type MediaFileUncheckedUpdateWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    appId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileUncheckedUpdateManyWithoutUserInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    appId?: NullableIntFieldUpdateOperationsInput | number | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComponentCreateManyAppInput = {
    id?: number
    name: string
    type: string
    properties: JsonNullValueInput | InputJsonValue
  }

  export type WorkflowCreateManyAppInput = {
    id?: number
    name: string
    steps: JsonNullValueInput | InputJsonValue
  }

  export type AppSchemaCreateManyAppInput = {
    id?: number
    name: string
    createdAt?: Date | string
  }

  export type AppMetricCreateManyAppInput = {
    id?: number
    activeDays: number
    downtime: number
    totalUsers: number
    traffic: number
    createdAt?: Date | string
  }

  export type AppIssueCreateManyAppInput = {
    id?: number
    severity: $Enums.IssueSeverity
    description: string
    status?: $Enums.IssueStatus
    createdAt?: Date | string
  }

  export type AppWarningCreateManyAppInput = {
    id?: number
    message: string
    createdAt?: Date | string
  }

  export type MediaFileCreateManyAppInput = {
    id?: number
    filename: string
    originalName: string
    mimeType: string
    size: number
    url: string
    thumbnail?: string | null
    userId: number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ComponentUpdateWithoutAppInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    properties?: JsonNullValueInput | InputJsonValue
  }

  export type ComponentUncheckedUpdateWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    properties?: JsonNullValueInput | InputJsonValue
  }

  export type ComponentUncheckedUpdateManyWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    properties?: JsonNullValueInput | InputJsonValue
  }

  export type WorkflowUpdateWithoutAppInput = {
    name?: StringFieldUpdateOperationsInput | string
    steps?: JsonNullValueInput | InputJsonValue
  }

  export type WorkflowUncheckedUpdateWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    steps?: JsonNullValueInput | InputJsonValue
  }

  export type WorkflowUncheckedUpdateManyWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    steps?: JsonNullValueInput | InputJsonValue
  }

  export type AppSchemaUpdateWithoutAppInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: AppDataUpdateManyWithoutSchemaNestedInput
    relatedFields?: AppFieldUpdateManyWithoutRelatedSchemaNestedInput
    fields?: AppFieldUpdateManyWithoutSchemaNestedInput
  }

  export type AppSchemaUncheckedUpdateWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: AppDataUncheckedUpdateManyWithoutSchemaNestedInput
    relatedFields?: AppFieldUncheckedUpdateManyWithoutRelatedSchemaNestedInput
    fields?: AppFieldUncheckedUpdateManyWithoutSchemaNestedInput
  }

  export type AppSchemaUncheckedUpdateManyWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppMetricUpdateWithoutAppInput = {
    activeDays?: IntFieldUpdateOperationsInput | number
    downtime?: FloatFieldUpdateOperationsInput | number
    totalUsers?: IntFieldUpdateOperationsInput | number
    traffic?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppMetricUncheckedUpdateWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeDays?: IntFieldUpdateOperationsInput | number
    downtime?: FloatFieldUpdateOperationsInput | number
    totalUsers?: IntFieldUpdateOperationsInput | number
    traffic?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppMetricUncheckedUpdateManyWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    activeDays?: IntFieldUpdateOperationsInput | number
    downtime?: FloatFieldUpdateOperationsInput | number
    totalUsers?: IntFieldUpdateOperationsInput | number
    traffic?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppIssueUpdateWithoutAppInput = {
    severity?: EnumIssueSeverityFieldUpdateOperationsInput | $Enums.IssueSeverity
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppIssueUncheckedUpdateWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    severity?: EnumIssueSeverityFieldUpdateOperationsInput | $Enums.IssueSeverity
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppIssueUncheckedUpdateManyWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    severity?: EnumIssueSeverityFieldUpdateOperationsInput | $Enums.IssueSeverity
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumIssueStatusFieldUpdateOperationsInput | $Enums.IssueStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppWarningUpdateWithoutAppInput = {
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppWarningUncheckedUpdateWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppWarningUncheckedUpdateManyWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileUpdateWithoutAppInput = {
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutMediaFilesNestedInput
  }

  export type MediaFileUncheckedUpdateWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MediaFileUncheckedUpdateManyWithoutAppInput = {
    id?: IntFieldUpdateOperationsInput | number
    filename?: StringFieldUpdateOperationsInput | string
    originalName?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    size?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: IntFieldUpdateOperationsInput | number
    metadata?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppCreateManyTemplateInput = {
    id?: number
    name: string
    description?: string | null
    status?: $Enums.AppStatus
    archived?: boolean
    ownerId: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AppUpdateWithoutTemplateInput = {
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutAppsNestedInput
    components?: ComponentUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUpdateManyWithoutAppNestedInput
    issues?: AppIssueUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUpdateManyWithoutAppNestedInput
    canvas?: CanvasUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUpdateManyWithoutAppNestedInput
  }

  export type AppUncheckedUpdateWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    components?: ComponentUncheckedUpdateManyWithoutAppNestedInput
    workflows?: WorkflowUncheckedUpdateManyWithoutAppNestedInput
    schemas?: AppSchemaUncheckedUpdateManyWithoutAppNestedInput
    metrics?: AppMetricUncheckedUpdateManyWithoutAppNestedInput
    issues?: AppIssueUncheckedUpdateManyWithoutAppNestedInput
    warnings?: AppWarningUncheckedUpdateManyWithoutAppNestedInput
    canvas?: CanvasUncheckedUpdateOneWithoutAppNestedInput
    mediaFiles?: MediaFileUncheckedUpdateManyWithoutAppNestedInput
  }

  export type AppUncheckedUpdateManyWithoutTemplateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    status?: EnumAppStatusFieldUpdateOperationsInput | $Enums.AppStatus
    archived?: BoolFieldUpdateOperationsInput | boolean
    ownerId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppDataCreateManySchemaInput = {
    id?: number
    data: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AppFieldCreateManyRelatedSchemaInput = {
    id?: number
    schemaId: number
    name: string
    type: $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type AppFieldCreateManySchemaInput = {
    id?: number
    name: string
    type: $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    relatedSchemaId?: number | null
    createdAt?: Date | string
  }

  export type AppDataUpdateWithoutSchemaInput = {
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppDataUncheckedUpdateWithoutSchemaInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppDataUncheckedUpdateManyWithoutSchemaInput = {
    id?: IntFieldUpdateOperationsInput | number
    data?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppFieldUpdateWithoutRelatedSchemaInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    schema?: AppSchemaUpdateOneRequiredWithoutFieldsNestedInput
  }

  export type AppFieldUncheckedUpdateWithoutRelatedSchemaInput = {
    id?: IntFieldUpdateOperationsInput | number
    schemaId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppFieldUncheckedUpdateManyWithoutRelatedSchemaInput = {
    id?: IntFieldUpdateOperationsInput | number
    schemaId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppFieldUpdateWithoutSchemaInput = {
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    relatedSchema?: AppSchemaUpdateOneWithoutRelatedFieldsNestedInput
  }

  export type AppFieldUncheckedUpdateWithoutSchemaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    relatedSchemaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AppFieldUncheckedUpdateManyWithoutSchemaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    type?: EnumFieldTypeFieldUpdateOperationsInput | $Enums.FieldType
    constraints?: JsonNullValueInput | InputJsonValue
    relatedSchemaId?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasElementCreateManyCanvasInput = {
    id?: number
    elementId: string
    type: $Enums.ElementType
    name?: string
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    zIndex?: number
    locked?: boolean
    visible?: boolean
    groupId?: string | null
    parentId?: number | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CanvasHistoryCreateManyCanvasInput = {
    id?: number
    action: string
    elementId?: string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    userId: number
    createdAt?: Date | string
  }

  export type CanvasElementUpdateWithoutCanvasInput = {
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: CanvasElementUpdateOneWithoutChildrenNestedInput
    children?: CanvasElementUpdateManyWithoutParentNestedInput
    interactions?: ElementInteractionUpdateManyWithoutElementNestedInput
    validations?: ElementValidationUpdateManyWithoutElementNestedInput
  }

  export type CanvasElementUncheckedUpdateWithoutCanvasInput = {
    id?: IntFieldUpdateOperationsInput | number
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CanvasElementUncheckedUpdateManyWithoutParentNestedInput
    interactions?: ElementInteractionUncheckedUpdateManyWithoutElementNestedInput
    validations?: ElementValidationUncheckedUpdateManyWithoutElementNestedInput
  }

  export type CanvasElementUncheckedUpdateManyWithoutCanvasInput = {
    id?: IntFieldUpdateOperationsInput | number
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableIntFieldUpdateOperationsInput | number | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasHistoryUpdateWithoutCanvasInput = {
    action?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCanvasHistoryNestedInput
  }

  export type CanvasHistoryUncheckedUpdateWithoutCanvasInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasHistoryUncheckedUpdateManyWithoutCanvasInput = {
    id?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    elementId?: NullableStringFieldUpdateOperationsInput | string | null
    oldState?: NullableJsonNullValueInput | InputJsonValue
    newState?: NullableJsonNullValueInput | InputJsonValue
    userId?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CanvasElementCreateManyParentInput = {
    id?: number
    canvasId: number
    elementId: string
    type: $Enums.ElementType
    name?: string
    x?: number
    y?: number
    width?: number
    height?: number
    rotation?: number
    zIndex?: number
    locked?: boolean
    visible?: boolean
    groupId?: string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ElementInteractionCreateManyElementInput = {
    id?: number
    event: string
    action: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
  }

  export type ElementValidationCreateManyElementInput = {
    id?: number
    rule: string
    value: JsonNullValueInput | InputJsonValue
    message: string
    createdAt?: Date | string
  }

  export type CanvasElementUpdateWithoutParentInput = {
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    canvas?: CanvasUpdateOneRequiredWithoutElementsNestedInput
    children?: CanvasElementUpdateManyWithoutParentNestedInput
    interactions?: ElementInteractionUpdateManyWithoutElementNestedInput
    validations?: ElementValidationUpdateManyWithoutElementNestedInput
  }

  export type CanvasElementUncheckedUpdateWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    canvasId?: IntFieldUpdateOperationsInput | number
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: CanvasElementUncheckedUpdateManyWithoutParentNestedInput
    interactions?: ElementInteractionUncheckedUpdateManyWithoutElementNestedInput
    validations?: ElementValidationUncheckedUpdateManyWithoutElementNestedInput
  }

  export type CanvasElementUncheckedUpdateManyWithoutParentInput = {
    id?: IntFieldUpdateOperationsInput | number
    canvasId?: IntFieldUpdateOperationsInput | number
    elementId?: StringFieldUpdateOperationsInput | string
    type?: EnumElementTypeFieldUpdateOperationsInput | $Enums.ElementType
    name?: StringFieldUpdateOperationsInput | string
    x?: FloatFieldUpdateOperationsInput | number
    y?: FloatFieldUpdateOperationsInput | number
    width?: FloatFieldUpdateOperationsInput | number
    height?: FloatFieldUpdateOperationsInput | number
    rotation?: FloatFieldUpdateOperationsInput | number
    zIndex?: IntFieldUpdateOperationsInput | number
    locked?: BoolFieldUpdateOperationsInput | boolean
    visible?: BoolFieldUpdateOperationsInput | boolean
    groupId?: NullableStringFieldUpdateOperationsInput | string | null
    properties?: JsonNullValueInput | InputJsonValue
    styles?: JsonNullValueInput | InputJsonValue
    constraints?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementInteractionUpdateWithoutElementInput = {
    event?: StringFieldUpdateOperationsInput | string
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementInteractionUncheckedUpdateWithoutElementInput = {
    id?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementInteractionUncheckedUpdateManyWithoutElementInput = {
    id?: IntFieldUpdateOperationsInput | number
    event?: StringFieldUpdateOperationsInput | string
    action?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementValidationUpdateWithoutElementInput = {
    rule?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementValidationUncheckedUpdateWithoutElementInput = {
    id?: IntFieldUpdateOperationsInput | number
    rule?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ElementValidationUncheckedUpdateManyWithoutElementInput = {
    id?: IntFieldUpdateOperationsInput | number
    rule?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    message?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}